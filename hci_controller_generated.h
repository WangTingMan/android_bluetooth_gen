// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_HCICONTROLLER_BLUETOOTH_HCI_H_
#define FLATBUFFERS_GENERATED_HCICONTROLLER_BLUETOOTH_HCI_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 2 &&
              FLATBUFFERS_VERSION_MINOR == 0 &&
              FLATBUFFERS_VERSION_REVISION == 7,
             "Non-compatible flatbuffers version included");

namespace bluetooth {
namespace hci {

struct LocalVersionInformationData;
struct LocalVersionInformationDataBuilder;

struct BufferSizeData;

struct LeMaximumDataLengthData;

struct VendorCapabilitiesData;

struct LocalSupportedCommandsData;

struct ControllerData;
struct ControllerDataBuilder;

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(2) BufferSizeData FLATBUFFERS_FINAL_CLASS {
 private:
  uint16_t data_packet_length_;
  uint8_t total_num_packets_;
  int8_t padding0__;

 public:
  BufferSizeData()
      : data_packet_length_(0),
        total_num_packets_(0),
        padding0__(0) {
    (void)padding0__;
  }
  BufferSizeData(uint16_t _data_packet_length, uint8_t _total_num_packets)
      : data_packet_length_(flatbuffers::EndianScalar(_data_packet_length)),
        total_num_packets_(flatbuffers::EndianScalar(_total_num_packets)),
        padding0__(0) {
    (void)padding0__;
  }
  uint16_t data_packet_length() const {
    return flatbuffers::EndianScalar(data_packet_length_);
  }
  uint8_t total_num_packets() const {
    return flatbuffers::EndianScalar(total_num_packets_);
  }
};
FLATBUFFERS_STRUCT_END(BufferSizeData, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(2) LeMaximumDataLengthData FLATBUFFERS_FINAL_CLASS {
 private:
  uint16_t supported_max_tx_octets_;
  uint16_t supported_max_tx_time_;
  uint16_t supported_max_rx_octets_;
  uint16_t supported_max_rx_time_;

 public:
  LeMaximumDataLengthData()
      : supported_max_tx_octets_(0),
        supported_max_tx_time_(0),
        supported_max_rx_octets_(0),
        supported_max_rx_time_(0) {
  }
  LeMaximumDataLengthData(uint16_t _supported_max_tx_octets, uint16_t _supported_max_tx_time, uint16_t _supported_max_rx_octets, uint16_t _supported_max_rx_time)
      : supported_max_tx_octets_(flatbuffers::EndianScalar(_supported_max_tx_octets)),
        supported_max_tx_time_(flatbuffers::EndianScalar(_supported_max_tx_time)),
        supported_max_rx_octets_(flatbuffers::EndianScalar(_supported_max_rx_octets)),
        supported_max_rx_time_(flatbuffers::EndianScalar(_supported_max_rx_time)) {
  }
  uint16_t supported_max_tx_octets() const {
    return flatbuffers::EndianScalar(supported_max_tx_octets_);
  }
  uint16_t supported_max_tx_time() const {
    return flatbuffers::EndianScalar(supported_max_tx_time_);
  }
  uint16_t supported_max_rx_octets() const {
    return flatbuffers::EndianScalar(supported_max_rx_octets_);
  }
  uint16_t supported_max_rx_time() const {
    return flatbuffers::EndianScalar(supported_max_rx_time_);
  }
};
FLATBUFFERS_STRUCT_END(LeMaximumDataLengthData, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) VendorCapabilitiesData FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t is_supported_;
  uint8_t max_advt_instances_;
  uint8_t offloaded_resolution_of_private_address_;
  int8_t padding0__;
  uint16_t total_scan_results_storage_;
  uint8_t max_irk_list_sz_;
  uint8_t filtering_support_;
  uint8_t max_filter_;
  uint8_t activity_energy_info_support_;
  uint16_t version_supported_;
  uint16_t total_num_of_advt_tracked_;
  uint8_t extended_scan_support_;
  uint8_t debug_logging_supported_;
  uint8_t le_address_generation_offloading_support_;
  int8_t padding1__;  int16_t padding2__;
  uint32_t a2dp_source_offload_capability_mask_;
  uint8_t bluetooth_quality_report_support_;
  int8_t padding3__;  int16_t padding4__;

 public:
  VendorCapabilitiesData()
      : is_supported_(0),
        max_advt_instances_(0),
        offloaded_resolution_of_private_address_(0),
        padding0__(0),
        total_scan_results_storage_(0),
        max_irk_list_sz_(0),
        filtering_support_(0),
        max_filter_(0),
        activity_energy_info_support_(0),
        version_supported_(0),
        total_num_of_advt_tracked_(0),
        extended_scan_support_(0),
        debug_logging_supported_(0),
        le_address_generation_offloading_support_(0),
        padding1__(0),
        padding2__(0),
        a2dp_source_offload_capability_mask_(0),
        bluetooth_quality_report_support_(0),
        padding3__(0),
        padding4__(0) {
    (void)padding0__;
    (void)padding1__;
    (void)padding2__;
    (void)padding3__;
    (void)padding4__;
  }
  VendorCapabilitiesData(uint8_t _is_supported, uint8_t _max_advt_instances, uint8_t _offloaded_resolution_of_private_address, uint16_t _total_scan_results_storage, uint8_t _max_irk_list_sz, uint8_t _filtering_support, uint8_t _max_filter, uint8_t _activity_energy_info_support, uint16_t _version_supported, uint16_t _total_num_of_advt_tracked, uint8_t _extended_scan_support, uint8_t _debug_logging_supported, uint8_t _le_address_generation_offloading_support, uint32_t _a2dp_source_offload_capability_mask, uint8_t _bluetooth_quality_report_support)
      : is_supported_(flatbuffers::EndianScalar(_is_supported)),
        max_advt_instances_(flatbuffers::EndianScalar(_max_advt_instances)),
        offloaded_resolution_of_private_address_(flatbuffers::EndianScalar(_offloaded_resolution_of_private_address)),
        padding0__(0),
        total_scan_results_storage_(flatbuffers::EndianScalar(_total_scan_results_storage)),
        max_irk_list_sz_(flatbuffers::EndianScalar(_max_irk_list_sz)),
        filtering_support_(flatbuffers::EndianScalar(_filtering_support)),
        max_filter_(flatbuffers::EndianScalar(_max_filter)),
        activity_energy_info_support_(flatbuffers::EndianScalar(_activity_energy_info_support)),
        version_supported_(flatbuffers::EndianScalar(_version_supported)),
        total_num_of_advt_tracked_(flatbuffers::EndianScalar(_total_num_of_advt_tracked)),
        extended_scan_support_(flatbuffers::EndianScalar(_extended_scan_support)),
        debug_logging_supported_(flatbuffers::EndianScalar(_debug_logging_supported)),
        le_address_generation_offloading_support_(flatbuffers::EndianScalar(_le_address_generation_offloading_support)),
        padding1__(0),
        padding2__(0),
        a2dp_source_offload_capability_mask_(flatbuffers::EndianScalar(_a2dp_source_offload_capability_mask)),
        bluetooth_quality_report_support_(flatbuffers::EndianScalar(_bluetooth_quality_report_support)),
        padding3__(0),
        padding4__(0) {
    (void)padding0__;
    (void)padding1__;
    (void)padding2__;
    (void)padding3__;
    (void)padding4__;
  }
  uint8_t is_supported() const {
    return flatbuffers::EndianScalar(is_supported_);
  }
  uint8_t max_advt_instances() const {
    return flatbuffers::EndianScalar(max_advt_instances_);
  }
  uint8_t offloaded_resolution_of_private_address() const {
    return flatbuffers::EndianScalar(offloaded_resolution_of_private_address_);
  }
  uint16_t total_scan_results_storage() const {
    return flatbuffers::EndianScalar(total_scan_results_storage_);
  }
  uint8_t max_irk_list_sz() const {
    return flatbuffers::EndianScalar(max_irk_list_sz_);
  }
  uint8_t filtering_support() const {
    return flatbuffers::EndianScalar(filtering_support_);
  }
  uint8_t max_filter() const {
    return flatbuffers::EndianScalar(max_filter_);
  }
  uint8_t activity_energy_info_support() const {
    return flatbuffers::EndianScalar(activity_energy_info_support_);
  }
  uint16_t version_supported() const {
    return flatbuffers::EndianScalar(version_supported_);
  }
  uint16_t total_num_of_advt_tracked() const {
    return flatbuffers::EndianScalar(total_num_of_advt_tracked_);
  }
  uint8_t extended_scan_support() const {
    return flatbuffers::EndianScalar(extended_scan_support_);
  }
  uint8_t debug_logging_supported() const {
    return flatbuffers::EndianScalar(debug_logging_supported_);
  }
  uint8_t le_address_generation_offloading_support() const {
    return flatbuffers::EndianScalar(le_address_generation_offloading_support_);
  }
  uint32_t a2dp_source_offload_capability_mask() const {
    return flatbuffers::EndianScalar(a2dp_source_offload_capability_mask_);
  }
  uint8_t bluetooth_quality_report_support() const {
    return flatbuffers::EndianScalar(bluetooth_quality_report_support_);
  }
};
FLATBUFFERS_STRUCT_END(VendorCapabilitiesData, 28);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1) LocalSupportedCommandsData FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t index_;
  uint8_t value_;

 public:
  LocalSupportedCommandsData()
      : index_(0),
        value_(0) {
  }
  LocalSupportedCommandsData(uint8_t _index, uint8_t _value)
      : index_(flatbuffers::EndianScalar(_index)),
        value_(flatbuffers::EndianScalar(_value)) {
  }
  uint8_t index() const {
    return flatbuffers::EndianScalar(index_);
  }
  uint8_t value() const {
    return flatbuffers::EndianScalar(value_);
  }
};
FLATBUFFERS_STRUCT_END(LocalSupportedCommandsData, 2);

struct LocalVersionInformationData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LocalVersionInformationDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HCI_VERSION = 4,
    VT_HCI_REVISION = 6,
    VT_LMP_VERSION = 8,
    VT_MANUFACTURER_NAME = 10,
    VT_LMP_SUBVERSION = 12
  };
  const flatbuffers::String *hci_version() const {
    return GetPointer<const flatbuffers::String *>(VT_HCI_VERSION);
  }
  uint16_t hci_revision() const {
    return GetField<uint16_t>(VT_HCI_REVISION, 0);
  }
  const flatbuffers::String *lmp_version() const {
    return GetPointer<const flatbuffers::String *>(VT_LMP_VERSION);
  }
  uint16_t manufacturer_name() const {
    return GetField<uint16_t>(VT_MANUFACTURER_NAME, 0);
  }
  uint16_t lmp_subversion() const {
    return GetField<uint16_t>(VT_LMP_SUBVERSION, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_HCI_VERSION) &&
           verifier.VerifyString(hci_version()) &&
           VerifyField<uint16_t>(verifier, VT_HCI_REVISION, 2) &&
           VerifyOffset(verifier, VT_LMP_VERSION) &&
           verifier.VerifyString(lmp_version()) &&
           VerifyField<uint16_t>(verifier, VT_MANUFACTURER_NAME, 2) &&
           VerifyField<uint16_t>(verifier, VT_LMP_SUBVERSION, 2) &&
           verifier.EndTable();
  }
};

struct LocalVersionInformationDataBuilder {
  typedef LocalVersionInformationData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_hci_version(flatbuffers::Offset<flatbuffers::String> hci_version) {
    fbb_.AddOffset(LocalVersionInformationData::VT_HCI_VERSION, hci_version);
  }
  void add_hci_revision(uint16_t hci_revision) {
    fbb_.AddElement<uint16_t>(LocalVersionInformationData::VT_HCI_REVISION, hci_revision, 0);
  }
  void add_lmp_version(flatbuffers::Offset<flatbuffers::String> lmp_version) {
    fbb_.AddOffset(LocalVersionInformationData::VT_LMP_VERSION, lmp_version);
  }
  void add_manufacturer_name(uint16_t manufacturer_name) {
    fbb_.AddElement<uint16_t>(LocalVersionInformationData::VT_MANUFACTURER_NAME, manufacturer_name, 0);
  }
  void add_lmp_subversion(uint16_t lmp_subversion) {
    fbb_.AddElement<uint16_t>(LocalVersionInformationData::VT_LMP_SUBVERSION, lmp_subversion, 0);
  }
  explicit LocalVersionInformationDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LocalVersionInformationData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LocalVersionInformationData>(end);
    return o;
  }
};

inline flatbuffers::Offset<LocalVersionInformationData> CreateLocalVersionInformationData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> hci_version = 0,
    uint16_t hci_revision = 0,
    flatbuffers::Offset<flatbuffers::String> lmp_version = 0,
    uint16_t manufacturer_name = 0,
    uint16_t lmp_subversion = 0) {
  LocalVersionInformationDataBuilder builder_(_fbb);
  builder_.add_lmp_version(lmp_version);
  builder_.add_hci_version(hci_version);
  builder_.add_lmp_subversion(lmp_subversion);
  builder_.add_manufacturer_name(manufacturer_name);
  builder_.add_hci_revision(hci_revision);
  return builder_.Finish();
}

inline flatbuffers::Offset<LocalVersionInformationData> CreateLocalVersionInformationDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *hci_version = nullptr,
    uint16_t hci_revision = 0,
    const char *lmp_version = nullptr,
    uint16_t manufacturer_name = 0,
    uint16_t lmp_subversion = 0) {
  auto hci_version__ = hci_version ? _fbb.CreateString(hci_version) : 0;
  auto lmp_version__ = lmp_version ? _fbb.CreateString(lmp_version) : 0;
  return bluetooth::hci::CreateLocalVersionInformationData(
      _fbb,
      hci_version__,
      hci_revision,
      lmp_version__,
      manufacturer_name,
      lmp_subversion);
}

struct ControllerData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ControllerDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TITLE = 4,
    VT_LOCAL_VERSION_INFORMATION = 6,
    VT_ACL_BUFFER_SIZE = 8,
    VT_SCO_BUFFER_SIZE = 10,
    VT_ISO_BUFFER_SIZE = 12,
    VT_LE_BUFFER_SIZE = 14,
    VT_LE_ACCEPT_LIST_SIZE = 16,
    VT_LE_RESOLVING_LIST_SIZE = 18,
    VT_LE_MAXIMUM_DATA_LENGTH = 20,
    VT_LE_MAXIMUM_ADVERTISING_DATA_LENGTH = 22,
    VT_LE_SUGGESTED_DEFAULT_DATA_LENGTH = 24,
    VT_LE_NUMBER_SUPPORTED_ADVERTISING_SETS = 26,
    VT_LE_PERIODIC_ADVERTISER_LIST_SIZE = 28,
    VT_LOCAL_SUPPORTED_COMMANDS = 30,
    VT_EXTENDED_LMP_FEATURES_ARRAY = 32,
    VT_LE_LOCAL_SUPPORTED_FEATURES = 34,
    VT_LE_SUPPORTED_STATES = 36,
    VT_VENDOR_CAPABILITIES = 38
  };
  const flatbuffers::String *title() const {
    return GetPointer<const flatbuffers::String *>(VT_TITLE);
  }
  const bluetooth::hci::LocalVersionInformationData *local_version_information() const {
    return GetPointer<const bluetooth::hci::LocalVersionInformationData *>(VT_LOCAL_VERSION_INFORMATION);
  }
  const bluetooth::hci::BufferSizeData *acl_buffer_size() const {
    return GetStruct<const bluetooth::hci::BufferSizeData *>(VT_ACL_BUFFER_SIZE);
  }
  const bluetooth::hci::BufferSizeData *sco_buffer_size() const {
    return GetStruct<const bluetooth::hci::BufferSizeData *>(VT_SCO_BUFFER_SIZE);
  }
  const bluetooth::hci::BufferSizeData *iso_buffer_size() const {
    return GetStruct<const bluetooth::hci::BufferSizeData *>(VT_ISO_BUFFER_SIZE);
  }
  const bluetooth::hci::BufferSizeData *le_buffer_size() const {
    return GetStruct<const bluetooth::hci::BufferSizeData *>(VT_LE_BUFFER_SIZE);
  }
  uint64_t le_accept_list_size() const {
    return GetField<uint64_t>(VT_LE_ACCEPT_LIST_SIZE, 0);
  }
  uint64_t le_resolving_list_size() const {
    return GetField<uint64_t>(VT_LE_RESOLVING_LIST_SIZE, 0);
  }
  const bluetooth::hci::LeMaximumDataLengthData *le_maximum_data_length() const {
    return GetStruct<const bluetooth::hci::LeMaximumDataLengthData *>(VT_LE_MAXIMUM_DATA_LENGTH);
  }
  uint16_t le_maximum_advertising_data_length() const {
    return GetField<uint16_t>(VT_LE_MAXIMUM_ADVERTISING_DATA_LENGTH, 0);
  }
  uint16_t le_suggested_default_data_length() const {
    return GetField<uint16_t>(VT_LE_SUGGESTED_DEFAULT_DATA_LENGTH, 0);
  }
  uint8_t le_number_supported_advertising_sets() const {
    return GetField<uint8_t>(VT_LE_NUMBER_SUPPORTED_ADVERTISING_SETS, 0);
  }
  uint8_t le_periodic_advertiser_list_size() const {
    return GetField<uint8_t>(VT_LE_PERIODIC_ADVERTISER_LIST_SIZE, 0);
  }
  const flatbuffers::Vector<const bluetooth::hci::LocalSupportedCommandsData *> *local_supported_commands() const {
    return GetPointer<const flatbuffers::Vector<const bluetooth::hci::LocalSupportedCommandsData *> *>(VT_LOCAL_SUPPORTED_COMMANDS);
  }
  const flatbuffers::Vector<uint64_t> *extended_lmp_features_array() const {
    return GetPointer<const flatbuffers::Vector<uint64_t> *>(VT_EXTENDED_LMP_FEATURES_ARRAY);
  }
  int64_t le_local_supported_features() const {
    return GetField<int64_t>(VT_LE_LOCAL_SUPPORTED_FEATURES, 0);
  }
  uint64_t le_supported_states() const {
    return GetField<uint64_t>(VT_LE_SUPPORTED_STATES, 0);
  }
  const bluetooth::hci::VendorCapabilitiesData *vendor_capabilities() const {
    return GetStruct<const bluetooth::hci::VendorCapabilitiesData *>(VT_VENDOR_CAPABILITIES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TITLE) &&
           verifier.VerifyString(title()) &&
           VerifyOffset(verifier, VT_LOCAL_VERSION_INFORMATION) &&
           verifier.VerifyTable(local_version_information()) &&
           VerifyField<bluetooth::hci::BufferSizeData>(verifier, VT_ACL_BUFFER_SIZE, 2) &&
           VerifyField<bluetooth::hci::BufferSizeData>(verifier, VT_SCO_BUFFER_SIZE, 2) &&
           VerifyField<bluetooth::hci::BufferSizeData>(verifier, VT_ISO_BUFFER_SIZE, 2) &&
           VerifyField<bluetooth::hci::BufferSizeData>(verifier, VT_LE_BUFFER_SIZE, 2) &&
           VerifyField<uint64_t>(verifier, VT_LE_ACCEPT_LIST_SIZE, 8) &&
           VerifyField<uint64_t>(verifier, VT_LE_RESOLVING_LIST_SIZE, 8) &&
           VerifyField<bluetooth::hci::LeMaximumDataLengthData>(verifier, VT_LE_MAXIMUM_DATA_LENGTH, 2) &&
           VerifyField<uint16_t>(verifier, VT_LE_MAXIMUM_ADVERTISING_DATA_LENGTH, 2) &&
           VerifyField<uint16_t>(verifier, VT_LE_SUGGESTED_DEFAULT_DATA_LENGTH, 2) &&
           VerifyField<uint8_t>(verifier, VT_LE_NUMBER_SUPPORTED_ADVERTISING_SETS, 1) &&
           VerifyField<uint8_t>(verifier, VT_LE_PERIODIC_ADVERTISER_LIST_SIZE, 1) &&
           VerifyOffset(verifier, VT_LOCAL_SUPPORTED_COMMANDS) &&
           verifier.VerifyVector(local_supported_commands()) &&
           VerifyOffset(verifier, VT_EXTENDED_LMP_FEATURES_ARRAY) &&
           verifier.VerifyVector(extended_lmp_features_array()) &&
           VerifyField<int64_t>(verifier, VT_LE_LOCAL_SUPPORTED_FEATURES, 8) &&
           VerifyField<uint64_t>(verifier, VT_LE_SUPPORTED_STATES, 8) &&
           VerifyField<bluetooth::hci::VendorCapabilitiesData>(verifier, VT_VENDOR_CAPABILITIES, 4) &&
           verifier.EndTable();
  }
};

struct ControllerDataBuilder {
  typedef ControllerData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_title(flatbuffers::Offset<flatbuffers::String> title) {
    fbb_.AddOffset(ControllerData::VT_TITLE, title);
  }
  void add_local_version_information(flatbuffers::Offset<bluetooth::hci::LocalVersionInformationData> local_version_information) {
    fbb_.AddOffset(ControllerData::VT_LOCAL_VERSION_INFORMATION, local_version_information);
  }
  void add_acl_buffer_size(const bluetooth::hci::BufferSizeData *acl_buffer_size) {
    fbb_.AddStruct(ControllerData::VT_ACL_BUFFER_SIZE, acl_buffer_size);
  }
  void add_sco_buffer_size(const bluetooth::hci::BufferSizeData *sco_buffer_size) {
    fbb_.AddStruct(ControllerData::VT_SCO_BUFFER_SIZE, sco_buffer_size);
  }
  void add_iso_buffer_size(const bluetooth::hci::BufferSizeData *iso_buffer_size) {
    fbb_.AddStruct(ControllerData::VT_ISO_BUFFER_SIZE, iso_buffer_size);
  }
  void add_le_buffer_size(const bluetooth::hci::BufferSizeData *le_buffer_size) {
    fbb_.AddStruct(ControllerData::VT_LE_BUFFER_SIZE, le_buffer_size);
  }
  void add_le_accept_list_size(uint64_t le_accept_list_size) {
    fbb_.AddElement<uint64_t>(ControllerData::VT_LE_ACCEPT_LIST_SIZE, le_accept_list_size, 0);
  }
  void add_le_resolving_list_size(uint64_t le_resolving_list_size) {
    fbb_.AddElement<uint64_t>(ControllerData::VT_LE_RESOLVING_LIST_SIZE, le_resolving_list_size, 0);
  }
  void add_le_maximum_data_length(const bluetooth::hci::LeMaximumDataLengthData *le_maximum_data_length) {
    fbb_.AddStruct(ControllerData::VT_LE_MAXIMUM_DATA_LENGTH, le_maximum_data_length);
  }
  void add_le_maximum_advertising_data_length(uint16_t le_maximum_advertising_data_length) {
    fbb_.AddElement<uint16_t>(ControllerData::VT_LE_MAXIMUM_ADVERTISING_DATA_LENGTH, le_maximum_advertising_data_length, 0);
  }
  void add_le_suggested_default_data_length(uint16_t le_suggested_default_data_length) {
    fbb_.AddElement<uint16_t>(ControllerData::VT_LE_SUGGESTED_DEFAULT_DATA_LENGTH, le_suggested_default_data_length, 0);
  }
  void add_le_number_supported_advertising_sets(uint8_t le_number_supported_advertising_sets) {
    fbb_.AddElement<uint8_t>(ControllerData::VT_LE_NUMBER_SUPPORTED_ADVERTISING_SETS, le_number_supported_advertising_sets, 0);
  }
  void add_le_periodic_advertiser_list_size(uint8_t le_periodic_advertiser_list_size) {
    fbb_.AddElement<uint8_t>(ControllerData::VT_LE_PERIODIC_ADVERTISER_LIST_SIZE, le_periodic_advertiser_list_size, 0);
  }
  void add_local_supported_commands(flatbuffers::Offset<flatbuffers::Vector<const bluetooth::hci::LocalSupportedCommandsData *>> local_supported_commands) {
    fbb_.AddOffset(ControllerData::VT_LOCAL_SUPPORTED_COMMANDS, local_supported_commands);
  }
  void add_extended_lmp_features_array(flatbuffers::Offset<flatbuffers::Vector<uint64_t>> extended_lmp_features_array) {
    fbb_.AddOffset(ControllerData::VT_EXTENDED_LMP_FEATURES_ARRAY, extended_lmp_features_array);
  }
  void add_le_local_supported_features(int64_t le_local_supported_features) {
    fbb_.AddElement<int64_t>(ControllerData::VT_LE_LOCAL_SUPPORTED_FEATURES, le_local_supported_features, 0);
  }
  void add_le_supported_states(uint64_t le_supported_states) {
    fbb_.AddElement<uint64_t>(ControllerData::VT_LE_SUPPORTED_STATES, le_supported_states, 0);
  }
  void add_vendor_capabilities(const bluetooth::hci::VendorCapabilitiesData *vendor_capabilities) {
    fbb_.AddStruct(ControllerData::VT_VENDOR_CAPABILITIES, vendor_capabilities);
  }
  explicit ControllerDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ControllerData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ControllerData>(end);
    return o;
  }
};

inline flatbuffers::Offset<ControllerData> CreateControllerData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> title = 0,
    flatbuffers::Offset<bluetooth::hci::LocalVersionInformationData> local_version_information = 0,
    const bluetooth::hci::BufferSizeData *acl_buffer_size = nullptr,
    const bluetooth::hci::BufferSizeData *sco_buffer_size = nullptr,
    const bluetooth::hci::BufferSizeData *iso_buffer_size = nullptr,
    const bluetooth::hci::BufferSizeData *le_buffer_size = nullptr,
    uint64_t le_accept_list_size = 0,
    uint64_t le_resolving_list_size = 0,
    const bluetooth::hci::LeMaximumDataLengthData *le_maximum_data_length = nullptr,
    uint16_t le_maximum_advertising_data_length = 0,
    uint16_t le_suggested_default_data_length = 0,
    uint8_t le_number_supported_advertising_sets = 0,
    uint8_t le_periodic_advertiser_list_size = 0,
    flatbuffers::Offset<flatbuffers::Vector<const bluetooth::hci::LocalSupportedCommandsData *>> local_supported_commands = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint64_t>> extended_lmp_features_array = 0,
    int64_t le_local_supported_features = 0,
    uint64_t le_supported_states = 0,
    const bluetooth::hci::VendorCapabilitiesData *vendor_capabilities = nullptr) {
  ControllerDataBuilder builder_(_fbb);
  builder_.add_le_supported_states(le_supported_states);
  builder_.add_le_local_supported_features(le_local_supported_features);
  builder_.add_le_resolving_list_size(le_resolving_list_size);
  builder_.add_le_accept_list_size(le_accept_list_size);
  builder_.add_vendor_capabilities(vendor_capabilities);
  builder_.add_extended_lmp_features_array(extended_lmp_features_array);
  builder_.add_local_supported_commands(local_supported_commands);
  builder_.add_le_maximum_data_length(le_maximum_data_length);
  builder_.add_le_buffer_size(le_buffer_size);
  builder_.add_iso_buffer_size(iso_buffer_size);
  builder_.add_sco_buffer_size(sco_buffer_size);
  builder_.add_acl_buffer_size(acl_buffer_size);
  builder_.add_local_version_information(local_version_information);
  builder_.add_title(title);
  builder_.add_le_suggested_default_data_length(le_suggested_default_data_length);
  builder_.add_le_maximum_advertising_data_length(le_maximum_advertising_data_length);
  builder_.add_le_periodic_advertiser_list_size(le_periodic_advertiser_list_size);
  builder_.add_le_number_supported_advertising_sets(le_number_supported_advertising_sets);
  return builder_.Finish();
}

inline flatbuffers::Offset<ControllerData> CreateControllerDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *title = nullptr,
    flatbuffers::Offset<bluetooth::hci::LocalVersionInformationData> local_version_information = 0,
    const bluetooth::hci::BufferSizeData *acl_buffer_size = nullptr,
    const bluetooth::hci::BufferSizeData *sco_buffer_size = nullptr,
    const bluetooth::hci::BufferSizeData *iso_buffer_size = nullptr,
    const bluetooth::hci::BufferSizeData *le_buffer_size = nullptr,
    uint64_t le_accept_list_size = 0,
    uint64_t le_resolving_list_size = 0,
    const bluetooth::hci::LeMaximumDataLengthData *le_maximum_data_length = nullptr,
    uint16_t le_maximum_advertising_data_length = 0,
    uint16_t le_suggested_default_data_length = 0,
    uint8_t le_number_supported_advertising_sets = 0,
    uint8_t le_periodic_advertiser_list_size = 0,
    const std::vector<bluetooth::hci::LocalSupportedCommandsData> *local_supported_commands = nullptr,
    const std::vector<uint64_t> *extended_lmp_features_array = nullptr,
    int64_t le_local_supported_features = 0,
    uint64_t le_supported_states = 0,
    const bluetooth::hci::VendorCapabilitiesData *vendor_capabilities = nullptr) {
  auto title__ = title ? _fbb.CreateString(title) : 0;
  auto local_supported_commands__ = local_supported_commands ? _fbb.CreateVectorOfStructs<bluetooth::hci::LocalSupportedCommandsData>(*local_supported_commands) : 0;
  auto extended_lmp_features_array__ = extended_lmp_features_array ? _fbb.CreateVector<uint64_t>(*extended_lmp_features_array) : 0;
  return bluetooth::hci::CreateControllerData(
      _fbb,
      title__,
      local_version_information,
      acl_buffer_size,
      sco_buffer_size,
      iso_buffer_size,
      le_buffer_size,
      le_accept_list_size,
      le_resolving_list_size,
      le_maximum_data_length,
      le_maximum_advertising_data_length,
      le_suggested_default_data_length,
      le_number_supported_advertising_sets,
      le_periodic_advertiser_list_size,
      local_supported_commands__,
      extended_lmp_features_array__,
      le_local_supported_features,
      le_supported_states,
      vendor_capabilities);
}

inline const bluetooth::hci::ControllerData *GetControllerData(const void *buf) {
  return flatbuffers::GetRoot<bluetooth::hci::ControllerData>(buf);
}

inline const bluetooth::hci::ControllerData *GetSizePrefixedControllerData(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<bluetooth::hci::ControllerData>(buf);
}

inline bool VerifyControllerDataBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<bluetooth::hci::ControllerData>(nullptr);
}

inline bool VerifySizePrefixedControllerDataBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<bluetooth::hci::ControllerData>(nullptr);
}

inline void FinishControllerDataBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<bluetooth::hci::ControllerData> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedControllerDataBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<bluetooth::hci::ControllerData> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace hci
}  // namespace bluetooth

#endif  // FLATBUFFERS_GENERATED_HCICONTROLLER_BLUETOOTH_HCI_H_
