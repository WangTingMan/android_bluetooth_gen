// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: frameworks/proto_logging/stats/enums/bluetooth/enums.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_frameworks_2fproto_5flogging_2fstats_2fenums_2fbluetooth_2fenums_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_frameworks_2fproto_5flogging_2fstats_2fenums_2fbluetooth_2fenums_2eproto

#include <cstdint>
#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_frameworks_2fproto_5flogging_2fstats_2fenums_2fbluetooth_2fenums_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_frameworks_2fproto_5flogging_2fstats_2fenums_2fbluetooth_2fenums_2eproto {
  static const ::uint32_t offsets[];
};
PROTOBUF_NAMESPACE_OPEN
PROTOBUF_NAMESPACE_CLOSE
namespace android {
namespace bluetooth {

enum ConnectionStateEnum : int {
  CONNECTION_STATE_DISCONNECTED = 0,
  CONNECTION_STATE_CONNECTING = 1,
  CONNECTION_STATE_CONNECTED = 2,
  CONNECTION_STATE_DISCONNECTING = 3
};
bool ConnectionStateEnum_IsValid(int value);
constexpr ConnectionStateEnum ConnectionStateEnum_MIN = CONNECTION_STATE_DISCONNECTED;
constexpr ConnectionStateEnum ConnectionStateEnum_MAX = CONNECTION_STATE_DISCONNECTING;
constexpr int ConnectionStateEnum_ARRAYSIZE = ConnectionStateEnum_MAX + 1;

const std::string& ConnectionStateEnum_Name(ConnectionStateEnum value);
template<typename T>
inline const std::string& ConnectionStateEnum_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ConnectionStateEnum>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ConnectionStateEnum_Name.");
  return ConnectionStateEnum_Name(static_cast<ConnectionStateEnum>(enum_t_value));
}
bool ConnectionStateEnum_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ConnectionStateEnum* value);
enum EnableDisableReasonEnum : int {
  ENABLE_DISABLE_REASON_UNSPECIFIED = 0,
  ENABLE_DISABLE_REASON_APPLICATION_REQUEST = 1,
  ENABLE_DISABLE_REASON_AIRPLANE_MODE = 2,
  ENABLE_DISABLE_REASON_DISALLOWED = 3,
  ENABLE_DISABLE_REASON_RESTARTED = 4,
  ENABLE_DISABLE_REASON_START_ERROR = 5,
  ENABLE_DISABLE_REASON_SYSTEM_BOOT = 6,
  ENABLE_DISABLE_REASON_CRASH = 7,
  ENABLE_DISABLE_REASON_USER_SWITCH = 8,
  ENABLE_DISABLE_REASON_RESTORE_USER_SETTING = 9,
  ENABLE_DISABLE_REASON_FACTORY_RESET = 10,
  ENABLE_DISABLE_REASON_INIT_FLAGS_CHANGED = 11,
  ENABLE_DISABLE_REASON_SATELLITE_MODE = 12
};
bool EnableDisableReasonEnum_IsValid(int value);
constexpr EnableDisableReasonEnum EnableDisableReasonEnum_MIN = ENABLE_DISABLE_REASON_UNSPECIFIED;
constexpr EnableDisableReasonEnum EnableDisableReasonEnum_MAX = ENABLE_DISABLE_REASON_SATELLITE_MODE;
constexpr int EnableDisableReasonEnum_ARRAYSIZE = EnableDisableReasonEnum_MAX + 1;

const std::string& EnableDisableReasonEnum_Name(EnableDisableReasonEnum value);
template<typename T>
inline const std::string& EnableDisableReasonEnum_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EnableDisableReasonEnum>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EnableDisableReasonEnum_Name.");
  return EnableDisableReasonEnum_Name(static_cast<EnableDisableReasonEnum>(enum_t_value));
}
bool EnableDisableReasonEnum_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EnableDisableReasonEnum* value);
enum DirectionEnum : int {
  DIRECTION_UNKNOWN = 0,
  DIRECTION_OUTGOING = 1,
  DIRECTION_INCOMING = 2
};
bool DirectionEnum_IsValid(int value);
constexpr DirectionEnum DirectionEnum_MIN = DIRECTION_UNKNOWN;
constexpr DirectionEnum DirectionEnum_MAX = DIRECTION_INCOMING;
constexpr int DirectionEnum_ARRAYSIZE = DirectionEnum_MAX + 1;

const std::string& DirectionEnum_Name(DirectionEnum value);
template<typename T>
inline const std::string& DirectionEnum_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DirectionEnum>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DirectionEnum_Name.");
  return DirectionEnum_Name(static_cast<DirectionEnum>(enum_t_value));
}
bool DirectionEnum_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DirectionEnum* value);
enum LinkTypeEnum : int {
  LINK_TYPE_UNKNOWN = 4095,
  LINK_TYPE_SCO = 0,
  LINK_TYPE_ACL = 1,
  LINK_TYPE_ESCO = 2
};
bool LinkTypeEnum_IsValid(int value);
constexpr LinkTypeEnum LinkTypeEnum_MIN = LINK_TYPE_SCO;
constexpr LinkTypeEnum LinkTypeEnum_MAX = LINK_TYPE_UNKNOWN;
constexpr int LinkTypeEnum_ARRAYSIZE = LinkTypeEnum_MAX + 1;

const std::string& LinkTypeEnum_Name(LinkTypeEnum value);
template<typename T>
inline const std::string& LinkTypeEnum_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LinkTypeEnum>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LinkTypeEnum_Name.");
  return LinkTypeEnum_Name(static_cast<LinkTypeEnum>(enum_t_value));
}
bool LinkTypeEnum_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LinkTypeEnum* value);
enum DeviceInfoSrcEnum : int {
  DEVICE_INFO_SRC_UNKNOWN = 0,
  DEVICE_INFO_INTERNAL = 1,
  DEVICE_INFO_EXTERNAL = 2
};
bool DeviceInfoSrcEnum_IsValid(int value);
constexpr DeviceInfoSrcEnum DeviceInfoSrcEnum_MIN = DEVICE_INFO_SRC_UNKNOWN;
constexpr DeviceInfoSrcEnum DeviceInfoSrcEnum_MAX = DEVICE_INFO_EXTERNAL;
constexpr int DeviceInfoSrcEnum_ARRAYSIZE = DeviceInfoSrcEnum_MAX + 1;

const std::string& DeviceInfoSrcEnum_Name(DeviceInfoSrcEnum value);
template<typename T>
inline const std::string& DeviceInfoSrcEnum_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DeviceInfoSrcEnum>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DeviceInfoSrcEnum_Name.");
  return DeviceInfoSrcEnum_Name(static_cast<DeviceInfoSrcEnum>(enum_t_value));
}
bool DeviceInfoSrcEnum_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DeviceInfoSrcEnum* value);
enum DeviceTypeEnum : int {
  DEVICE_TYPE_UNKNOWN = 0,
  DEVICE_TYPE_CLASSIC = 1,
  DEVICE_TYPE_LE = 2,
  DEVICE_TYPE_DUAL = 3
};
bool DeviceTypeEnum_IsValid(int value);
constexpr DeviceTypeEnum DeviceTypeEnum_MIN = DEVICE_TYPE_UNKNOWN;
constexpr DeviceTypeEnum DeviceTypeEnum_MAX = DEVICE_TYPE_DUAL;
constexpr int DeviceTypeEnum_ARRAYSIZE = DeviceTypeEnum_MAX + 1;

const std::string& DeviceTypeEnum_Name(DeviceTypeEnum value);
template<typename T>
inline const std::string& DeviceTypeEnum_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DeviceTypeEnum>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DeviceTypeEnum_Name.");
  return DeviceTypeEnum_Name(static_cast<DeviceTypeEnum>(enum_t_value));
}
bool DeviceTypeEnum_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DeviceTypeEnum* value);
enum TransportTypeEnum : int {
  TRANSPORT_TYPE_AUTO = 0,
  TRANSPORT_TYPE_BREDR = 1,
  TRANSPORT_TYPE_LE = 2
};
bool TransportTypeEnum_IsValid(int value);
constexpr TransportTypeEnum TransportTypeEnum_MIN = TRANSPORT_TYPE_AUTO;
constexpr TransportTypeEnum TransportTypeEnum_MAX = TRANSPORT_TYPE_LE;
constexpr int TransportTypeEnum_ARRAYSIZE = TransportTypeEnum_MAX + 1;

const std::string& TransportTypeEnum_Name(TransportTypeEnum value);
template<typename T>
inline const std::string& TransportTypeEnum_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TransportTypeEnum>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TransportTypeEnum_Name.");
  return TransportTypeEnum_Name(static_cast<TransportTypeEnum>(enum_t_value));
}
bool TransportTypeEnum_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TransportTypeEnum* value);
enum BondStateEnum : int {
  BOND_STATE_UNKNOWN = 0,
  BOND_STATE_NONE = 10,
  BOND_STATE_BONDING = 11,
  BOND_STATE_BONDED = 12
};
bool BondStateEnum_IsValid(int value);
constexpr BondStateEnum BondStateEnum_MIN = BOND_STATE_UNKNOWN;
constexpr BondStateEnum BondStateEnum_MAX = BOND_STATE_BONDED;
constexpr int BondStateEnum_ARRAYSIZE = BondStateEnum_MAX + 1;

const std::string& BondStateEnum_Name(BondStateEnum value);
template<typename T>
inline const std::string& BondStateEnum_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BondStateEnum>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BondStateEnum_Name.");
  return BondStateEnum_Name(static_cast<BondStateEnum>(enum_t_value));
}
bool BondStateEnum_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BondStateEnum* value);
enum BondSubStateEnum : int {
  BOND_SUB_STATE_UNKNOWN = 0,
  BOND_SUB_STATE_LOCAL_OOB_DATA_PROVIDED = 1,
  BOND_SUB_STATE_LOCAL_PIN_REQUESTED = 2,
  BOND_SUB_STATE_LOCAL_PIN_REPLIED = 3,
  BOND_SUB_STATE_LOCAL_SSP_REQUESTED = 4,
  BOND_SUB_STATE_LOCAL_SSP_REPLIED = 5,
  BOND_SUB_STATE_LOCAL_BOND_STATE_INTENT_SENT = 6,
  BOND_SUB_STATE_LOCAL_START_PAIRING = 7,
  BOND_SUB_STATE_LOCAL_START_PAIRING_OOB = 8
};
bool BondSubStateEnum_IsValid(int value);
constexpr BondSubStateEnum BondSubStateEnum_MIN = BOND_SUB_STATE_UNKNOWN;
constexpr BondSubStateEnum BondSubStateEnum_MAX = BOND_SUB_STATE_LOCAL_START_PAIRING_OOB;
constexpr int BondSubStateEnum_ARRAYSIZE = BondSubStateEnum_MAX + 1;

const std::string& BondSubStateEnum_Name(BondSubStateEnum value);
template<typename T>
inline const std::string& BondSubStateEnum_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BondSubStateEnum>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BondSubStateEnum_Name.");
  return BondSubStateEnum_Name(static_cast<BondSubStateEnum>(enum_t_value));
}
bool BondSubStateEnum_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BondSubStateEnum* value);
enum UnbondReasonEnum : int {
  UNBOND_REASON_UNKNOWN = 0,
  UNBOND_REASON_AUTH_FAILED = 1,
  UNBOND_REASON_AUTH_REJECTED = 2,
  UNBOND_REASON_AUTH_CANCELED = 3,
  UNBOND_REASON_REMOTE_DEVICE_DOWN = 4,
  UNBOND_REASON_DISCOVERY_IN_PROGRESS = 5,
  UNBOND_REASON_AUTH_TIMEOUT = 6,
  UNBOND_REASON_REPEATED_ATTEMPTS = 7,
  UNBOND_REASON_REMOTE_AUTH_CANCELED = 8,
  UNBOND_REASON_REMOVED = 9
};
bool UnbondReasonEnum_IsValid(int value);
constexpr UnbondReasonEnum UnbondReasonEnum_MIN = UNBOND_REASON_UNKNOWN;
constexpr UnbondReasonEnum UnbondReasonEnum_MAX = UNBOND_REASON_REMOVED;
constexpr int UnbondReasonEnum_ARRAYSIZE = UnbondReasonEnum_MAX + 1;

const std::string& UnbondReasonEnum_Name(UnbondReasonEnum value);
template<typename T>
inline const std::string& UnbondReasonEnum_Name(T enum_t_value) {
  static_assert(::std::is_same<T, UnbondReasonEnum>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function UnbondReasonEnum_Name.");
  return UnbondReasonEnum_Name(static_cast<UnbondReasonEnum>(enum_t_value));
}
bool UnbondReasonEnum_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, UnbondReasonEnum* value);
enum SocketTypeEnum : int {
  SOCKET_TYPE_UNKNOWN = 0,
  SOCKET_TYPE_RFCOMM = 1,
  SOCKET_TYPE_SCO = 2,
  SOCKET_TYPE_L2CAP_BREDR = 3,
  SOCKET_TYPE_L2CAP_LE = 4
};
bool SocketTypeEnum_IsValid(int value);
constexpr SocketTypeEnum SocketTypeEnum_MIN = SOCKET_TYPE_UNKNOWN;
constexpr SocketTypeEnum SocketTypeEnum_MAX = SOCKET_TYPE_L2CAP_LE;
constexpr int SocketTypeEnum_ARRAYSIZE = SocketTypeEnum_MAX + 1;

const std::string& SocketTypeEnum_Name(SocketTypeEnum value);
template<typename T>
inline const std::string& SocketTypeEnum_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SocketTypeEnum>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SocketTypeEnum_Name.");
  return SocketTypeEnum_Name(static_cast<SocketTypeEnum>(enum_t_value));
}
bool SocketTypeEnum_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SocketTypeEnum* value);
enum SocketConnectionstateEnum : int {
  SOCKET_CONNECTION_STATE_UNKNOWN = 0,
  SOCKET_CONNECTION_STATE_LISTENING = 1,
  SOCKET_CONNECTION_STATE_CONNECTING = 2,
  SOCKET_CONNECTION_STATE_CONNECTED = 3,
  SOCKET_CONNECTION_STATE_DISCONNECTING = 4,
  SOCKET_CONNECTION_STATE_DISCONNECTED = 5
};
bool SocketConnectionstateEnum_IsValid(int value);
constexpr SocketConnectionstateEnum SocketConnectionstateEnum_MIN = SOCKET_CONNECTION_STATE_UNKNOWN;
constexpr SocketConnectionstateEnum SocketConnectionstateEnum_MAX = SOCKET_CONNECTION_STATE_DISCONNECTED;
constexpr int SocketConnectionstateEnum_ARRAYSIZE = SocketConnectionstateEnum_MAX + 1;

const std::string& SocketConnectionstateEnum_Name(SocketConnectionstateEnum value);
template<typename T>
inline const std::string& SocketConnectionstateEnum_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SocketConnectionstateEnum>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SocketConnectionstateEnum_Name.");
  return SocketConnectionstateEnum_Name(static_cast<SocketConnectionstateEnum>(enum_t_value));
}
bool SocketConnectionstateEnum_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SocketConnectionstateEnum* value);
enum SocketRoleEnum : int {
  SOCKET_ROLE_UNKNOWN = 0,
  SOCKET_ROLE_LISTEN = 1,
  SOCKET_ROLE_CONNECTION = 2
};
bool SocketRoleEnum_IsValid(int value);
constexpr SocketRoleEnum SocketRoleEnum_MIN = SOCKET_ROLE_UNKNOWN;
constexpr SocketRoleEnum SocketRoleEnum_MAX = SOCKET_ROLE_CONNECTION;
constexpr int SocketRoleEnum_ARRAYSIZE = SocketRoleEnum_MAX + 1;

const std::string& SocketRoleEnum_Name(SocketRoleEnum value);
template<typename T>
inline const std::string& SocketRoleEnum_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SocketRoleEnum>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SocketRoleEnum_Name.");
  return SocketRoleEnum_Name(static_cast<SocketRoleEnum>(enum_t_value));
}
bool SocketRoleEnum_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SocketRoleEnum* value);
enum L2capCocConnectionResult : int {
  RESULT_L2CAP_CONN_UNKNOWN = 0,
  RESULT_L2CAP_CONN_SUCCESS = 1,
  RESULT_L2CAP_CONN_ACL_FAILURE = 2,
  RESULT_L2CAP_CONN_CL_SEC_FAILURE = 3,
  RESULT_L2CAP_CONN_INSUFFICIENT_AUTHENTICATION = 4,
  RESULT_L2CAP_CONN_INSUFFICIENT_AUTHORIZATION = 5,
  RESULT_L2CAP_CONN_INSUFFICIENT_ENCRYP_KEY_SIZE = 6,
  RESULT_L2CAP_CONN_INSUFFICIENT_ENCRYP = 7,
  RESULT_L2CAP_CONN_INVALID_SOURCE_CID = 8,
  RESULT_L2CAP_CONN_SOURCE_CID_ALREADY_ALLOCATED = 9,
  RESULT_L2CAP_CONN_UNACCEPTABLE_PARAMETERS = 10,
  RESULT_L2CAP_CONN_INVALID_PARAMETERS = 11,
  RESULT_L2CAP_CONN_NO_RESOURCES = 12,
  RESULT_L2CAP_CONN_NO_PSM = 13,
  RESULT_L2CAP_CONN_TIMEOUT = 14,
  RESULT_L2CAP_CONN_BLUETOOTH_OFF = 15,
  RESULT_L2CAP_CONN_BLUETOOTH_SOCKET_CONNECTION_FAILED = 1000,
  RESULT_L2CAP_CONN_BLUETOOTH_SOCKET_CONNECTION_CLOSED = 1001,
  RESULT_L2CAP_CONN_BLUETOOTH_UNABLE_TO_SEND_RPC = 1002,
  RESULT_L2CAP_CONN_BLUETOOTH_NULL_BLUETOOTH_DEVICE = 1003,
  RESULT_L2CAP_CONN_BLUETOOTH_GET_SOCKET_MANAGER_FAILED = 1004,
  RESULT_L2CAP_CONN_BLUETOOTH_NULL_FILE_DESCRIPTOR = 1005,
  RESULT_L2CAP_CONN_SERVER_FAILURE = 2000
};
bool L2capCocConnectionResult_IsValid(int value);
constexpr L2capCocConnectionResult L2capCocConnectionResult_MIN = RESULT_L2CAP_CONN_UNKNOWN;
constexpr L2capCocConnectionResult L2capCocConnectionResult_MAX = RESULT_L2CAP_CONN_SERVER_FAILURE;
constexpr int L2capCocConnectionResult_ARRAYSIZE = L2capCocConnectionResult_MAX + 1;

const std::string& L2capCocConnectionResult_Name(L2capCocConnectionResult value);
template<typename T>
inline const std::string& L2capCocConnectionResult_Name(T enum_t_value) {
  static_assert(::std::is_same<T, L2capCocConnectionResult>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function L2capCocConnectionResult_Name.");
  return L2capCocConnectionResult_Name(static_cast<L2capCocConnectionResult>(enum_t_value));
}
bool L2capCocConnectionResult_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, L2capCocConnectionResult* value);
enum CodePathCounterKeyEnum : int {
  KEY_UNKNOWN = 0,
  L2CAP_SUCCESS = 100000,
  L2CAP_CONNECT_CONFIRM_NEG = 100001,
  L2CAP_NO_COMPATIBLE_CHANNEL_AT_CSM_CLOSED = 100002,
  L2CAP_SECURITY_NEG_AT_CSM_CLOSED = 100003,
  L2CAP_TIMEOUT_AT_CSM_CLOSED = 100004,
  L2CAP_CREDIT_BASED_CONNECT_RSP_NEG = 100005,
  L2CAP_CONNECT_RSP_NEG = 100006,
  L2CAP_INFO_NO_COMPATIBLE_CHANNEL_AT_RSP = 100007,
  L2CAP_CONFIG_REQ_FAILURE = 100008,
  L2CAP_CONFIG_RSP_NEG = 100009,
  L2CAP_NO_COMPATIBLE_CHANNEL_AT_W4_SEC = 100010,
  L2CAP_SECURITY_NEG_AT_W4_SEC = 100011,
  L2CAP_TIMEOUT_AT_CONNECT_RSP = 100012,
  L2CAP_CONN_OTHER_ERROR_AT_CONNECT_RSP = 100013,
  SDP_SUCCESS = 100100,
  SDP_FAILURE = 100101,
  SDP_SENDING_DELAYED_UUID = 100102,
  SDP_NOT_SENDING_DELAYED_UUID = 100103,
  SDP_SENT_UUID = 100104,
  SDP_UUIDS_EQUAL_SKIP = 100105,
  SDP_ADD_UUID_WITH_INTENT = 100106,
  SDP_ADD_UUID_WITH_NO_INTENT = 100107,
  SDP_DROP_UUID = 100108,
  SDP_FETCH_UUID_SKIP_ALREADY_CACHED = 100109,
  SDP_FETCH_UUID_SKIP_ALREADY_BONDED = 100110,
  SDP_INVOKE_SDP_CYCLE = 100111,
  SDP_FETCH_UUID_REQUEST = 100112,
  RFCOMM_CONNECTION_SUCCESS_IND = 101000,
  RFCOMM_CONNECTION_SUCCESS_CNF = 101001,
  RFCOMM_PORT_START_CNF_FAILED = 101002,
  RFCOMM_PORT_START_CLOSE = 101003,
  RFCOMM_PORT_START_FAILED = 101004,
  RFCOMM_PORT_NEG_FAILED = 101005,
  RFCOMM_PORT_CLOSED = 101006,
  RFCOMM_PORT_PEER_CONNECTION_FAILED = 101007,
  RFCOMM_PORT_PEER_TIMEOUT = 101008,
  HFP_COLLISON_AT_AG_OPEN = 101101,
  HFP_COLLISON_AT_CONNECTING = 101102,
  HFP_SELF_INITIATED_AG_FAILED = 101103,
  HFP_SLC_SETUP_FAILED = 101104,
  A2DP_CONNECTION_SUCCESS = 102000,
  A2DP_CONNECTION_ACL_DISCONNECTED = 102001,
  A2DP_CONNECTION_REJECT_EVT = 102002,
  A2DP_CONNECTION_FAILURE = 102003,
  A2DP_CONNECTION_UNKNOWN_EVENT = 102004,
  A2DP_ALREADY_CONNECTING = 102005,
  A2DP_OFFLOAD_START_REQ_FAILURE = 102006,
  A2DP_CONNECTION_CLOSE = 102007,
  A2DP_CONNECTION_DISCONNECTED = 102008,
  A2DP_CONNECTION_TIMEOUT = 102009,
  HID_PLUG_FAILURE = 103001,
  HIDD_REGISTER_DESCRIPTOR_MALFORMED = 103002,
  HIDD_ERR_NOT_REGISTERED_AT_INITIATE = 103003,
  HIDD_ERR_NO_RESOURCES = 103004,
  HIDD_ERR_NO_CONNECTION_AT_SEND_DATA = 103005,
  HIDD_ERR_NO_CONNECTION_AT_DISCONNECT = 103006,
  HIDD_ERR_INVALID_PARAM = 103007,
  HIDD_ERR_CONGESTED_AT_DATA_WRITE = 103008,
  HIDD_ERR_CONGESTED_AT_FLAG_CHECK = 103009,
  HIDD_ERR_CONN_IN_PROCESS = 103010,
  HIDD_ERR_ALREADY_CONN = 103011,
  HIDD_ERR_DISCONNECTING = 103012,
  HIDD_ERR_L2CAP_NOT_STARTED_INCOMING = 103013,
  HIDD_ERR_L2CAP_FAILED_INITIATE = 103014,
  HIDD_ERR_L2CAP_FAILED_CONTROL = 103015,
  HIDD_ERR_L2CAP_FAILED_INTERRUPT = 103016,
  HIDD_ERR_HOST_CALLBACK_NULL = 103017,
  HIDD_ERR_INVALID_PARAM_SEND_REPORT = 103018,
  HIDD_ERR_DEVICE_NOT_IN_USE_AT_CONNECT = 103019,
  HIDD_ERR_DEVICE_NOT_IN_USE_AT_DISCONNECT = 103020,
  HIDD_ERR_NOT_REGISTERED_AT_CONNECT = 103021,
  HIDD_ERR_NOT_REGISTERED_AT_DISCONNECT = 103022,
  HIDD_ERR_NOT_REGISTERED_AT_GET_DEVICE = 103023,
  HIDD_ERR_NOT_REGISTERED_AT_DEREGISTER = 103024,
  HIDD_ERR_NOT_REGISTERED_DUE_TO_DESCRIPTOR_LENGTH = 103025,
  HIDD_ERR_NOT_REGISTERED_DUE_TO_BUFFER_ALLOCATION = 103026,
  HIDD_ERR_NOT_REGISTERED_AT_SDP = 103027,
  HIDD_ERR_ALREADY_REGISTERED = 103028,
  HIDH_ERR_ALREADY_REGISTERED = 103101,
  HIDH_ERR_NO_RESOURCES_SDP = 103102,
  HIDH_ERR_NO_RESOURCES_ADD_DEVICE = 103103,
  HIDH_ERR_NO_CONNECTION_AT_SEND_DATA = 103104,
  HIDH_ERR_NO_CONNECTION_AT_HOST_WRITE_DEV = 103105,
  HIDH_ERR_NO_CONNECTION_AT_HOST_CLOSE_DEV = 103106,
  HIDH_ERR_INVALID_PARAM_AT_SEND_DATA = 103107,
  HIDH_ERR_INVALID_PARAM_AT_HOST_REGISTER = 103108,
  HIDH_ERR_INVALID_PARAM_AT_HOST_REMOVE_DEV = 103109,
  HIDH_ERR_INVALID_PARAM_AT_HOST_OPEN_DEV = 103110,
  HIDH_ERR_INVALID_PARAM_AT_HOST_CLOSE_DEV = 103111,
  HIDH_ERR_INVALID_PARAM_AT_HOST_WRITE_DEV = 103112,
  HIDH_ERR_CONGESTED_AT_SEND_DATA = 103113,
  HIDH_ERR_CONGESTED_AT_FLAG_CHECK = 103114,
  HIDH_ERR_CONN_IN_PROCESS = 103115,
  HIDH_ERR_ALREADY_CONN = 103116,
  HIDH_ERR_L2CAP_FAILED_AT_INITIATE = 103117,
  HIDH_ERR_L2CAP_FAILED_AT_REGISTER_CONTROL = 103118,
  HIDH_ERR_L2CAP_FAILED_AT_REGISTER_INTERRUPT = 103119,
  HIDH_ERR_AUTH_FAILED = 103120,
  HIDH_ERR_SDP_BUSY = 103121,
  HIDH_COUNT_MAX_ADDED_DEVICE_LIMIT_REACHED = 103122,
  HIDH_COUNT_VIRTUAL_UNPLUG_REQUESTED_BY_REMOTE_DEVICE = 103123,
  HIDH_COUNT_CONNECT_REQ_WHEN_MAX_DEVICE_LIMIT_REACHED = 103124,
  HIDH_COUNT_WRONG_REPORT_TYPE = 103125,
  HIDH_COUNT_INCOMING_CONNECTION_REJECTED = 103126,
  HIDH_COUNT_CONNECTION_POLICY_DISABLED = 103127,
  HIDH_COUNT_SUPPORT_BOTH_HID_AND_HOGP = 103128,
  HIDH_COUNT_SUPPORT_ONLY_HID_OR_HOGP = 103129,
  LE_SCAN_COUNT_TOTAL_ENABLE = 120000,
  LE_SCAN_COUNT_TOTAL_DISABLE = 120001,
  LE_SCAN_COUNT_FILTERED_ENABLE = 120002,
  LE_SCAN_COUNT_FILTERED_DISABLE = 120003,
  LE_SCAN_COUNT_UNFILTERED_ENABLE = 120004,
  LE_SCAN_COUNT_UNFILTERED_DISABLE = 120005,
  LE_SCAN_COUNT_BATCH_ENABLE = 120006,
  LE_SCAN_COUNT_BATCH_DISABLE = 120007,
  LE_SCAN_COUNT_AUTO_BATCH_ENABLE = 120008,
  LE_SCAN_COUNT_AUTO_BATCH_DISABLE = 120009,
  LE_SCAN_DURATION_COUNT_REGULAR_10S = 120100,
  LE_SCAN_DURATION_COUNT_REGULAR_1M = 120101,
  LE_SCAN_DURATION_COUNT_REGULAR_10M = 120102,
  LE_SCAN_DURATION_COUNT_REGULAR_1H = 120103,
  LE_SCAN_DURATION_COUNT_REGULAR_1HP = 120104,
  LE_SCAN_DURATION_COUNT_BATCH_10S = 120105,
  LE_SCAN_DURATION_COUNT_BATCH_1M = 120106,
  LE_SCAN_DURATION_COUNT_BATCH_10M = 120107,
  LE_SCAN_DURATION_COUNT_BATCH_1H = 120108,
  LE_SCAN_DURATION_COUNT_BATCH_1HP = 120109,
  LE_SCAN_RADIO_DURATION_ALL = 120200,
  LE_SCAN_RADIO_DURATION_REGULAR = 120201,
  LE_SCAN_RADIO_DURATION_BATCH = 120202,
  LE_SCAN_RADIO_DURATION_REGULAR_SCREEN_ON = 120203,
  LE_SCAN_RADIO_DURATION_REGULAR_SCREEN_OFF = 120204,
  LE_SCAN_RADIO_DURATION_BATCH_SCREEN_ON = 120205,
  LE_SCAN_RADIO_DURATION_BATCH_SCREEN_OFF = 120206,
  LE_SCAN_RADIO_SCAN_MODE_OPPORTUNISTIC_COUNT = 120250,
  LE_SCAN_RADIO_SCAN_MODE_LOW_POWER_COUNT = 120251,
  LE_SCAN_RADIO_SCAN_MODE_BALANCED_COUNT = 120252,
  LE_SCAN_RADIO_SCAN_MODE_LOW_LATENCY_COUNT = 120253,
  LE_SCAN_RADIO_SCAN_MODE_AMBIENT_DISCOVERY_COUNT = 120254,
  LE_SCAN_RADIO_SCAN_MODE_SCREEN_OFF_COUNT = 120255,
  LE_SCAN_RADIO_SCAN_MODE_SCREEN_OFF_BALANCED_COUNT = 120256,
  LE_SCAN_RADIO_SCAN_MODE_OPPORTUNISTIC_COUNT_SCREEN_OFF = 120257,
  LE_SCAN_RADIO_SCAN_MODE_LOW_POWER_COUNT_SCREEN_OFF = 120258,
  LE_SCAN_RADIO_SCAN_MODE_BALANCED_COUNT_SCREEN_OFF = 120259,
  LE_SCAN_RADIO_SCAN_MODE_LOW_LATENCY_COUNT_SCREEN_OFF = 120260,
  LE_SCAN_RADIO_SCAN_MODE_AMBIENT_DISCOVERY_COUNT_SCREEN_OFF = 120261,
  LE_SCAN_RADIO_SCAN_MODE_SCREEN_OFF_COUNT_SCREEN_OFF = 120262,
  LE_SCAN_RADIO_SCAN_MODE_SCREEN_OFF_BALANCED_COUNT_SCREEN_OFF = 120263,
  LE_SCAN_RESULTS_COUNT_ALL = 120300,
  LE_SCAN_RESULTS_COUNT_REGULAR = 120301,
  LE_SCAN_RESULTS_COUNT_BATCH = 120302,
  LE_SCAN_RESULTS_COUNT_REGULAR_SCREEN_ON = 120303,
  LE_SCAN_RESULTS_COUNT_REGULAR_SCREEN_OFF = 120304,
  LE_SCAN_RESULTS_COUNT_BATCH_SCREEN_ON = 120305,
  LE_SCAN_RESULTS_COUNT_BATCH_SCREEN_OFF = 120306,
  LE_SCAN_RESULTS_COUNT_BATCH_BUNDLE = 120307,
  LE_SCAN_RESULTS_COUNT_BATCH_BUNDLE_SCREEN_ON = 120308,
  LE_SCAN_RESULTS_COUNT_BATCH_BUNDLE_SCREEN_OFF = 120309,
  LE_SCAN_ABUSE_COUNT_SCAN_TIMEOUT = 120400,
  LE_SCAN_ABUSE_COUNT_HW_FILTER_NOT_AVAILABLE = 120401,
  LE_SCAN_ABUSE_COUNT_TRACKING_HW_FILTER_NOT_AVAILABLE = 120402,
  LE_ADV_COUNT_ENABLE = 120500,
  LE_ADV_COUNT_DISABLE = 120501,
  LE_ADV_COUNT_CONNECTABLE_ENABLE = 120502,
  LE_ADV_COUNT_CONNECTABLE_DISABLE = 120503,
  LE_ADV_COUNT_PERIODIC_ENABLE = 120504,
  LE_ADV_COUNT_PERIODIC_DISABLE = 120505,
  LE_ADV_INSTANCE_COUNT_5 = 120600,
  LE_ADV_INSTANCE_COUNT_10 = 120601,
  LE_ADV_INSTANCE_COUNT_15 = 120602,
  LE_ADV_INSTANCE_COUNT_15P = 120603,
  LE_ADV_DURATION_COUNT_TOTAL_1M = 120700,
  LE_ADV_DURATION_COUNT_TOTAL_30M = 120701,
  LE_ADV_DURATION_COUNT_TOTAL_1H = 120702,
  LE_ADV_DURATION_COUNT_TOTAL_3H = 120703,
  LE_ADV_DURATION_COUNT_TOTAL_3HP = 120704,
  LE_ADV_DURATION_COUNT_CONNECTABLE_1M = 120705,
  LE_ADV_DURATION_COUNT_CONNECTABLE_30M = 120706,
  LE_ADV_DURATION_COUNT_CONNECTABLE_1H = 120707,
  LE_ADV_DURATION_COUNT_CONNECTABLE_3H = 120708,
  LE_ADV_DURATION_COUNT_CONNECTABLE_3HP = 120709,
  LE_ADV_DURATION_COUNT_PERIODIC_1M = 120710,
  LE_ADV_DURATION_COUNT_PERIODIC_30M = 120711,
  LE_ADV_DURATION_COUNT_PERIODIC_1H = 120712,
  LE_ADV_DURATION_COUNT_PERIODIC_3H = 120713,
  LE_ADV_DURATION_COUNT_PERIODIC_3HP = 120714,
  LE_ADV_ERROR_ON_START_COUNT = 120800,
  GATT_CLIENT_CONNECT_IS_DIRECT = 120900,
  GATT_CLIENT_CONNECT_IS_AUTOCONNECT = 120901,
  GATT_CLIENT_CONNECT_IS_DIRECT_IN_FOREGROUND = 120902,
  GATT_CLIENT_CONNECT_IS_DIRECT_NOT_IN_FOREGROUND = 120903,
  GATT_CLIENT_CONNECT_IS_AUTOCONNECT_IN_FOREGROUND = 120904,
  GATT_CLIENT_CONNECT_IS_AUTOCONNECT_NOT_IN_FOREGROUND = 120905,
  GATT_SERVER_CONNECT_IS_DIRECT_IN_FOREGROUND = 120906,
  GATT_SERVER_CONNECT_IS_DIRECT_NOT_IN_FOREGROUND = 120907,
  GATT_SERVER_CONNECT_IS_AUTOCONNECT_IN_FOREGROUND = 120908,
  GATT_SERVER_CONNECT_IS_AUTOCONNECT_NOT_IN_FOREGROUND = 120909,
  SCREEN_ON_EVENT = 121000,
  SCREEN_OFF_EVENT = 121001,
  LE_AUDIO_ALLOWLIST_DEVICE_HEALTH_STATUS_GOOD = 121100,
  LE_AUDIO_ALLOWLIST_DEVICE_HEALTH_STATUS_BAD = 121101,
  LE_AUDIO_ALLOWLIST_DEVICE_HEALTH_STATUS_BAD_INVALID_DB = 121102,
  LE_AUDIO_ALLOWLIST_DEVICE_HEALTH_STATUS_BAD_INVALID_CSIS = 121103,
  LE_AUDIO_NONALLOWLIST_DEVICE_HEALTH_STATUS_GOOD = 121104,
  LE_AUDIO_NONALLOWLIST_DEVICE_HEALTH_STATUS_BAD = 121105,
  LE_AUDIO_NONALLOWLIST_DEVICE_HEALTH_STATUS_BAD_INVALID_DB = 121106,
  LE_AUDIO_NONALLOWLIST_DEVICE_HEALTH_STATUS_BAD_INVALID_CSIS = 121107,
  LE_AUDIO_ALLOWLIST_GROUP_HEALTH_STATUS_GOOD = 121108,
  LE_AUDIO_ALLOWLIST_GROUP_HEALTH_STATUS_TRENDING_BAD = 121109,
  LE_AUDIO_ALLOWLIST_GROUP_HEALTH_STATUS_BAD = 121110,
  LE_AUDIO_ALLOWLIST_GROUP_HEALTH_STATUS_BAD_ONCE_CIS_FAILED = 121111,
  LE_AUDIO_ALLOWLIST_GROUP_HEALTH_STATUS_BAD_ONCE_SIGNALING_FAILED = 121112,
  LE_AUDIO_NONALLOWLIST_GROUP_HEALTH_STATUS_GOOD = 121113,
  LE_AUDIO_NONALLOWLIST_GROUP_HEALTH_STATUS_TRENDING_BAD = 121114,
  LE_AUDIO_NONALLOWLIST_GROUP_HEALTH_STATUS_BAD = 121115,
  LE_AUDIO_NONALLOWLIST_GROUP_HEALTH_STATUS_BAD_ONCE_CIS_FAILED = 121116,
  LE_AUDIO_NONALLOWLIST_GROUP_HEALTH_STATUS_BAD_ONCE_SIGNALING_FAILED = 121117
};
bool CodePathCounterKeyEnum_IsValid(int value);
constexpr CodePathCounterKeyEnum CodePathCounterKeyEnum_MIN = KEY_UNKNOWN;
constexpr CodePathCounterKeyEnum CodePathCounterKeyEnum_MAX = LE_AUDIO_NONALLOWLIST_GROUP_HEALTH_STATUS_BAD_ONCE_SIGNALING_FAILED;
constexpr int CodePathCounterKeyEnum_ARRAYSIZE = CodePathCounterKeyEnum_MAX + 1;

const std::string& CodePathCounterKeyEnum_Name(CodePathCounterKeyEnum value);
template<typename T>
inline const std::string& CodePathCounterKeyEnum_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CodePathCounterKeyEnum>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CodePathCounterKeyEnum_Name.");
  return CodePathCounterKeyEnum_Name(static_cast<CodePathCounterKeyEnum>(enum_t_value));
}
bool CodePathCounterKeyEnum_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CodePathCounterKeyEnum* value);
enum AddressTypeEnum : int {
  ADDRESS_TYPE_PUBLIC = 0,
  ADDRESS_TYPE_RANDOM = 1,
  ADDRESS_TYPE_UNKNOWN = 65535
};
bool AddressTypeEnum_IsValid(int value);
constexpr AddressTypeEnum AddressTypeEnum_MIN = ADDRESS_TYPE_PUBLIC;
constexpr AddressTypeEnum AddressTypeEnum_MAX = ADDRESS_TYPE_UNKNOWN;
constexpr int AddressTypeEnum_ARRAYSIZE = AddressTypeEnum_MAX + 1;

const std::string& AddressTypeEnum_Name(AddressTypeEnum value);
template<typename T>
inline const std::string& AddressTypeEnum_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AddressTypeEnum>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AddressTypeEnum_Name.");
  return AddressTypeEnum_Name(static_cast<AddressTypeEnum>(enum_t_value));
}
bool AddressTypeEnum_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AddressTypeEnum* value);
enum MajorClassEnum : int {
  MAJOR_CLASS_UNCATEGORIZED = 7936,
  MAJOR_CLASS_MISC = 0,
  MAJOR_CLASS_COMPUTER = 256,
  MAJOR_CLASS_PHONE = 512,
  MAJOR_CLASS_NETWORKING = 768,
  MAJOR_CLASS_AUDIO_VIDEO = 1024,
  MAJOR_CLASS_PERIPHERAL = 1280,
  MAJOR_CLASS_IMAGING = 1536,
  MAJOR_CLASS_WEARABLE = 1792,
  MAJOR_CLASS_TOY = 2048,
  MAJOR_CLASS_HEALTH = 2304
};
bool MajorClassEnum_IsValid(int value);
constexpr MajorClassEnum MajorClassEnum_MIN = MAJOR_CLASS_MISC;
constexpr MajorClassEnum MajorClassEnum_MAX = MAJOR_CLASS_UNCATEGORIZED;
constexpr int MajorClassEnum_ARRAYSIZE = MajorClassEnum_MAX + 1;

const std::string& MajorClassEnum_Name(MajorClassEnum value);
template<typename T>
inline const std::string& MajorClassEnum_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MajorClassEnum>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MajorClassEnum_Name.");
  return MajorClassEnum_Name(static_cast<MajorClassEnum>(enum_t_value));
}
bool MajorClassEnum_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MajorClassEnum* value);
enum ProfileConnectionResult : int {
  RESULT_UNKNOWN = 0,
  RESULT_SUCCESS = 1,
  RESULT_FAILURE = 2
};
bool ProfileConnectionResult_IsValid(int value);
constexpr ProfileConnectionResult ProfileConnectionResult_MIN = RESULT_UNKNOWN;
constexpr ProfileConnectionResult ProfileConnectionResult_MAX = RESULT_FAILURE;
constexpr int ProfileConnectionResult_ARRAYSIZE = ProfileConnectionResult_MAX + 1;

const std::string& ProfileConnectionResult_Name(ProfileConnectionResult value);
template<typename T>
inline const std::string& ProfileConnectionResult_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ProfileConnectionResult>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ProfileConnectionResult_Name.");
  return ProfileConnectionResult_Name(static_cast<ProfileConnectionResult>(enum_t_value));
}
bool ProfileConnectionResult_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ProfileConnectionResult* value);
enum ProfileConnectionReason : int {
  REASON_UNKNOWN = 0,
  REASON_SUCCESS = 1,
  REASON_UNEXPECTED_STATE = 2,
  REASON_NATIVE_LAYER_REJECTED = 3,
  REASON_INCOMING_CONN_REJECTED = 4
};
bool ProfileConnectionReason_IsValid(int value);
constexpr ProfileConnectionReason ProfileConnectionReason_MIN = REASON_UNKNOWN;
constexpr ProfileConnectionReason ProfileConnectionReason_MAX = REASON_INCOMING_CONN_REJECTED;
constexpr int ProfileConnectionReason_ARRAYSIZE = ProfileConnectionReason_MAX + 1;

const std::string& ProfileConnectionReason_Name(ProfileConnectionReason value);
template<typename T>
inline const std::string& ProfileConnectionReason_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ProfileConnectionReason>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ProfileConnectionReason_Name.");
  return ProfileConnectionReason_Name(static_cast<ProfileConnectionReason>(enum_t_value));
}
bool ProfileConnectionReason_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ProfileConnectionReason* value);
enum ContentProfileFileName : int {
  BLUETOOTH_FILE_NAME_UNKNOWN = 0,
  BLUETOOTH_MAP_ACCOUNT_LOADER = 1,
  BLUETOOTH_MAP_APP_OBSERVER = 2,
  BLUETOOTH_MAP_APP_PARAMS = 3,
  BLUETOOTH_MAP_BMESSAGE = 4,
  BLUETOOTH_MAP_BMESSAGE_EMAIL = 5,
  BLUETOOTH_MAP_BMESSAGE_MIME = 6,
  BLUETOOTH_MAP_CONTENT = 7,
  BLUETOOTH_MAP_CONTENT_OBSERVER = 8,
  BLUETOOTH_MAP_CONVO_CONTACT_ELEMENT = 9,
  BLUETOOTH_MAP_CONVO_LISTING = 10,
  BLUETOOTH_MAP_CONVO_LISTING_ELEMENT = 11,
  BLUETOOTH_MAP_FOLDER_ELEMENT = 12,
  BLUETOOTH_MAP_MAS_INSTANCE = 13,
  BLUETOOTH_MAP_MESSAGE_LISTING = 14,
  BLUETOOTH_MAP_OBEX_SERVER = 15,
  BLUETOOTH_MAP_SERVICE = 16,
  BLUETOOTH_MAP_SMS_PDU = 17,
  BLUETOOTH_MAP_UTILS = 18,
  BLUETOOTH_MNS_OBEX_CLIENT = 19,
  BLUETOOTH_SMS_MMS_CONTACTS = 20,
  BLUETOOTH_MMS_FILE_PROVIDER = 21,
  BLUETOOTH_OPP_MANAGER = 10001,
  BLUETOOTH_OPP_TRANSFER_HISTORY = 10002,
  BLUETOOTH_OPP_OBEX_CLIENT_SESSION = 10003,
  BLUETOOTH_OPP_UTILITY = 10004,
  BLUETOOTH_OPP_LAUNCHER_ACTIVITY = 10005,
  BLUETOOTH_OPP_RECEIVER = 10006,
  BLUETOOTH_OPP_TRANSFER = 10007,
  BLUETOOTH_OPP_SEND_FILE_INFO = 10008,
  BLUETOOTH_OPP_INCOMING_FILE_CONFIRM_ACTIVITY = 10009,
  BLUETOOTH_OPP_OBEX_SERVER_SESSION = 10010,
  BLUETOOTH_OPP_RECEIVE_FILE_INFO = 10011,
  BLUETOOTH_OPP_TRANSFER_ACTIVITY = 10012,
  BLUETOOTH_OPP_PROVIDER = 10013,
  BLUETOOTH_OPP_SERVICE = 10014,
  BLUETOOTH_OPP_CONSTANTS = 10015,
  BLUETOOTH_PBAP_ACTIVITY = 20001,
  BLUETOOTH_PBAP_AUTHENTICATOR = 20002,
  BLUETOOTH_PBAP_CALL_LOG_COMPOSER = 20003,
  BLUETOOTH_PBAP_CONFIG = 20004,
  BLUETOOTH_PBAP_OBEX_SERVER = 20005,
  BLUETOOTH_PBAP_SERVICE = 20006,
  BLUETOOTH_PBAP_SIM_VCARD_MANAGER = 20007,
  BLUETOOTH_PBAP_UTILS = 20008,
  BLUETOOTH_PBAP_VCARD_MANAGER = 20009,
  BLUETOOTH_PBAP_HANDLER_FOR_STRING_BUFFER = 20010,
  BLUETOOTH_PBAP_STATE_MACHINE = 20011
};
bool ContentProfileFileName_IsValid(int value);
constexpr ContentProfileFileName ContentProfileFileName_MIN = BLUETOOTH_FILE_NAME_UNKNOWN;
constexpr ContentProfileFileName ContentProfileFileName_MAX = BLUETOOTH_PBAP_STATE_MACHINE;
constexpr int ContentProfileFileName_ARRAYSIZE = ContentProfileFileName_MAX + 1;

const std::string& ContentProfileFileName_Name(ContentProfileFileName value);
template<typename T>
inline const std::string& ContentProfileFileName_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ContentProfileFileName>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ContentProfileFileName_Name.");
  return ContentProfileFileName_Name(static_cast<ContentProfileFileName>(enum_t_value));
}
bool ContentProfileFileName_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ContentProfileFileName* value);
// ===================================================================


// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)

}  // namespace bluetooth
}  // namespace android

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::android::bluetooth::ConnectionStateEnum> : ::std::true_type {};
template <> struct is_proto_enum< ::android::bluetooth::EnableDisableReasonEnum> : ::std::true_type {};
template <> struct is_proto_enum< ::android::bluetooth::DirectionEnum> : ::std::true_type {};
template <> struct is_proto_enum< ::android::bluetooth::LinkTypeEnum> : ::std::true_type {};
template <> struct is_proto_enum< ::android::bluetooth::DeviceInfoSrcEnum> : ::std::true_type {};
template <> struct is_proto_enum< ::android::bluetooth::DeviceTypeEnum> : ::std::true_type {};
template <> struct is_proto_enum< ::android::bluetooth::TransportTypeEnum> : ::std::true_type {};
template <> struct is_proto_enum< ::android::bluetooth::BondStateEnum> : ::std::true_type {};
template <> struct is_proto_enum< ::android::bluetooth::BondSubStateEnum> : ::std::true_type {};
template <> struct is_proto_enum< ::android::bluetooth::UnbondReasonEnum> : ::std::true_type {};
template <> struct is_proto_enum< ::android::bluetooth::SocketTypeEnum> : ::std::true_type {};
template <> struct is_proto_enum< ::android::bluetooth::SocketConnectionstateEnum> : ::std::true_type {};
template <> struct is_proto_enum< ::android::bluetooth::SocketRoleEnum> : ::std::true_type {};
template <> struct is_proto_enum< ::android::bluetooth::L2capCocConnectionResult> : ::std::true_type {};
template <> struct is_proto_enum< ::android::bluetooth::CodePathCounterKeyEnum> : ::std::true_type {};
template <> struct is_proto_enum< ::android::bluetooth::AddressTypeEnum> : ::std::true_type {};
template <> struct is_proto_enum< ::android::bluetooth::MajorClassEnum> : ::std::true_type {};
template <> struct is_proto_enum< ::android::bluetooth::ProfileConnectionResult> : ::std::true_type {};
template <> struct is_proto_enum< ::android::bluetooth::ProfileConnectionReason> : ::std::true_type {};
template <> struct is_proto_enum< ::android::bluetooth::ContentProfileFileName> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_frameworks_2fproto_5flogging_2fstats_2fenums_2fbluetooth_2fenums_2eproto
