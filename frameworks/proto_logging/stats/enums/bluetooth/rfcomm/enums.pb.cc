// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: frameworks/proto_logging/stats/enums/bluetooth/rfcomm/enums.proto

#include "frameworks/proto_logging/stats/enums/bluetooth/rfcomm/enums.pb.h"

#include <algorithm>
#include <cstdint>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace android {
namespace bluetooth {
namespace rfcomm {
}  // namespace rfcomm
}  // namespace bluetooth
}  // namespace android
namespace android {
namespace bluetooth {
namespace rfcomm {
bool RfcommConnectionResult_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> RfcommConnectionResult_strings[8] = {};

static const char RfcommConnectionResult_names[] =
  "RFCOMM_CONN_RESULT_FAILURE_UNKNOWN"
  "RFCOMM_CONN_RESULT_GET_SOCKET_MANAGER_FAILED"
  "RFCOMM_CONN_RESULT_NULL_BLUETOOTH_DEVICE"
  "RFCOMM_CONN_RESULT_NULL_FILE_DESCRIPTOR"
  "RFCOMM_CONN_RESULT_SOCKET_CONNECTION_CLOSED"
  "RFCOMM_CONN_RESULT_SOCKET_CONNECTION_FAILED"
  "RFCOMM_CONN_RESULT_SUCCESS"
  "RFCOMM_CONN_RESULT_UNABLE_TO_SEND_RPC";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry RfcommConnectionResult_entries[] = {
  { {RfcommConnectionResult_names + 0, 34}, 0 },
  { {RfcommConnectionResult_names + 34, 44}, 6 },
  { {RfcommConnectionResult_names + 78, 40}, 5 },
  { {RfcommConnectionResult_names + 118, 39}, 7 },
  { {RfcommConnectionResult_names + 157, 43}, 3 },
  { {RfcommConnectionResult_names + 200, 43}, 2 },
  { {RfcommConnectionResult_names + 243, 26}, 1 },
  { {RfcommConnectionResult_names + 269, 37}, 4 },
};

static const int RfcommConnectionResult_entries_by_number[] = {
  0, // 0 -> RFCOMM_CONN_RESULT_FAILURE_UNKNOWN
  6, // 1 -> RFCOMM_CONN_RESULT_SUCCESS
  5, // 2 -> RFCOMM_CONN_RESULT_SOCKET_CONNECTION_FAILED
  4, // 3 -> RFCOMM_CONN_RESULT_SOCKET_CONNECTION_CLOSED
  7, // 4 -> RFCOMM_CONN_RESULT_UNABLE_TO_SEND_RPC
  2, // 5 -> RFCOMM_CONN_RESULT_NULL_BLUETOOTH_DEVICE
  1, // 6 -> RFCOMM_CONN_RESULT_GET_SOCKET_MANAGER_FAILED
  3, // 7 -> RFCOMM_CONN_RESULT_NULL_FILE_DESCRIPTOR
};

const std::string& RfcommConnectionResult_Name(
    RfcommConnectionResult value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          RfcommConnectionResult_entries,
          RfcommConnectionResult_entries_by_number,
          8, RfcommConnectionResult_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      RfcommConnectionResult_entries,
      RfcommConnectionResult_entries_by_number,
      8, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     RfcommConnectionResult_strings[idx].get();
}
bool RfcommConnectionResult_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RfcommConnectionResult* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      RfcommConnectionResult_entries, 8, name, &int_value);
  if (success) {
    *value = static_cast<RfcommConnectionResult>(int_value);
  }
  return success;
}
bool SocketConnectionSecurity_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SocketConnectionSecurity_strings[3] = {};

static const char SocketConnectionSecurity_names[] =
  "SOCKET_SECURITY_INSECURE"
  "SOCKET_SECURITY_SECURE"
  "SOCKET_SECURITY_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SocketConnectionSecurity_entries[] = {
  { {SocketConnectionSecurity_names + 0, 24}, 2 },
  { {SocketConnectionSecurity_names + 24, 22}, 1 },
  { {SocketConnectionSecurity_names + 46, 23}, 0 },
};

static const int SocketConnectionSecurity_entries_by_number[] = {
  2, // 0 -> SOCKET_SECURITY_UNKNOWN
  1, // 1 -> SOCKET_SECURITY_SECURE
  0, // 2 -> SOCKET_SECURITY_INSECURE
};

const std::string& SocketConnectionSecurity_Name(
    SocketConnectionSecurity value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          SocketConnectionSecurity_entries,
          SocketConnectionSecurity_entries_by_number,
          3, SocketConnectionSecurity_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      SocketConnectionSecurity_entries,
      SocketConnectionSecurity_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     SocketConnectionSecurity_strings[idx].get();
}
bool SocketConnectionSecurity_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SocketConnectionSecurity* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      SocketConnectionSecurity_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<SocketConnectionSecurity>(int_value);
  }
  return success;
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace rfcomm
}  // namespace bluetooth
}  // namespace android
PROTOBUF_NAMESPACE_OPEN
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
