// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: frameworks/proto_logging/stats/enums/bluetooth/le/enums.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_frameworks_2fproto_5flogging_2fstats_2fenums_2fbluetooth_2fle_2fenums_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_frameworks_2fproto_5flogging_2fstats_2fenums_2fbluetooth_2fle_2fenums_2eproto

#include <cstdint>
#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_frameworks_2fproto_5flogging_2fstats_2fenums_2fbluetooth_2fle_2fenums_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_frameworks_2fproto_5flogging_2fstats_2fenums_2fbluetooth_2fle_2fenums_2eproto {
  static const ::uint32_t offsets[];
};
PROTOBUF_NAMESPACE_OPEN
PROTOBUF_NAMESPACE_CLOSE
namespace android {
namespace bluetooth {
namespace le {

enum LeAclConnectionState : int {
  LE_ACL_UNSPECIFIED = 0,
  LE_ACL_SUCCESS = 1,
  LE_ACL_FAILED = 2,
  LE_ACL_ALREADY_PRESENT = 3
};
bool LeAclConnectionState_IsValid(int value);
constexpr LeAclConnectionState LeAclConnectionState_MIN = LE_ACL_UNSPECIFIED;
constexpr LeAclConnectionState LeAclConnectionState_MAX = LE_ACL_ALREADY_PRESENT;
constexpr int LeAclConnectionState_ARRAYSIZE = LeAclConnectionState_MAX + 1;

const std::string& LeAclConnectionState_Name(LeAclConnectionState value);
template<typename T>
inline const std::string& LeAclConnectionState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LeAclConnectionState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LeAclConnectionState_Name.");
  return LeAclConnectionState_Name(static_cast<LeAclConnectionState>(enum_t_value));
}
bool LeAclConnectionState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LeAclConnectionState* value);
enum LeConnectionOriginType : int {
  ORIGIN_UNSPECIFIED = 0,
  ORIGIN_NATIVE = 1,
  ORIGIN_JAVA = 2
};
bool LeConnectionOriginType_IsValid(int value);
constexpr LeConnectionOriginType LeConnectionOriginType_MIN = ORIGIN_UNSPECIFIED;
constexpr LeConnectionOriginType LeConnectionOriginType_MAX = ORIGIN_JAVA;
constexpr int LeConnectionOriginType_ARRAYSIZE = LeConnectionOriginType_MAX + 1;

const std::string& LeConnectionOriginType_Name(LeConnectionOriginType value);
template<typename T>
inline const std::string& LeConnectionOriginType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LeConnectionOriginType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LeConnectionOriginType_Name.");
  return LeConnectionOriginType_Name(static_cast<LeConnectionOriginType>(enum_t_value));
}
bool LeConnectionOriginType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LeConnectionOriginType* value);
enum LeConnectionType : int {
  CONNECTION_TYPE_UNSPECIFIED = 0,
  CONNECTION_TYPE_LE_ACL = 1,
  CONNECTION_TYPE_GATT = 2,
  CONNECTION_TYPE_L2CAP_FIXED_CHNL_SMP = 3,
  CONNECTION_TYPE_L2CAP_FIXED_CHNL_ATT = 4,
  CONNECTION_TYPE_L2CAP_FIXED_CHNL_LE_SIGNALLING = 5,
  CONNECTION_TYPE_L2CAP_FIXED_CHNL_AMP = 6,
  CONNECTION_TYPE_L2CAP_FIXED_CHNL_SMP_BR_EDR = 7
};
bool LeConnectionType_IsValid(int value);
constexpr LeConnectionType LeConnectionType_MIN = CONNECTION_TYPE_UNSPECIFIED;
constexpr LeConnectionType LeConnectionType_MAX = CONNECTION_TYPE_L2CAP_FIXED_CHNL_SMP_BR_EDR;
constexpr int LeConnectionType_ARRAYSIZE = LeConnectionType_MAX + 1;

const std::string& LeConnectionType_Name(LeConnectionType value);
template<typename T>
inline const std::string& LeConnectionType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LeConnectionType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LeConnectionType_Name.");
  return LeConnectionType_Name(static_cast<LeConnectionType>(enum_t_value));
}
bool LeConnectionType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LeConnectionType* value);
enum LeConnectionState : int {
  STATE_UNSPECIFIED = 0,
  STATE_LE_ACL_START = 1,
  STATE_LE_ACL_END = 2,
  STATE_LE_ACL_CANCEL = 3,
  STATE_LE_ACL_TIMEOUT = 4,
  STATE_GATT_APP_USE_LINK_FLAG = 5,
  STATE_GATT_CREATE_DIRECT_CONN = 6,
  STATE_GATT_HOLD_LINK_EMPTY = 7,
  STATE_GATT_CONNECT_NATIVE = 8,
  STATE_GATT_APP_CREATE_LE_ACL = 9,
  STATE_GATT_CONN_STATE_CHANGE_CLIENT = 10,
  STATE_GATT_CONN_STATE_CHANGE_SERVER = 11,
  STATE_L2CAP_FIXED_CHNL_START_CREATE_CONN = 12,
  STATE_L2CAP_FIXED_CHNL_START_LE_ACL = 13,
  STATE_L2CAP_FIXED_CHNL_LE_ACL_FINISH = 14
};
bool LeConnectionState_IsValid(int value);
constexpr LeConnectionState LeConnectionState_MIN = STATE_UNSPECIFIED;
constexpr LeConnectionState LeConnectionState_MAX = STATE_L2CAP_FIXED_CHNL_LE_ACL_FINISH;
constexpr int LeConnectionState_ARRAYSIZE = LeConnectionState_MAX + 1;

const std::string& LeConnectionState_Name(LeConnectionState value);
template<typename T>
inline const std::string& LeConnectionState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LeConnectionState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LeConnectionState_Name.");
  return LeConnectionState_Name(static_cast<LeConnectionState>(enum_t_value));
}
bool LeConnectionState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LeConnectionState* value);
enum LeScanCallbackType : int {
  TYPE_UNKNOWN = 0,
  TYPE_ALL_MATCHES = 1,
  TYPE_FIRST_MATCH = 2,
  TYPE_MATCH_LOST = 4,
  TYPE_ALL_MATCHES_AUTO_BATCH = 8
};
bool LeScanCallbackType_IsValid(int value);
constexpr LeScanCallbackType LeScanCallbackType_MIN = TYPE_UNKNOWN;
constexpr LeScanCallbackType LeScanCallbackType_MAX = TYPE_ALL_MATCHES_AUTO_BATCH;
constexpr int LeScanCallbackType_ARRAYSIZE = LeScanCallbackType_MAX + 1;

const std::string& LeScanCallbackType_Name(LeScanCallbackType value);
template<typename T>
inline const std::string& LeScanCallbackType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LeScanCallbackType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LeScanCallbackType_Name.");
  return LeScanCallbackType_Name(static_cast<LeScanCallbackType>(enum_t_value));
}
bool LeScanCallbackType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LeScanCallbackType* value);
enum LeScanType : int {
  SCAN_TYPE_UNKNOWN = 0,
  SCAN_TYPE_REGULAR = 1,
  SCAN_TYPE_BATCH = 2,
  SCAN_TYPE_AUTO_BATCH = 3
};
bool LeScanType_IsValid(int value);
constexpr LeScanType LeScanType_MIN = SCAN_TYPE_UNKNOWN;
constexpr LeScanType LeScanType_MAX = SCAN_TYPE_AUTO_BATCH;
constexpr int LeScanType_ARRAYSIZE = LeScanType_MAX + 1;

const std::string& LeScanType_Name(LeScanType value);
template<typename T>
inline const std::string& LeScanType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LeScanType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LeScanType_Name.");
  return LeScanType_Name(static_cast<LeScanType>(enum_t_value));
}
bool LeScanType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LeScanType* value);
enum LeScanMode : int {
  SCAN_MODE_UNKNOWN = 0,
  SCAN_MODE_OPPORTUNISTIC = 1,
  SCAN_MODE_LOW_POWER = 2,
  SCAN_MODE_BALANCED = 3,
  SCAN_MODE_LOW_LATENCY = 4,
  SCAN_MODE_AMBIENT_DISCOVERY = 5,
  SCAN_MODE_SCREEN_OFF = 6,
  SCAN_MODE_SCREEN_OFF_BALANCED = 7,
  SCAN_MODE_CUSTOM = 20
};
bool LeScanMode_IsValid(int value);
constexpr LeScanMode LeScanMode_MIN = SCAN_MODE_UNKNOWN;
constexpr LeScanMode LeScanMode_MAX = SCAN_MODE_CUSTOM;
constexpr int LeScanMode_ARRAYSIZE = LeScanMode_MAX + 1;

const std::string& LeScanMode_Name(LeScanMode value);
template<typename T>
inline const std::string& LeScanMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LeScanMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LeScanMode_Name.");
  return LeScanMode_Name(static_cast<LeScanMode>(enum_t_value));
}
bool LeScanMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LeScanMode* value);
enum LeScanAbuseReason : int {
  REASON_UNKNOWN = 0,
  REASON_SCAN_TIMEOUT = 1,
  REASON_HW_FILTER_NA = 2,
  REASON_TRACKING_HW_FILTER_NA = 3
};
bool LeScanAbuseReason_IsValid(int value);
constexpr LeScanAbuseReason LeScanAbuseReason_MIN = REASON_UNKNOWN;
constexpr LeScanAbuseReason LeScanAbuseReason_MAX = REASON_TRACKING_HW_FILTER_NA;
constexpr int LeScanAbuseReason_ARRAYSIZE = LeScanAbuseReason_MAX + 1;

const std::string& LeScanAbuseReason_Name(LeScanAbuseReason value);
template<typename T>
inline const std::string& LeScanAbuseReason_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LeScanAbuseReason>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LeScanAbuseReason_Name.");
  return LeScanAbuseReason_Name(static_cast<LeScanAbuseReason>(enum_t_value));
}
bool LeScanAbuseReason_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LeScanAbuseReason* value);
enum LeAdvInterval : int {
  INTERVAL_UNKNOWN = 0,
  INTERVAL_HIGH = 1,
  INTERVAL_MEDIUM = 2,
  INTERVAL_LOW = 3
};
bool LeAdvInterval_IsValid(int value);
constexpr LeAdvInterval LeAdvInterval_MIN = INTERVAL_UNKNOWN;
constexpr LeAdvInterval LeAdvInterval_MAX = INTERVAL_LOW;
constexpr int LeAdvInterval_ARRAYSIZE = LeAdvInterval_MAX + 1;

const std::string& LeAdvInterval_Name(LeAdvInterval value);
template<typename T>
inline const std::string& LeAdvInterval_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LeAdvInterval>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LeAdvInterval_Name.");
  return LeAdvInterval_Name(static_cast<LeAdvInterval>(enum_t_value));
}
bool LeAdvInterval_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LeAdvInterval* value);
enum LeAdvTxPower : int {
  TX_POWER_UNKNOWN = 0,
  TX_POWER_ULTRA_LOW = 1,
  TX_POWER_LOW = 2,
  TX_POWER_MEDIUM = 3,
  TX_POWER_HIGH = 4
};
bool LeAdvTxPower_IsValid(int value);
constexpr LeAdvTxPower LeAdvTxPower_MIN = TX_POWER_UNKNOWN;
constexpr LeAdvTxPower LeAdvTxPower_MAX = TX_POWER_HIGH;
constexpr int LeAdvTxPower_ARRAYSIZE = LeAdvTxPower_MAX + 1;

const std::string& LeAdvTxPower_Name(LeAdvTxPower value);
template<typename T>
inline const std::string& LeAdvTxPower_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LeAdvTxPower>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LeAdvTxPower_Name.");
  return LeAdvTxPower_Name(static_cast<LeAdvTxPower>(enum_t_value));
}
bool LeAdvTxPower_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LeAdvTxPower* value);
enum LeAdvOpCode : int {
  ERROR_CODE_UNKNOWN = 0,
  ERROR_CODE_ON_START = 1
};
bool LeAdvOpCode_IsValid(int value);
constexpr LeAdvOpCode LeAdvOpCode_MIN = ERROR_CODE_UNKNOWN;
constexpr LeAdvOpCode LeAdvOpCode_MAX = ERROR_CODE_ON_START;
constexpr int LeAdvOpCode_ARRAYSIZE = LeAdvOpCode_MAX + 1;

const std::string& LeAdvOpCode_Name(LeAdvOpCode value);
template<typename T>
inline const std::string& LeAdvOpCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LeAdvOpCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LeAdvOpCode_Name.");
  return LeAdvOpCode_Name(static_cast<LeAdvOpCode>(enum_t_value));
}
bool LeAdvOpCode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LeAdvOpCode* value);
enum LeAdvStatusCode : int {
  ADV_STATUS_UNKNOWN = 0,
  ADV_STATUS_SUCCESS = 1,
  ADV_STATUS_FAILED_DATA_TOO_LARGE = 2,
  ADV_STATUS_FAILED_TOO_MANY_ADVERTISERS = 3,
  ADV_STATUS_FAILED_ALREADY_STARTED = 4,
  ADV_STATUS_FAILED_INTERNAL_ERROR = 5,
  ADV_STATUS_FAILED_FEATURE_UNSUPPORTED = 6
};
bool LeAdvStatusCode_IsValid(int value);
constexpr LeAdvStatusCode LeAdvStatusCode_MIN = ADV_STATUS_UNKNOWN;
constexpr LeAdvStatusCode LeAdvStatusCode_MAX = ADV_STATUS_FAILED_FEATURE_UNSUPPORTED;
constexpr int LeAdvStatusCode_ARRAYSIZE = LeAdvStatusCode_MAX + 1;

const std::string& LeAdvStatusCode_Name(LeAdvStatusCode value);
template<typename T>
inline const std::string& LeAdvStatusCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LeAdvStatusCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LeAdvStatusCode_Name.");
  return LeAdvStatusCode_Name(static_cast<LeAdvStatusCode>(enum_t_value));
}
bool LeAdvStatusCode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LeAdvStatusCode* value);
// ===================================================================


// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)

}  // namespace le
}  // namespace bluetooth
}  // namespace android

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::android::bluetooth::le::LeAclConnectionState> : ::std::true_type {};
template <> struct is_proto_enum< ::android::bluetooth::le::LeConnectionOriginType> : ::std::true_type {};
template <> struct is_proto_enum< ::android::bluetooth::le::LeConnectionType> : ::std::true_type {};
template <> struct is_proto_enum< ::android::bluetooth::le::LeConnectionState> : ::std::true_type {};
template <> struct is_proto_enum< ::android::bluetooth::le::LeScanCallbackType> : ::std::true_type {};
template <> struct is_proto_enum< ::android::bluetooth::le::LeScanType> : ::std::true_type {};
template <> struct is_proto_enum< ::android::bluetooth::le::LeScanMode> : ::std::true_type {};
template <> struct is_proto_enum< ::android::bluetooth::le::LeScanAbuseReason> : ::std::true_type {};
template <> struct is_proto_enum< ::android::bluetooth::le::LeAdvInterval> : ::std::true_type {};
template <> struct is_proto_enum< ::android::bluetooth::le::LeAdvTxPower> : ::std::true_type {};
template <> struct is_proto_enum< ::android::bluetooth::le::LeAdvOpCode> : ::std::true_type {};
template <> struct is_proto_enum< ::android::bluetooth::le::LeAdvStatusCode> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_frameworks_2fproto_5flogging_2fstats_2fenums_2fbluetooth_2fle_2fenums_2eproto
