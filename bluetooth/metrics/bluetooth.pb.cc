// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: packages/modules/Bluetooth/system/gd/proto/bluetooth/metrics/bluetooth.proto

#include "packages/modules/Bluetooth/system/gd/proto/bluetooth/metrics/bluetooth.pb.h"

#include <algorithm>
#include <cstdint>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace bluetooth {
namespace metrics {
namespace BluetoothMetricsProto {
PROTOBUF_CONSTEXPR BluetoothLog::BluetoothLog(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.session_)*/{}
  , /*decltype(_impl_.pair_event_)*/{}
  , /*decltype(_impl_.wake_event_)*/{}
  , /*decltype(_impl_.scan_event_)*/{}
  , /*decltype(_impl_.profile_connection_stats_)*/{}
  , /*decltype(_impl_.headset_profile_connection_stats_)*/{}
  , /*decltype(_impl_.num_bluetooth_session_)*/::int64_t{0}
  , /*decltype(_impl_.num_pair_event_)*/::int64_t{0}
  , /*decltype(_impl_.num_wake_event_)*/::int64_t{0}
  , /*decltype(_impl_.num_scan_event_)*/::int64_t{0}
  , /*decltype(_impl_.num_bonded_devices_)*/0} {}
struct BluetoothLogDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BluetoothLogDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BluetoothLogDefaultTypeInternal() {}
  union {  // NOLINT(misc-non-private-member-variables-in-classes)
    BluetoothLog _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BluetoothLogDefaultTypeInternal _BluetoothLog_default_instance_;
PROTOBUF_CONSTEXPR DeviceInfo::DeviceInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.device_class_)*/0
  , /*decltype(_impl_.device_type_)*/0} {}
struct DeviceInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeviceInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeviceInfoDefaultTypeInternal() {}
  union {  // NOLINT(misc-non-private-member-variables-in-classes)
    DeviceInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeviceInfoDefaultTypeInternal _DeviceInfo_default_instance_;
PROTOBUF_CONSTEXPR BluetoothSession::BluetoothSession(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.disconnect_reason_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.device_connected_to_)*/nullptr
  , /*decltype(_impl_.rfcomm_session_)*/nullptr
  , /*decltype(_impl_.a2dp_session_)*/nullptr
  , /*decltype(_impl_.session_duration_sec_)*/::int64_t{0}
  , /*decltype(_impl_.connection_technology_type_)*/0
  , /*decltype(_impl_.disconnect_reason_type_)*/0} {}
struct BluetoothSessionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BluetoothSessionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BluetoothSessionDefaultTypeInternal() {}
  union {  // NOLINT(misc-non-private-member-variables-in-classes)
    BluetoothSession _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BluetoothSessionDefaultTypeInternal _BluetoothSession_default_instance_;
PROTOBUF_CONSTEXPR RFCommSession::RFCommSession(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.rx_bytes_)*/0
  , /*decltype(_impl_.tx_bytes_)*/0} {}
struct RFCommSessionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RFCommSessionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RFCommSessionDefaultTypeInternal() {}
  union {  // NOLINT(misc-non-private-member-variables-in-classes)
    RFCommSession _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RFCommSessionDefaultTypeInternal _RFCommSession_default_instance_;
PROTOBUF_CONSTEXPR A2DPSession::A2DPSession(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.media_timer_min_millis_)*/0
  , /*decltype(_impl_.media_timer_max_millis_)*/0
  , /*decltype(_impl_.media_timer_avg_millis_)*/0
  , /*decltype(_impl_.buffer_overruns_max_count_)*/0
  , /*decltype(_impl_.buffer_overruns_total_)*/0
  , /*decltype(_impl_.buffer_underruns_average_)*/0
  , /*decltype(_impl_.audio_duration_millis_)*/::int64_t{0}
  , /*decltype(_impl_.buffer_underruns_count_)*/0
  , /*decltype(_impl_.source_codec_)*/0
  , /*decltype(_impl_.is_a2dp_offload_)*/false} {}
struct A2DPSessionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR A2DPSessionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~A2DPSessionDefaultTypeInternal() {}
  union {  // NOLINT(misc-non-private-member-variables-in-classes)
    A2DPSession _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 A2DPSessionDefaultTypeInternal _A2DPSession_default_instance_;
PROTOBUF_CONSTEXPR PairEvent::PairEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.device_paired_with_)*/nullptr
  , /*decltype(_impl_.event_time_millis_)*/::int64_t{0}
  , /*decltype(_impl_.disconnect_reason_)*/0} {}
struct PairEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PairEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PairEventDefaultTypeInternal() {}
  union {  // NOLINT(misc-non-private-member-variables-in-classes)
    PairEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PairEventDefaultTypeInternal _PairEvent_default_instance_;
PROTOBUF_CONSTEXPR WakeEvent::WakeEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.requestor_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.event_time_millis_)*/::int64_t{0}
  , /*decltype(_impl_.wake_event_type_)*/0} {}
struct WakeEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR WakeEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~WakeEventDefaultTypeInternal() {}
  union {  // NOLINT(misc-non-private-member-variables-in-classes)
    WakeEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 WakeEventDefaultTypeInternal _WakeEvent_default_instance_;
PROTOBUF_CONSTEXPR ScanEvent::ScanEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.initiator_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.scan_event_type_)*/0
  , /*decltype(_impl_.scan_technology_type_)*/0
  , /*decltype(_impl_.event_time_millis_)*/::int64_t{0}
  , /*decltype(_impl_.number_results_)*/0} {}
struct ScanEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ScanEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ScanEventDefaultTypeInternal() {}
  union {  // NOLINT(misc-non-private-member-variables-in-classes)
    ScanEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ScanEventDefaultTypeInternal _ScanEvent_default_instance_;
PROTOBUF_CONSTEXPR ProfileConnectionStats::ProfileConnectionStats(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.profile_id_)*/0
  , /*decltype(_impl_.num_times_connected_)*/0} {}
struct ProfileConnectionStatsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ProfileConnectionStatsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ProfileConnectionStatsDefaultTypeInternal() {}
  union {  // NOLINT(misc-non-private-member-variables-in-classes)
    ProfileConnectionStats _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ProfileConnectionStatsDefaultTypeInternal _ProfileConnectionStats_default_instance_;
PROTOBUF_CONSTEXPR HeadsetProfileConnectionStats::HeadsetProfileConnectionStats(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.headset_profile_type_)*/0
  , /*decltype(_impl_.num_times_connected_)*/0} {}
struct HeadsetProfileConnectionStatsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HeadsetProfileConnectionStatsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~HeadsetProfileConnectionStatsDefaultTypeInternal() {}
  union {  // NOLINT(misc-non-private-member-variables-in-classes)
    HeadsetProfileConnectionStats _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HeadsetProfileConnectionStatsDefaultTypeInternal _HeadsetProfileConnectionStats_default_instance_;
PROTOBUF_CONSTEXPR BluetoothRemoteDeviceInformation::BluetoothRemoteDeviceInformation(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.allowlisted_device_name_hash_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.class_of_device_)*/0
  , /*decltype(_impl_.oui_)*/0} {}
struct BluetoothRemoteDeviceInformationDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BluetoothRemoteDeviceInformationDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BluetoothRemoteDeviceInformationDefaultTypeInternal() {}
  union {  // NOLINT(misc-non-private-member-variables-in-classes)
    BluetoothRemoteDeviceInformation _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BluetoothRemoteDeviceInformationDefaultTypeInternal _BluetoothRemoteDeviceInformation_default_instance_;
}  // namespace BluetoothMetricsProto
}  // namespace metrics
}  // namespace bluetooth
namespace bluetooth {
namespace metrics {
namespace BluetoothMetricsProto {
bool DeviceInfo_DeviceType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> DeviceInfo_DeviceType_strings[4] = {};

static const char DeviceInfo_DeviceType_names[] =
  "DEVICE_TYPE_BREDR"
  "DEVICE_TYPE_DUMO"
  "DEVICE_TYPE_LE"
  "DEVICE_TYPE_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry DeviceInfo_DeviceType_entries[] = {
  { {DeviceInfo_DeviceType_names + 0, 17}, 1 },
  { {DeviceInfo_DeviceType_names + 17, 16}, 3 },
  { {DeviceInfo_DeviceType_names + 33, 14}, 2 },
  { {DeviceInfo_DeviceType_names + 47, 19}, 0 },
};

static const int DeviceInfo_DeviceType_entries_by_number[] = {
  3, // 0 -> DEVICE_TYPE_UNKNOWN
  0, // 1 -> DEVICE_TYPE_BREDR
  2, // 2 -> DEVICE_TYPE_LE
  1, // 3 -> DEVICE_TYPE_DUMO
};

const std::string& DeviceInfo_DeviceType_Name(
    DeviceInfo_DeviceType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          DeviceInfo_DeviceType_entries,
          DeviceInfo_DeviceType_entries_by_number,
          4, DeviceInfo_DeviceType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      DeviceInfo_DeviceType_entries,
      DeviceInfo_DeviceType_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     DeviceInfo_DeviceType_strings[idx].get();
}
bool DeviceInfo_DeviceType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DeviceInfo_DeviceType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      DeviceInfo_DeviceType_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<DeviceInfo_DeviceType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr DeviceInfo_DeviceType DeviceInfo::DEVICE_TYPE_UNKNOWN;
constexpr DeviceInfo_DeviceType DeviceInfo::DEVICE_TYPE_BREDR;
constexpr DeviceInfo_DeviceType DeviceInfo::DEVICE_TYPE_LE;
constexpr DeviceInfo_DeviceType DeviceInfo::DEVICE_TYPE_DUMO;
constexpr DeviceInfo_DeviceType DeviceInfo::DeviceType_MIN;
constexpr DeviceInfo_DeviceType DeviceInfo::DeviceType_MAX;
constexpr int DeviceInfo::DeviceType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool BluetoothSession_ConnectionTechnologyType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> BluetoothSession_ConnectionTechnologyType_strings[3] = {};

static const char BluetoothSession_ConnectionTechnologyType_names[] =
  "CONNECTION_TECHNOLOGY_TYPE_BREDR"
  "CONNECTION_TECHNOLOGY_TYPE_LE"
  "CONNECTION_TECHNOLOGY_TYPE_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry BluetoothSession_ConnectionTechnologyType_entries[] = {
  { {BluetoothSession_ConnectionTechnologyType_names + 0, 32}, 2 },
  { {BluetoothSession_ConnectionTechnologyType_names + 32, 29}, 1 },
  { {BluetoothSession_ConnectionTechnologyType_names + 61, 34}, 0 },
};

static const int BluetoothSession_ConnectionTechnologyType_entries_by_number[] = {
  2, // 0 -> CONNECTION_TECHNOLOGY_TYPE_UNKNOWN
  1, // 1 -> CONNECTION_TECHNOLOGY_TYPE_LE
  0, // 2 -> CONNECTION_TECHNOLOGY_TYPE_BREDR
};

const std::string& BluetoothSession_ConnectionTechnologyType_Name(
    BluetoothSession_ConnectionTechnologyType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          BluetoothSession_ConnectionTechnologyType_entries,
          BluetoothSession_ConnectionTechnologyType_entries_by_number,
          3, BluetoothSession_ConnectionTechnologyType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      BluetoothSession_ConnectionTechnologyType_entries,
      BluetoothSession_ConnectionTechnologyType_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     BluetoothSession_ConnectionTechnologyType_strings[idx].get();
}
bool BluetoothSession_ConnectionTechnologyType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BluetoothSession_ConnectionTechnologyType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      BluetoothSession_ConnectionTechnologyType_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<BluetoothSession_ConnectionTechnologyType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr BluetoothSession_ConnectionTechnologyType BluetoothSession::CONNECTION_TECHNOLOGY_TYPE_UNKNOWN;
constexpr BluetoothSession_ConnectionTechnologyType BluetoothSession::CONNECTION_TECHNOLOGY_TYPE_LE;
constexpr BluetoothSession_ConnectionTechnologyType BluetoothSession::CONNECTION_TECHNOLOGY_TYPE_BREDR;
constexpr BluetoothSession_ConnectionTechnologyType BluetoothSession::ConnectionTechnologyType_MIN;
constexpr BluetoothSession_ConnectionTechnologyType BluetoothSession::ConnectionTechnologyType_MAX;
constexpr int BluetoothSession::ConnectionTechnologyType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool BluetoothSession_DisconnectReasonType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> BluetoothSession_DisconnectReasonType_strings[3] = {};

static const char BluetoothSession_DisconnectReasonType_names[] =
  "METRICS_DUMP"
  "NEXT_START_WITHOUT_END_PREVIOUS"
  "UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry BluetoothSession_DisconnectReasonType_entries[] = {
  { {BluetoothSession_DisconnectReasonType_names + 0, 12}, 1 },
  { {BluetoothSession_DisconnectReasonType_names + 12, 31}, 2 },
  { {BluetoothSession_DisconnectReasonType_names + 43, 7}, 0 },
};

static const int BluetoothSession_DisconnectReasonType_entries_by_number[] = {
  2, // 0 -> UNKNOWN
  0, // 1 -> METRICS_DUMP
  1, // 2 -> NEXT_START_WITHOUT_END_PREVIOUS
};

const std::string& BluetoothSession_DisconnectReasonType_Name(
    BluetoothSession_DisconnectReasonType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          BluetoothSession_DisconnectReasonType_entries,
          BluetoothSession_DisconnectReasonType_entries_by_number,
          3, BluetoothSession_DisconnectReasonType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      BluetoothSession_DisconnectReasonType_entries,
      BluetoothSession_DisconnectReasonType_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     BluetoothSession_DisconnectReasonType_strings[idx].get();
}
bool BluetoothSession_DisconnectReasonType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BluetoothSession_DisconnectReasonType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      BluetoothSession_DisconnectReasonType_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<BluetoothSession_DisconnectReasonType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr BluetoothSession_DisconnectReasonType BluetoothSession::UNKNOWN;
constexpr BluetoothSession_DisconnectReasonType BluetoothSession::METRICS_DUMP;
constexpr BluetoothSession_DisconnectReasonType BluetoothSession::NEXT_START_WITHOUT_END_PREVIOUS;
constexpr BluetoothSession_DisconnectReasonType BluetoothSession::DisconnectReasonType_MIN;
constexpr BluetoothSession_DisconnectReasonType BluetoothSession::DisconnectReasonType_MAX;
constexpr int BluetoothSession::DisconnectReasonType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool WakeEvent_WakeEventType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> WakeEvent_WakeEventType_strings[3] = {};

static const char WakeEvent_WakeEventType_names[] =
  "ACQUIRED"
  "RELEASED"
  "UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry WakeEvent_WakeEventType_entries[] = {
  { {WakeEvent_WakeEventType_names + 0, 8}, 1 },
  { {WakeEvent_WakeEventType_names + 8, 8}, 2 },
  { {WakeEvent_WakeEventType_names + 16, 7}, 0 },
};

static const int WakeEvent_WakeEventType_entries_by_number[] = {
  2, // 0 -> UNKNOWN
  0, // 1 -> ACQUIRED
  1, // 2 -> RELEASED
};

const std::string& WakeEvent_WakeEventType_Name(
    WakeEvent_WakeEventType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          WakeEvent_WakeEventType_entries,
          WakeEvent_WakeEventType_entries_by_number,
          3, WakeEvent_WakeEventType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      WakeEvent_WakeEventType_entries,
      WakeEvent_WakeEventType_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     WakeEvent_WakeEventType_strings[idx].get();
}
bool WakeEvent_WakeEventType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, WakeEvent_WakeEventType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      WakeEvent_WakeEventType_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<WakeEvent_WakeEventType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr WakeEvent_WakeEventType WakeEvent::UNKNOWN;
constexpr WakeEvent_WakeEventType WakeEvent::ACQUIRED;
constexpr WakeEvent_WakeEventType WakeEvent::RELEASED;
constexpr WakeEvent_WakeEventType WakeEvent::WakeEventType_MIN;
constexpr WakeEvent_WakeEventType WakeEvent::WakeEventType_MAX;
constexpr int WakeEvent::WakeEventType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ScanEvent_ScanTechnologyType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ScanEvent_ScanTechnologyType_strings[4] = {};

static const char ScanEvent_ScanTechnologyType_names[] =
  "SCAN_TECH_TYPE_BOTH"
  "SCAN_TECH_TYPE_BREDR"
  "SCAN_TECH_TYPE_LE"
  "SCAN_TYPE_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ScanEvent_ScanTechnologyType_entries[] = {
  { {ScanEvent_ScanTechnologyType_names + 0, 19}, 3 },
  { {ScanEvent_ScanTechnologyType_names + 19, 20}, 2 },
  { {ScanEvent_ScanTechnologyType_names + 39, 17}, 1 },
  { {ScanEvent_ScanTechnologyType_names + 56, 17}, 0 },
};

static const int ScanEvent_ScanTechnologyType_entries_by_number[] = {
  3, // 0 -> SCAN_TYPE_UNKNOWN
  2, // 1 -> SCAN_TECH_TYPE_LE
  1, // 2 -> SCAN_TECH_TYPE_BREDR
  0, // 3 -> SCAN_TECH_TYPE_BOTH
};

const std::string& ScanEvent_ScanTechnologyType_Name(
    ScanEvent_ScanTechnologyType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ScanEvent_ScanTechnologyType_entries,
          ScanEvent_ScanTechnologyType_entries_by_number,
          4, ScanEvent_ScanTechnologyType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ScanEvent_ScanTechnologyType_entries,
      ScanEvent_ScanTechnologyType_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ScanEvent_ScanTechnologyType_strings[idx].get();
}
bool ScanEvent_ScanTechnologyType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ScanEvent_ScanTechnologyType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ScanEvent_ScanTechnologyType_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<ScanEvent_ScanTechnologyType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ScanEvent_ScanTechnologyType ScanEvent::SCAN_TYPE_UNKNOWN;
constexpr ScanEvent_ScanTechnologyType ScanEvent::SCAN_TECH_TYPE_LE;
constexpr ScanEvent_ScanTechnologyType ScanEvent::SCAN_TECH_TYPE_BREDR;
constexpr ScanEvent_ScanTechnologyType ScanEvent::SCAN_TECH_TYPE_BOTH;
constexpr ScanEvent_ScanTechnologyType ScanEvent::ScanTechnologyType_MIN;
constexpr ScanEvent_ScanTechnologyType ScanEvent::ScanTechnologyType_MAX;
constexpr int ScanEvent::ScanTechnologyType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ScanEvent_ScanEventType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ScanEvent_ScanEventType_strings[2] = {};

static const char ScanEvent_ScanEventType_names[] =
  "SCAN_EVENT_START"
  "SCAN_EVENT_STOP";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ScanEvent_ScanEventType_entries[] = {
  { {ScanEvent_ScanEventType_names + 0, 16}, 0 },
  { {ScanEvent_ScanEventType_names + 16, 15}, 1 },
};

static const int ScanEvent_ScanEventType_entries_by_number[] = {
  0, // 0 -> SCAN_EVENT_START
  1, // 1 -> SCAN_EVENT_STOP
};

const std::string& ScanEvent_ScanEventType_Name(
    ScanEvent_ScanEventType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ScanEvent_ScanEventType_entries,
          ScanEvent_ScanEventType_entries_by_number,
          2, ScanEvent_ScanEventType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ScanEvent_ScanEventType_entries,
      ScanEvent_ScanEventType_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ScanEvent_ScanEventType_strings[idx].get();
}
bool ScanEvent_ScanEventType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ScanEvent_ScanEventType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ScanEvent_ScanEventType_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<ScanEvent_ScanEventType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ScanEvent_ScanEventType ScanEvent::SCAN_EVENT_START;
constexpr ScanEvent_ScanEventType ScanEvent::SCAN_EVENT_STOP;
constexpr ScanEvent_ScanEventType ScanEvent::ScanEventType_MIN;
constexpr ScanEvent_ScanEventType ScanEvent::ScanEventType_MAX;
constexpr int ScanEvent::ScanEventType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool A2dpSourceCodec_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> A2dpSourceCodec_strings[6] = {};

static const char A2dpSourceCodec_names[] =
  "A2DP_SOURCE_CODEC_AAC"
  "A2DP_SOURCE_CODEC_APTX"
  "A2DP_SOURCE_CODEC_APTX_HD"
  "A2DP_SOURCE_CODEC_LDAC"
  "A2DP_SOURCE_CODEC_SBC"
  "A2DP_SOURCE_CODEC_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry A2dpSourceCodec_entries[] = {
  { {A2dpSourceCodec_names + 0, 21}, 2 },
  { {A2dpSourceCodec_names + 21, 22}, 3 },
  { {A2dpSourceCodec_names + 43, 25}, 4 },
  { {A2dpSourceCodec_names + 68, 22}, 5 },
  { {A2dpSourceCodec_names + 90, 21}, 1 },
  { {A2dpSourceCodec_names + 111, 25}, 0 },
};

static const int A2dpSourceCodec_entries_by_number[] = {
  5, // 0 -> A2DP_SOURCE_CODEC_UNKNOWN
  4, // 1 -> A2DP_SOURCE_CODEC_SBC
  0, // 2 -> A2DP_SOURCE_CODEC_AAC
  1, // 3 -> A2DP_SOURCE_CODEC_APTX
  2, // 4 -> A2DP_SOURCE_CODEC_APTX_HD
  3, // 5 -> A2DP_SOURCE_CODEC_LDAC
};

const std::string& A2dpSourceCodec_Name(
    A2dpSourceCodec value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          A2dpSourceCodec_entries,
          A2dpSourceCodec_entries_by_number,
          6, A2dpSourceCodec_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      A2dpSourceCodec_entries,
      A2dpSourceCodec_entries_by_number,
      6, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     A2dpSourceCodec_strings[idx].get();
}
bool A2dpSourceCodec_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, A2dpSourceCodec* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      A2dpSourceCodec_entries, 6, name, &int_value);
  if (success) {
    *value = static_cast<A2dpSourceCodec>(int_value);
  }
  return success;
}
bool ProfileId_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ProfileId_strings[20] = {};

static const char ProfileId_names[] =
  "A2DP"
  "A2DP_SINK"
  "AVRCP"
  "AVRCP_CONTROLLER"
  "GATT"
  "GATT_SERVER"
  "HEADSET"
  "HEADSET_CLIENT"
  "HEALTH"
  "HEARING_AID"
  "HID_DEVICE"
  "HID_HOST"
  "MAP"
  "MAP_CLIENT"
  "OPP"
  "PAN"
  "PBAP"
  "PBAP_CLIENT"
  "PROFILE_UNKNOWN"
  "SAP";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ProfileId_entries[] = {
  { {ProfileId_names + 0, 4}, 2 },
  { {ProfileId_names + 4, 9}, 11 },
  { {ProfileId_names + 13, 5}, 13 },
  { {ProfileId_names + 18, 16}, 12 },
  { {ProfileId_names + 34, 4}, 7 },
  { {ProfileId_names + 38, 11}, 8 },
  { {ProfileId_names + 49, 7}, 1 },
  { {ProfileId_names + 56, 14}, 16 },
  { {ProfileId_names + 70, 6}, 3 },
  { {ProfileId_names + 76, 11}, 21 },
  { {ProfileId_names + 87, 10}, 19 },
  { {ProfileId_names + 97, 8}, 4 },
  { {ProfileId_names + 105, 3}, 9 },
  { {ProfileId_names + 108, 10}, 18 },
  { {ProfileId_names + 118, 3}, 20 },
  { {ProfileId_names + 121, 3}, 5 },
  { {ProfileId_names + 124, 4}, 6 },
  { {ProfileId_names + 128, 11}, 17 },
  { {ProfileId_names + 139, 15}, 0 },
  { {ProfileId_names + 154, 3}, 10 },
};

static const int ProfileId_entries_by_number[] = {
  18, // 0 -> PROFILE_UNKNOWN
  6, // 1 -> HEADSET
  0, // 2 -> A2DP
  8, // 3 -> HEALTH
  11, // 4 -> HID_HOST
  15, // 5 -> PAN
  16, // 6 -> PBAP
  4, // 7 -> GATT
  5, // 8 -> GATT_SERVER
  12, // 9 -> MAP
  19, // 10 -> SAP
  1, // 11 -> A2DP_SINK
  3, // 12 -> AVRCP_CONTROLLER
  2, // 13 -> AVRCP
  7, // 16 -> HEADSET_CLIENT
  17, // 17 -> PBAP_CLIENT
  13, // 18 -> MAP_CLIENT
  10, // 19 -> HID_DEVICE
  14, // 20 -> OPP
  9, // 21 -> HEARING_AID
};

const std::string& ProfileId_Name(
    ProfileId value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ProfileId_entries,
          ProfileId_entries_by_number,
          20, ProfileId_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ProfileId_entries,
      ProfileId_entries_by_number,
      20, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ProfileId_strings[idx].get();
}
bool ProfileId_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ProfileId* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ProfileId_entries, 20, name, &int_value);
  if (success) {
    *value = static_cast<ProfileId>(int_value);
  }
  return success;
}
bool HeadsetProfileType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> HeadsetProfileType_strings[3] = {};

static const char HeadsetProfileType_names[] =
  "HEADSET_PROFILE_UNKNOWN"
  "HFP"
  "HSP";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry HeadsetProfileType_entries[] = {
  { {HeadsetProfileType_names + 0, 23}, 0 },
  { {HeadsetProfileType_names + 23, 3}, 2 },
  { {HeadsetProfileType_names + 26, 3}, 1 },
};

static const int HeadsetProfileType_entries_by_number[] = {
  0, // 0 -> HEADSET_PROFILE_UNKNOWN
  2, // 1 -> HSP
  1, // 2 -> HFP
};

const std::string& HeadsetProfileType_Name(
    HeadsetProfileType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          HeadsetProfileType_entries,
          HeadsetProfileType_entries_by_number,
          3, HeadsetProfileType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      HeadsetProfileType_entries,
      HeadsetProfileType_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     HeadsetProfileType_strings[idx].get();
}
bool HeadsetProfileType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, HeadsetProfileType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      HeadsetProfileType_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<HeadsetProfileType>(int_value);
  }
  return success;
}

// ===================================================================

class BluetoothLog::_Internal {
 public:
  using HasBits = decltype(std::declval<BluetoothLog>()._impl_._has_bits_);
  static void set_has_num_bonded_devices(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_num_bluetooth_session(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_num_pair_event(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_num_wake_event(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_num_scan_event(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

BluetoothLog::BluetoothLog(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:bluetooth.metrics.BluetoothMetricsProto.BluetoothLog)
}
BluetoothLog::BluetoothLog(const BluetoothLog& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  BluetoothLog* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.session_){from._impl_.session_}
    , decltype(_impl_.pair_event_){from._impl_.pair_event_}
    , decltype(_impl_.wake_event_){from._impl_.wake_event_}
    , decltype(_impl_.scan_event_){from._impl_.scan_event_}
    , decltype(_impl_.profile_connection_stats_){from._impl_.profile_connection_stats_}
    , decltype(_impl_.headset_profile_connection_stats_){from._impl_.headset_profile_connection_stats_}
    , decltype(_impl_.num_bluetooth_session_){}
    , decltype(_impl_.num_pair_event_){}
    , decltype(_impl_.num_wake_event_){}
    , decltype(_impl_.num_scan_event_){}
    , decltype(_impl_.num_bonded_devices_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.num_bluetooth_session_, &from._impl_.num_bluetooth_session_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.num_bonded_devices_) -
    reinterpret_cast<char*>(&_impl_.num_bluetooth_session_)) + sizeof(_impl_.num_bonded_devices_));
  // @@protoc_insertion_point(copy_constructor:bluetooth.metrics.BluetoothMetricsProto.BluetoothLog)
}

inline void BluetoothLog::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.session_){arena}
    , decltype(_impl_.pair_event_){arena}
    , decltype(_impl_.wake_event_){arena}
    , decltype(_impl_.scan_event_){arena}
    , decltype(_impl_.profile_connection_stats_){arena}
    , decltype(_impl_.headset_profile_connection_stats_){arena}
    , decltype(_impl_.num_bluetooth_session_){::int64_t{0}}
    , decltype(_impl_.num_pair_event_){::int64_t{0}}
    , decltype(_impl_.num_wake_event_){::int64_t{0}}
    , decltype(_impl_.num_scan_event_){::int64_t{0}}
    , decltype(_impl_.num_bonded_devices_){0}
  };
}

BluetoothLog::~BluetoothLog() {
  // @@protoc_insertion_point(destructor:bluetooth.metrics.BluetoothMetricsProto.BluetoothLog)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BluetoothLog::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.session_.~RepeatedPtrField();
  _impl_.pair_event_.~RepeatedPtrField();
  _impl_.wake_event_.~RepeatedPtrField();
  _impl_.scan_event_.~RepeatedPtrField();
  _impl_.profile_connection_stats_.~RepeatedPtrField();
  _impl_.headset_profile_connection_stats_.~RepeatedPtrField();
}

void BluetoothLog::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BluetoothLog::Clear() {
// @@protoc_insertion_point(message_clear_start:bluetooth.metrics.BluetoothMetricsProto.BluetoothLog)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.session_.Clear();
  _impl_.pair_event_.Clear();
  _impl_.wake_event_.Clear();
  _impl_.scan_event_.Clear();
  _impl_.profile_connection_stats_.Clear();
  _impl_.headset_profile_connection_stats_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&_impl_.num_bluetooth_session_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.num_bonded_devices_) -
        reinterpret_cast<char*>(&_impl_.num_bluetooth_session_)) + sizeof(_impl_.num_bonded_devices_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* BluetoothLog::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .bluetooth.metrics.BluetoothMetricsProto.BluetoothSession session = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_session(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .bluetooth.metrics.BluetoothMetricsProto.PairEvent pair_event = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_pair_event(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .bluetooth.metrics.BluetoothMetricsProto.WakeEvent wake_event = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_wake_event(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .bluetooth.metrics.BluetoothMetricsProto.ScanEvent scan_event = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_scan_event(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 num_bonded_devices = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _Internal::set_has_num_bonded_devices(&has_bits);
          _impl_.num_bonded_devices_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int64 num_bluetooth_session = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
          _Internal::set_has_num_bluetooth_session(&has_bits);
          _impl_.num_bluetooth_session_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int64 num_pair_event = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 56)) {
          _Internal::set_has_num_pair_event(&has_bits);
          _impl_.num_pair_event_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int64 num_wake_event = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 64)) {
          _Internal::set_has_num_wake_event(&has_bits);
          _impl_.num_wake_event_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int64 num_scan_event = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 72)) {
          _Internal::set_has_num_scan_event(&has_bits);
          _impl_.num_scan_event_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .bluetooth.metrics.BluetoothMetricsProto.ProfileConnectionStats profile_connection_stats = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 82)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_profile_connection_stats(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<82>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .bluetooth.metrics.BluetoothMetricsProto.HeadsetProfileConnectionStats headset_profile_connection_stats = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 90)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_headset_profile_connection_stats(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<90>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* BluetoothLog::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:bluetooth.metrics.BluetoothMetricsProto.BluetoothLog)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .bluetooth.metrics.BluetoothMetricsProto.BluetoothSession session = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_session_size()); i < n; i++) {
    const auto& repfield = this->_internal_session(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .bluetooth.metrics.BluetoothMetricsProto.PairEvent pair_event = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_pair_event_size()); i < n; i++) {
    const auto& repfield = this->_internal_pair_event(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .bluetooth.metrics.BluetoothMetricsProto.WakeEvent wake_event = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_wake_event_size()); i < n; i++) {
    const auto& repfield = this->_internal_wake_event(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .bluetooth.metrics.BluetoothMetricsProto.ScanEvent scan_event = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_scan_event_size()); i < n; i++) {
    const auto& repfield = this->_internal_scan_event(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 num_bonded_devices = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_num_bonded_devices(), target);
  }

  // optional int64 num_bluetooth_session = 6;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(6, this->_internal_num_bluetooth_session(), target);
  }

  // optional int64 num_pair_event = 7;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(7, this->_internal_num_pair_event(), target);
  }

  // optional int64 num_wake_event = 8;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(8, this->_internal_num_wake_event(), target);
  }

  // optional int64 num_scan_event = 9;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(9, this->_internal_num_scan_event(), target);
  }

  // repeated .bluetooth.metrics.BluetoothMetricsProto.ProfileConnectionStats profile_connection_stats = 10;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_profile_connection_stats_size()); i < n; i++) {
    const auto& repfield = this->_internal_profile_connection_stats(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(10, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .bluetooth.metrics.BluetoothMetricsProto.HeadsetProfileConnectionStats headset_profile_connection_stats = 11;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_headset_profile_connection_stats_size()); i < n; i++) {
    const auto& repfield = this->_internal_headset_profile_connection_stats(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(11, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:bluetooth.metrics.BluetoothMetricsProto.BluetoothLog)
  return target;
}

size_t BluetoothLog::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:bluetooth.metrics.BluetoothMetricsProto.BluetoothLog)
  size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .bluetooth.metrics.BluetoothMetricsProto.BluetoothSession session = 1;
  total_size += 1UL * this->_internal_session_size();
  for (const auto& msg : this->_impl_.session_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .bluetooth.metrics.BluetoothMetricsProto.PairEvent pair_event = 2;
  total_size += 1UL * this->_internal_pair_event_size();
  for (const auto& msg : this->_impl_.pair_event_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .bluetooth.metrics.BluetoothMetricsProto.WakeEvent wake_event = 3;
  total_size += 1UL * this->_internal_wake_event_size();
  for (const auto& msg : this->_impl_.wake_event_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .bluetooth.metrics.BluetoothMetricsProto.ScanEvent scan_event = 4;
  total_size += 1UL * this->_internal_scan_event_size();
  for (const auto& msg : this->_impl_.scan_event_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .bluetooth.metrics.BluetoothMetricsProto.ProfileConnectionStats profile_connection_stats = 10;
  total_size += 1UL * this->_internal_profile_connection_stats_size();
  for (const auto& msg : this->_impl_.profile_connection_stats_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .bluetooth.metrics.BluetoothMetricsProto.HeadsetProfileConnectionStats headset_profile_connection_stats = 11;
  total_size += 1UL * this->_internal_headset_profile_connection_stats_size();
  for (const auto& msg : this->_impl_.headset_profile_connection_stats_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional int64 num_bluetooth_session = 6;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_num_bluetooth_session());
    }

    // optional int64 num_pair_event = 7;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_num_pair_event());
    }

    // optional int64 num_wake_event = 8;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_num_wake_event());
    }

    // optional int64 num_scan_event = 9;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_num_scan_event());
    }

    // optional int32 num_bonded_devices = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_num_bonded_devices());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void BluetoothLog::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const BluetoothLog*>(
      &from));
}

void BluetoothLog::MergeFrom(const BluetoothLog& from) {
  BluetoothLog* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:bluetooth.metrics.BluetoothMetricsProto.BluetoothLog)
  GOOGLE_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.session_.MergeFrom(from._impl_.session_);
  _this->_impl_.pair_event_.MergeFrom(from._impl_.pair_event_);
  _this->_impl_.wake_event_.MergeFrom(from._impl_.wake_event_);
  _this->_impl_.scan_event_.MergeFrom(from._impl_.scan_event_);
  _this->_impl_.profile_connection_stats_.MergeFrom(from._impl_.profile_connection_stats_);
  _this->_impl_.headset_profile_connection_stats_.MergeFrom(from._impl_.headset_profile_connection_stats_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.num_bluetooth_session_ = from._impl_.num_bluetooth_session_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.num_pair_event_ = from._impl_.num_pair_event_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.num_wake_event_ = from._impl_.num_wake_event_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.num_scan_event_ = from._impl_.num_scan_event_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.num_bonded_devices_ = from._impl_.num_bonded_devices_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void BluetoothLog::CopyFrom(const BluetoothLog& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:bluetooth.metrics.BluetoothMetricsProto.BluetoothLog)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BluetoothLog::IsInitialized() const {
  return true;
}

void BluetoothLog::InternalSwap(BluetoothLog* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.session_.InternalSwap(&other->_impl_.session_);
  _impl_.pair_event_.InternalSwap(&other->_impl_.pair_event_);
  _impl_.wake_event_.InternalSwap(&other->_impl_.wake_event_);
  _impl_.scan_event_.InternalSwap(&other->_impl_.scan_event_);
  _impl_.profile_connection_stats_.InternalSwap(&other->_impl_.profile_connection_stats_);
  _impl_.headset_profile_connection_stats_.InternalSwap(&other->_impl_.headset_profile_connection_stats_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BluetoothLog, _impl_.num_bonded_devices_)
      + sizeof(BluetoothLog::_impl_.num_bonded_devices_)  // NOLINT
      - PROTOBUF_FIELD_OFFSET(BluetoothLog, _impl_.num_bluetooth_session_)>(
          reinterpret_cast<char*>(&_impl_.num_bluetooth_session_),
          reinterpret_cast<char*>(&other->_impl_.num_bluetooth_session_));
}

std::string BluetoothLog::GetTypeName() const {
  return "bluetooth.metrics.BluetoothMetricsProto.BluetoothLog";
}


// ===================================================================

class DeviceInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<DeviceInfo>()._impl_._has_bits_);
  static void set_has_device_class(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_device_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

DeviceInfo::DeviceInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:bluetooth.metrics.BluetoothMetricsProto.DeviceInfo)
}
DeviceInfo::DeviceInfo(const DeviceInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DeviceInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.device_class_){}
    , decltype(_impl_.device_type_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.device_class_, &from._impl_.device_class_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.device_type_) -
    reinterpret_cast<char*>(&_impl_.device_class_)) + sizeof(_impl_.device_type_));
  // @@protoc_insertion_point(copy_constructor:bluetooth.metrics.BluetoothMetricsProto.DeviceInfo)
}

inline void DeviceInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.device_class_){0}
    , decltype(_impl_.device_type_){0}
  };
}

DeviceInfo::~DeviceInfo() {
  // @@protoc_insertion_point(destructor:bluetooth.metrics.BluetoothMetricsProto.DeviceInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeviceInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DeviceInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeviceInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:bluetooth.metrics.BluetoothMetricsProto.DeviceInfo)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.device_class_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.device_type_) -
        reinterpret_cast<char*>(&_impl_.device_class_)) + sizeof(_impl_.device_type_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DeviceInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 device_class = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_device_class(&has_bits);
          _impl_.device_class_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .bluetooth.metrics.BluetoothMetricsProto.DeviceInfo.DeviceType device_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          ::uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo_DeviceType_IsValid(val))) {
            _internal_set_device_type(static_cast<::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo_DeviceType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* DeviceInfo::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:bluetooth.metrics.BluetoothMetricsProto.DeviceInfo)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 device_class = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_device_class(), target);
  }

  // optional .bluetooth.metrics.BluetoothMetricsProto.DeviceInfo.DeviceType device_type = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_device_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:bluetooth.metrics.BluetoothMetricsProto.DeviceInfo)
  return target;
}

size_t DeviceInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:bluetooth.metrics.BluetoothMetricsProto.DeviceInfo)
  size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int32 device_class = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_device_class());
    }

    // optional .bluetooth.metrics.BluetoothMetricsProto.DeviceInfo.DeviceType device_type = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_device_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DeviceInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DeviceInfo*>(
      &from));
}

void DeviceInfo::MergeFrom(const DeviceInfo& from) {
  DeviceInfo* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:bluetooth.metrics.BluetoothMetricsProto.DeviceInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.device_class_ = from._impl_.device_class_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.device_type_ = from._impl_.device_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DeviceInfo::CopyFrom(const DeviceInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:bluetooth.metrics.BluetoothMetricsProto.DeviceInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceInfo::IsInitialized() const {
  return true;
}

void DeviceInfo::InternalSwap(DeviceInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DeviceInfo, _impl_.device_type_)
      + sizeof(DeviceInfo::_impl_.device_type_)  // NOLINT
      - PROTOBUF_FIELD_OFFSET(DeviceInfo, _impl_.device_class_)>(
          reinterpret_cast<char*>(&_impl_.device_class_),
          reinterpret_cast<char*>(&other->_impl_.device_class_));
}

std::string DeviceInfo::GetTypeName() const {
  return "bluetooth.metrics.BluetoothMetricsProto.DeviceInfo";
}


// ===================================================================

class BluetoothSession::_Internal {
 public:
  using HasBits = decltype(std::declval<BluetoothSession>()._impl_._has_bits_);
  static void set_has_session_duration_sec(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_connection_technology_type(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_disconnect_reason(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo& device_connected_to(const BluetoothSession* msg);
  static void set_has_device_connected_to(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::bluetooth::metrics::BluetoothMetricsProto::RFCommSession& rfcomm_session(const BluetoothSession* msg);
  static void set_has_rfcomm_session(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::bluetooth::metrics::BluetoothMetricsProto::A2DPSession& a2dp_session(const BluetoothSession* msg);
  static void set_has_a2dp_session(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_disconnect_reason_type(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

const ::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo&
BluetoothSession::_Internal::device_connected_to(const BluetoothSession* msg) {
  return *msg->_impl_.device_connected_to_;
}
const ::bluetooth::metrics::BluetoothMetricsProto::RFCommSession&
BluetoothSession::_Internal::rfcomm_session(const BluetoothSession* msg) {
  return *msg->_impl_.rfcomm_session_;
}
const ::bluetooth::metrics::BluetoothMetricsProto::A2DPSession&
BluetoothSession::_Internal::a2dp_session(const BluetoothSession* msg) {
  return *msg->_impl_.a2dp_session_;
}
BluetoothSession::BluetoothSession(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:bluetooth.metrics.BluetoothMetricsProto.BluetoothSession)
}
BluetoothSession::BluetoothSession(const BluetoothSession& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  BluetoothSession* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.disconnect_reason_){}
    , decltype(_impl_.device_connected_to_){nullptr}
    , decltype(_impl_.rfcomm_session_){nullptr}
    , decltype(_impl_.a2dp_session_){nullptr}
    , decltype(_impl_.session_duration_sec_){}
    , decltype(_impl_.connection_technology_type_){}
    , decltype(_impl_.disconnect_reason_type_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.disconnect_reason_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.disconnect_reason_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_disconnect_reason()) {
    _this->_impl_.disconnect_reason_.Set(from._internal_disconnect_reason(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_device_connected_to()) {
    _this->_impl_.device_connected_to_ = new ::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo(*from._impl_.device_connected_to_);
  }
  if (from._internal_has_rfcomm_session()) {
    _this->_impl_.rfcomm_session_ = new ::bluetooth::metrics::BluetoothMetricsProto::RFCommSession(*from._impl_.rfcomm_session_);
  }
  if (from._internal_has_a2dp_session()) {
    _this->_impl_.a2dp_session_ = new ::bluetooth::metrics::BluetoothMetricsProto::A2DPSession(*from._impl_.a2dp_session_);
  }
  ::memcpy(&_impl_.session_duration_sec_, &from._impl_.session_duration_sec_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.disconnect_reason_type_) -
    reinterpret_cast<char*>(&_impl_.session_duration_sec_)) + sizeof(_impl_.disconnect_reason_type_));
  // @@protoc_insertion_point(copy_constructor:bluetooth.metrics.BluetoothMetricsProto.BluetoothSession)
}

inline void BluetoothSession::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.disconnect_reason_){}
    , decltype(_impl_.device_connected_to_){nullptr}
    , decltype(_impl_.rfcomm_session_){nullptr}
    , decltype(_impl_.a2dp_session_){nullptr}
    , decltype(_impl_.session_duration_sec_){::int64_t{0}}
    , decltype(_impl_.connection_technology_type_){0}
    , decltype(_impl_.disconnect_reason_type_){0}
  };
  _impl_.disconnect_reason_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.disconnect_reason_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

BluetoothSession::~BluetoothSession() {
  // @@protoc_insertion_point(destructor:bluetooth.metrics.BluetoothMetricsProto.BluetoothSession)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BluetoothSession::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.disconnect_reason_.Destroy();
  if (this != internal_default_instance()) delete _impl_.device_connected_to_;
  if (this != internal_default_instance()) delete _impl_.rfcomm_session_;
  if (this != internal_default_instance()) delete _impl_.a2dp_session_;
}

void BluetoothSession::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BluetoothSession::Clear() {
// @@protoc_insertion_point(message_clear_start:bluetooth.metrics.BluetoothMetricsProto.BluetoothSession)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.disconnect_reason_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.device_connected_to_ != nullptr);
      _impl_.device_connected_to_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.rfcomm_session_ != nullptr);
      _impl_.rfcomm_session_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.a2dp_session_ != nullptr);
      _impl_.a2dp_session_->Clear();
    }
  }
  if (cached_has_bits & 0x00000070u) {
    ::memset(&_impl_.session_duration_sec_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.disconnect_reason_type_) -
        reinterpret_cast<char*>(&_impl_.session_duration_sec_)) + sizeof(_impl_.disconnect_reason_type_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* BluetoothSession::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 session_duration_sec = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_session_duration_sec(&has_bits);
          _impl_.session_duration_sec_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .bluetooth.metrics.BluetoothMetricsProto.BluetoothSession.ConnectionTechnologyType connection_technology_type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          ::uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::bluetooth::metrics::BluetoothMetricsProto::BluetoothSession_ConnectionTechnologyType_IsValid(val))) {
            _internal_set_connection_technology_type(static_cast<::bluetooth::metrics::BluetoothMetricsProto::BluetoothSession_ConnectionTechnologyType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string disconnect_reason = 4 [deprecated = true];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_disconnect_reason();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .bluetooth.metrics.BluetoothMetricsProto.DeviceInfo device_connected_to = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_device_connected_to(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .bluetooth.metrics.BluetoothMetricsProto.RFCommSession rfcomm_session = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_rfcomm_session(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .bluetooth.metrics.BluetoothMetricsProto.A2DPSession a2dp_session = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_a2dp_session(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .bluetooth.metrics.BluetoothMetricsProto.BluetoothSession.DisconnectReasonType disconnect_reason_type = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 64)) {
          ::uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::bluetooth::metrics::BluetoothMetricsProto::BluetoothSession_DisconnectReasonType_IsValid(val))) {
            _internal_set_disconnect_reason_type(static_cast<::bluetooth::metrics::BluetoothMetricsProto::BluetoothSession_DisconnectReasonType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(8, val, mutable_unknown_fields());
          }
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* BluetoothSession::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:bluetooth.metrics.BluetoothMetricsProto.BluetoothSession)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int64 session_duration_sec = 2;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_session_duration_sec(), target);
  }

  // optional .bluetooth.metrics.BluetoothMetricsProto.BluetoothSession.ConnectionTechnologyType connection_technology_type = 3;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_connection_technology_type(), target);
  }

  // optional string disconnect_reason = 4 [deprecated = true];
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_disconnect_reason(), target);
  }

  // optional .bluetooth.metrics.BluetoothMetricsProto.DeviceInfo device_connected_to = 5;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::device_connected_to(this),
        _Internal::device_connected_to(this).GetCachedSize(), target, stream);
  }

  // optional .bluetooth.metrics.BluetoothMetricsProto.RFCommSession rfcomm_session = 6;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::rfcomm_session(this),
        _Internal::rfcomm_session(this).GetCachedSize(), target, stream);
  }

  // optional .bluetooth.metrics.BluetoothMetricsProto.A2DPSession a2dp_session = 7;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::a2dp_session(this),
        _Internal::a2dp_session(this).GetCachedSize(), target, stream);
  }

  // optional .bluetooth.metrics.BluetoothMetricsProto.BluetoothSession.DisconnectReasonType disconnect_reason_type = 8;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      8, this->_internal_disconnect_reason_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:bluetooth.metrics.BluetoothMetricsProto.BluetoothSession)
  return target;
}

size_t BluetoothSession::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:bluetooth.metrics.BluetoothMetricsProto.BluetoothSession)
  size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional string disconnect_reason = 4 [deprecated = true];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_disconnect_reason());
    }

    // optional .bluetooth.metrics.BluetoothMetricsProto.DeviceInfo device_connected_to = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.device_connected_to_);
    }

    // optional .bluetooth.metrics.BluetoothMetricsProto.RFCommSession rfcomm_session = 6;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.rfcomm_session_);
    }

    // optional .bluetooth.metrics.BluetoothMetricsProto.A2DPSession a2dp_session = 7;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.a2dp_session_);
    }

    // optional int64 session_duration_sec = 2;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_session_duration_sec());
    }

    // optional .bluetooth.metrics.BluetoothMetricsProto.BluetoothSession.ConnectionTechnologyType connection_technology_type = 3;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_connection_technology_type());
    }

    // optional .bluetooth.metrics.BluetoothMetricsProto.BluetoothSession.DisconnectReasonType disconnect_reason_type = 8;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_disconnect_reason_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void BluetoothSession::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const BluetoothSession*>(
      &from));
}

void BluetoothSession::MergeFrom(const BluetoothSession& from) {
  BluetoothSession* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:bluetooth.metrics.BluetoothMetricsProto.BluetoothSession)
  GOOGLE_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_disconnect_reason(from._internal_disconnect_reason());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_device_connected_to()->::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo::MergeFrom(
          from._internal_device_connected_to());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_rfcomm_session()->::bluetooth::metrics::BluetoothMetricsProto::RFCommSession::MergeFrom(
          from._internal_rfcomm_session());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_a2dp_session()->::bluetooth::metrics::BluetoothMetricsProto::A2DPSession::MergeFrom(
          from._internal_a2dp_session());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.session_duration_sec_ = from._impl_.session_duration_sec_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.connection_technology_type_ = from._impl_.connection_technology_type_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.disconnect_reason_type_ = from._impl_.disconnect_reason_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void BluetoothSession::CopyFrom(const BluetoothSession& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:bluetooth.metrics.BluetoothMetricsProto.BluetoothSession)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BluetoothSession::IsInitialized() const {
  return true;
}

void BluetoothSession::InternalSwap(BluetoothSession* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.disconnect_reason_, lhs_arena,
      &other->_impl_.disconnect_reason_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BluetoothSession, _impl_.disconnect_reason_type_)
      + sizeof(BluetoothSession::_impl_.disconnect_reason_type_)  // NOLINT
      - PROTOBUF_FIELD_OFFSET(BluetoothSession, _impl_.device_connected_to_)>(
          reinterpret_cast<char*>(&_impl_.device_connected_to_),
          reinterpret_cast<char*>(&other->_impl_.device_connected_to_));
}

std::string BluetoothSession::GetTypeName() const {
  return "bluetooth.metrics.BluetoothMetricsProto.BluetoothSession";
}


// ===================================================================

class RFCommSession::_Internal {
 public:
  using HasBits = decltype(std::declval<RFCommSession>()._impl_._has_bits_);
  static void set_has_rx_bytes(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_tx_bytes(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

RFCommSession::RFCommSession(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:bluetooth.metrics.BluetoothMetricsProto.RFCommSession)
}
RFCommSession::RFCommSession(const RFCommSession& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  RFCommSession* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.rx_bytes_){}
    , decltype(_impl_.tx_bytes_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.rx_bytes_, &from._impl_.rx_bytes_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.tx_bytes_) -
    reinterpret_cast<char*>(&_impl_.rx_bytes_)) + sizeof(_impl_.tx_bytes_));
  // @@protoc_insertion_point(copy_constructor:bluetooth.metrics.BluetoothMetricsProto.RFCommSession)
}

inline void RFCommSession::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.rx_bytes_){0}
    , decltype(_impl_.tx_bytes_){0}
  };
}

RFCommSession::~RFCommSession() {
  // @@protoc_insertion_point(destructor:bluetooth.metrics.BluetoothMetricsProto.RFCommSession)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RFCommSession::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void RFCommSession::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RFCommSession::Clear() {
// @@protoc_insertion_point(message_clear_start:bluetooth.metrics.BluetoothMetricsProto.RFCommSession)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.rx_bytes_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.tx_bytes_) -
        reinterpret_cast<char*>(&_impl_.rx_bytes_)) + sizeof(_impl_.tx_bytes_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* RFCommSession::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 rx_bytes = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_rx_bytes(&has_bits);
          _impl_.rx_bytes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 tx_bytes = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_tx_bytes(&has_bits);
          _impl_.tx_bytes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* RFCommSession::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:bluetooth.metrics.BluetoothMetricsProto.RFCommSession)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 rx_bytes = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_rx_bytes(), target);
  }

  // optional int32 tx_bytes = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_tx_bytes(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:bluetooth.metrics.BluetoothMetricsProto.RFCommSession)
  return target;
}

size_t RFCommSession::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:bluetooth.metrics.BluetoothMetricsProto.RFCommSession)
  size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int32 rx_bytes = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_rx_bytes());
    }

    // optional int32 tx_bytes = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_tx_bytes());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RFCommSession::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const RFCommSession*>(
      &from));
}

void RFCommSession::MergeFrom(const RFCommSession& from) {
  RFCommSession* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:bluetooth.metrics.BluetoothMetricsProto.RFCommSession)
  GOOGLE_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.rx_bytes_ = from._impl_.rx_bytes_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.tx_bytes_ = from._impl_.tx_bytes_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void RFCommSession::CopyFrom(const RFCommSession& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:bluetooth.metrics.BluetoothMetricsProto.RFCommSession)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RFCommSession::IsInitialized() const {
  return true;
}

void RFCommSession::InternalSwap(RFCommSession* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RFCommSession, _impl_.tx_bytes_)
      + sizeof(RFCommSession::_impl_.tx_bytes_)  // NOLINT
      - PROTOBUF_FIELD_OFFSET(RFCommSession, _impl_.rx_bytes_)>(
          reinterpret_cast<char*>(&_impl_.rx_bytes_),
          reinterpret_cast<char*>(&other->_impl_.rx_bytes_));
}

std::string RFCommSession::GetTypeName() const {
  return "bluetooth.metrics.BluetoothMetricsProto.RFCommSession";
}


// ===================================================================

class A2DPSession::_Internal {
 public:
  using HasBits = decltype(std::declval<A2DPSession>()._impl_._has_bits_);
  static void set_has_media_timer_min_millis(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_media_timer_max_millis(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_media_timer_avg_millis(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_buffer_overruns_max_count(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_buffer_overruns_total(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_buffer_underruns_average(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_buffer_underruns_count(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_audio_duration_millis(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_source_codec(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_is_a2dp_offload(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
};

A2DPSession::A2DPSession(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:bluetooth.metrics.BluetoothMetricsProto.A2DPSession)
}
A2DPSession::A2DPSession(const A2DPSession& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  A2DPSession* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.media_timer_min_millis_){}
    , decltype(_impl_.media_timer_max_millis_){}
    , decltype(_impl_.media_timer_avg_millis_){}
    , decltype(_impl_.buffer_overruns_max_count_){}
    , decltype(_impl_.buffer_overruns_total_){}
    , decltype(_impl_.buffer_underruns_average_){}
    , decltype(_impl_.audio_duration_millis_){}
    , decltype(_impl_.buffer_underruns_count_){}
    , decltype(_impl_.source_codec_){}
    , decltype(_impl_.is_a2dp_offload_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.media_timer_min_millis_, &from._impl_.media_timer_min_millis_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.is_a2dp_offload_) -
    reinterpret_cast<char*>(&_impl_.media_timer_min_millis_)) + sizeof(_impl_.is_a2dp_offload_));
  // @@protoc_insertion_point(copy_constructor:bluetooth.metrics.BluetoothMetricsProto.A2DPSession)
}

inline void A2DPSession::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.media_timer_min_millis_){0}
    , decltype(_impl_.media_timer_max_millis_){0}
    , decltype(_impl_.media_timer_avg_millis_){0}
    , decltype(_impl_.buffer_overruns_max_count_){0}
    , decltype(_impl_.buffer_overruns_total_){0}
    , decltype(_impl_.buffer_underruns_average_){0}
    , decltype(_impl_.audio_duration_millis_){::int64_t{0}}
    , decltype(_impl_.buffer_underruns_count_){0}
    , decltype(_impl_.source_codec_){0}
    , decltype(_impl_.is_a2dp_offload_){false}
  };
}

A2DPSession::~A2DPSession() {
  // @@protoc_insertion_point(destructor:bluetooth.metrics.BluetoothMetricsProto.A2DPSession)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void A2DPSession::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void A2DPSession::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void A2DPSession::Clear() {
// @@protoc_insertion_point(message_clear_start:bluetooth.metrics.BluetoothMetricsProto.A2DPSession)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.media_timer_min_millis_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.buffer_underruns_count_) -
        reinterpret_cast<char*>(&_impl_.media_timer_min_millis_)) + sizeof(_impl_.buffer_underruns_count_));
  }
  if (cached_has_bits & 0x00000300u) {
    ::memset(&_impl_.source_codec_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.is_a2dp_offload_) -
        reinterpret_cast<char*>(&_impl_.source_codec_)) + sizeof(_impl_.is_a2dp_offload_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* A2DPSession::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 media_timer_min_millis = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_media_timer_min_millis(&has_bits);
          _impl_.media_timer_min_millis_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 media_timer_max_millis = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_media_timer_max_millis(&has_bits);
          _impl_.media_timer_max_millis_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 media_timer_avg_millis = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_media_timer_avg_millis(&has_bits);
          _impl_.media_timer_avg_millis_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 buffer_overruns_max_count = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_buffer_overruns_max_count(&has_bits);
          _impl_.buffer_overruns_max_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 buffer_overruns_total = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _Internal::set_has_buffer_overruns_total(&has_bits);
          _impl_.buffer_overruns_total_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional float buffer_underruns_average = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 53)) {
          _Internal::set_has_buffer_underruns_average(&has_bits);
          _impl_.buffer_underruns_average_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 buffer_underruns_count = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 56)) {
          _Internal::set_has_buffer_underruns_count(&has_bits);
          _impl_.buffer_underruns_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int64 audio_duration_millis = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 64)) {
          _Internal::set_has_audio_duration_millis(&has_bits);
          _impl_.audio_duration_millis_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .bluetooth.metrics.BluetoothMetricsProto.A2dpSourceCodec source_codec = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 72)) {
          ::uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::bluetooth::metrics::BluetoothMetricsProto::A2dpSourceCodec_IsValid(val))) {
            _internal_set_source_codec(static_cast<::bluetooth::metrics::BluetoothMetricsProto::A2dpSourceCodec>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(9, val, mutable_unknown_fields());
          }
        } else {
          goto handle_unusual;
        }
        continue;
      // optional bool is_a2dp_offload = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 80)) {
          _Internal::set_has_is_a2dp_offload(&has_bits);
          _impl_.is_a2dp_offload_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* A2DPSession::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:bluetooth.metrics.BluetoothMetricsProto.A2DPSession)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 media_timer_min_millis = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_media_timer_min_millis(), target);
  }

  // optional int32 media_timer_max_millis = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_media_timer_max_millis(), target);
  }

  // optional int32 media_timer_avg_millis = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_media_timer_avg_millis(), target);
  }

  // optional int32 buffer_overruns_max_count = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_buffer_overruns_max_count(), target);
  }

  // optional int32 buffer_overruns_total = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_buffer_overruns_total(), target);
  }

  // optional float buffer_underruns_average = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(6, this->_internal_buffer_underruns_average(), target);
  }

  // optional int32 buffer_underruns_count = 7;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(7, this->_internal_buffer_underruns_count(), target);
  }

  // optional int64 audio_duration_millis = 8;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(8, this->_internal_audio_duration_millis(), target);
  }

  // optional .bluetooth.metrics.BluetoothMetricsProto.A2dpSourceCodec source_codec = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      9, this->_internal_source_codec(), target);
  }

  // optional bool is_a2dp_offload = 10;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(10, this->_internal_is_a2dp_offload(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:bluetooth.metrics.BluetoothMetricsProto.A2DPSession)
  return target;
}

size_t A2DPSession::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:bluetooth.metrics.BluetoothMetricsProto.A2DPSession)
  size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional int32 media_timer_min_millis = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_media_timer_min_millis());
    }

    // optional int32 media_timer_max_millis = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_media_timer_max_millis());
    }

    // optional int32 media_timer_avg_millis = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_media_timer_avg_millis());
    }

    // optional int32 buffer_overruns_max_count = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_buffer_overruns_max_count());
    }

    // optional int32 buffer_overruns_total = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_buffer_overruns_total());
    }

    // optional float buffer_underruns_average = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 4;
    }

    // optional int64 audio_duration_millis = 8;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_audio_duration_millis());
    }

    // optional int32 buffer_underruns_count = 7;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_buffer_underruns_count());
    }

  }
  if (cached_has_bits & 0x00000300u) {
    // optional .bluetooth.metrics.BluetoothMetricsProto.A2dpSourceCodec source_codec = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_source_codec());
    }

    // optional bool is_a2dp_offload = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void A2DPSession::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const A2DPSession*>(
      &from));
}

void A2DPSession::MergeFrom(const A2DPSession& from) {
  A2DPSession* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:bluetooth.metrics.BluetoothMetricsProto.A2DPSession)
  GOOGLE_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.media_timer_min_millis_ = from._impl_.media_timer_min_millis_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.media_timer_max_millis_ = from._impl_.media_timer_max_millis_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.media_timer_avg_millis_ = from._impl_.media_timer_avg_millis_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.buffer_overruns_max_count_ = from._impl_.buffer_overruns_max_count_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.buffer_overruns_total_ = from._impl_.buffer_overruns_total_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.buffer_underruns_average_ = from._impl_.buffer_underruns_average_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.audio_duration_millis_ = from._impl_.audio_duration_millis_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.buffer_underruns_count_ = from._impl_.buffer_underruns_count_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.source_codec_ = from._impl_.source_codec_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.is_a2dp_offload_ = from._impl_.is_a2dp_offload_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void A2DPSession::CopyFrom(const A2DPSession& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:bluetooth.metrics.BluetoothMetricsProto.A2DPSession)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool A2DPSession::IsInitialized() const {
  return true;
}

void A2DPSession::InternalSwap(A2DPSession* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(A2DPSession, _impl_.is_a2dp_offload_)
      + sizeof(A2DPSession::_impl_.is_a2dp_offload_)  // NOLINT
      - PROTOBUF_FIELD_OFFSET(A2DPSession, _impl_.media_timer_min_millis_)>(
          reinterpret_cast<char*>(&_impl_.media_timer_min_millis_),
          reinterpret_cast<char*>(&other->_impl_.media_timer_min_millis_));
}

std::string A2DPSession::GetTypeName() const {
  return "bluetooth.metrics.BluetoothMetricsProto.A2DPSession";
}


// ===================================================================

class PairEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<PairEvent>()._impl_._has_bits_);
  static void set_has_disconnect_reason(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_event_time_millis(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo& device_paired_with(const PairEvent* msg);
  static void set_has_device_paired_with(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo&
PairEvent::_Internal::device_paired_with(const PairEvent* msg) {
  return *msg->_impl_.device_paired_with_;
}
PairEvent::PairEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:bluetooth.metrics.BluetoothMetricsProto.PairEvent)
}
PairEvent::PairEvent(const PairEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  PairEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.device_paired_with_){nullptr}
    , decltype(_impl_.event_time_millis_){}
    , decltype(_impl_.disconnect_reason_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_device_paired_with()) {
    _this->_impl_.device_paired_with_ = new ::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo(*from._impl_.device_paired_with_);
  }
  ::memcpy(&_impl_.event_time_millis_, &from._impl_.event_time_millis_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.disconnect_reason_) -
    reinterpret_cast<char*>(&_impl_.event_time_millis_)) + sizeof(_impl_.disconnect_reason_));
  // @@protoc_insertion_point(copy_constructor:bluetooth.metrics.BluetoothMetricsProto.PairEvent)
}

inline void PairEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.device_paired_with_){nullptr}
    , decltype(_impl_.event_time_millis_){::int64_t{0}}
    , decltype(_impl_.disconnect_reason_){0}
  };
}

PairEvent::~PairEvent() {
  // @@protoc_insertion_point(destructor:bluetooth.metrics.BluetoothMetricsProto.PairEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PairEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.device_paired_with_;
}

void PairEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PairEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:bluetooth.metrics.BluetoothMetricsProto.PairEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.device_paired_with_ != nullptr);
    _impl_.device_paired_with_->Clear();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.event_time_millis_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.disconnect_reason_) -
        reinterpret_cast<char*>(&_impl_.event_time_millis_)) + sizeof(_impl_.disconnect_reason_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* PairEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 disconnect_reason = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_disconnect_reason(&has_bits);
          _impl_.disconnect_reason_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int64 event_time_millis = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_event_time_millis(&has_bits);
          _impl_.event_time_millis_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .bluetooth.metrics.BluetoothMetricsProto.DeviceInfo device_paired_with = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_device_paired_with(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* PairEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:bluetooth.metrics.BluetoothMetricsProto.PairEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 disconnect_reason = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_disconnect_reason(), target);
  }

  // optional int64 event_time_millis = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_event_time_millis(), target);
  }

  // optional .bluetooth.metrics.BluetoothMetricsProto.DeviceInfo device_paired_with = 3;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::device_paired_with(this),
        _Internal::device_paired_with(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:bluetooth.metrics.BluetoothMetricsProto.PairEvent)
  return target;
}

size_t PairEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:bluetooth.metrics.BluetoothMetricsProto.PairEvent)
  size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .bluetooth.metrics.BluetoothMetricsProto.DeviceInfo device_paired_with = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.device_paired_with_);
    }

    // optional int64 event_time_millis = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_event_time_millis());
    }

    // optional int32 disconnect_reason = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_disconnect_reason());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PairEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const PairEvent*>(
      &from));
}

void PairEvent::MergeFrom(const PairEvent& from) {
  PairEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:bluetooth.metrics.BluetoothMetricsProto.PairEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_device_paired_with()->::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo::MergeFrom(
          from._internal_device_paired_with());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.event_time_millis_ = from._impl_.event_time_millis_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.disconnect_reason_ = from._impl_.disconnect_reason_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PairEvent::CopyFrom(const PairEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:bluetooth.metrics.BluetoothMetricsProto.PairEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PairEvent::IsInitialized() const {
  return true;
}

void PairEvent::InternalSwap(PairEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PairEvent, _impl_.disconnect_reason_)
      + sizeof(PairEvent::_impl_.disconnect_reason_)  // NOLINT
      - PROTOBUF_FIELD_OFFSET(PairEvent, _impl_.device_paired_with_)>(
          reinterpret_cast<char*>(&_impl_.device_paired_with_),
          reinterpret_cast<char*>(&other->_impl_.device_paired_with_));
}

std::string PairEvent::GetTypeName() const {
  return "bluetooth.metrics.BluetoothMetricsProto.PairEvent";
}


// ===================================================================

class WakeEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<WakeEvent>()._impl_._has_bits_);
  static void set_has_wake_event_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_requestor(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_event_time_millis(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

WakeEvent::WakeEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:bluetooth.metrics.BluetoothMetricsProto.WakeEvent)
}
WakeEvent::WakeEvent(const WakeEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  WakeEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.requestor_){}
    , decltype(_impl_.name_){}
    , decltype(_impl_.event_time_millis_){}
    , decltype(_impl_.wake_event_type_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.requestor_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.requestor_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_requestor()) {
    _this->_impl_.requestor_.Set(from._internal_requestor(), 
      _this->GetArenaForAllocation());
  }
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.event_time_millis_, &from._impl_.event_time_millis_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.wake_event_type_) -
    reinterpret_cast<char*>(&_impl_.event_time_millis_)) + sizeof(_impl_.wake_event_type_));
  // @@protoc_insertion_point(copy_constructor:bluetooth.metrics.BluetoothMetricsProto.WakeEvent)
}

inline void WakeEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.requestor_){}
    , decltype(_impl_.name_){}
    , decltype(_impl_.event_time_millis_){::int64_t{0}}
    , decltype(_impl_.wake_event_type_){0}
  };
  _impl_.requestor_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.requestor_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

WakeEvent::~WakeEvent() {
  // @@protoc_insertion_point(destructor:bluetooth.metrics.BluetoothMetricsProto.WakeEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void WakeEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.requestor_.Destroy();
  _impl_.name_.Destroy();
}

void WakeEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void WakeEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:bluetooth.metrics.BluetoothMetricsProto.WakeEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.requestor_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&_impl_.event_time_millis_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.wake_event_type_) -
        reinterpret_cast<char*>(&_impl_.event_time_millis_)) + sizeof(_impl_.wake_event_type_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* WakeEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .bluetooth.metrics.BluetoothMetricsProto.WakeEvent.WakeEventType wake_event_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          ::uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::bluetooth::metrics::BluetoothMetricsProto::WakeEvent_WakeEventType_IsValid(val))) {
            _internal_set_wake_event_type(static_cast<::bluetooth::metrics::BluetoothMetricsProto::WakeEvent_WakeEventType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string requestor = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_requestor();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int64 event_time_millis = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_event_time_millis(&has_bits);
          _impl_.event_time_millis_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* WakeEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:bluetooth.metrics.BluetoothMetricsProto.WakeEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .bluetooth.metrics.BluetoothMetricsProto.WakeEvent.WakeEventType wake_event_type = 1;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_wake_event_type(), target);
  }

  // optional string requestor = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_requestor(), target);
  }

  // optional string name = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_name(), target);
  }

  // optional int64 event_time_millis = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(4, this->_internal_event_time_millis(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:bluetooth.metrics.BluetoothMetricsProto.WakeEvent)
  return target;
}

size_t WakeEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:bluetooth.metrics.BluetoothMetricsProto.WakeEvent)
  size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string requestor = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_requestor());
    }

    // optional string name = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional int64 event_time_millis = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_event_time_millis());
    }

    // optional .bluetooth.metrics.BluetoothMetricsProto.WakeEvent.WakeEventType wake_event_type = 1;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_wake_event_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void WakeEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const WakeEvent*>(
      &from));
}

void WakeEvent::MergeFrom(const WakeEvent& from) {
  WakeEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:bluetooth.metrics.BluetoothMetricsProto.WakeEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_requestor(from._internal_requestor());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.event_time_millis_ = from._impl_.event_time_millis_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.wake_event_type_ = from._impl_.wake_event_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void WakeEvent::CopyFrom(const WakeEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:bluetooth.metrics.BluetoothMetricsProto.WakeEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WakeEvent::IsInitialized() const {
  return true;
}

void WakeEvent::InternalSwap(WakeEvent* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.requestor_, lhs_arena,
      &other->_impl_.requestor_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(WakeEvent, _impl_.wake_event_type_)
      + sizeof(WakeEvent::_impl_.wake_event_type_)  // NOLINT
      - PROTOBUF_FIELD_OFFSET(WakeEvent, _impl_.event_time_millis_)>(
          reinterpret_cast<char*>(&_impl_.event_time_millis_),
          reinterpret_cast<char*>(&other->_impl_.event_time_millis_));
}

std::string WakeEvent::GetTypeName() const {
  return "bluetooth.metrics.BluetoothMetricsProto.WakeEvent";
}


// ===================================================================

class ScanEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<ScanEvent>()._impl_._has_bits_);
  static void set_has_scan_event_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_initiator(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_scan_technology_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_number_results(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_event_time_millis(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

ScanEvent::ScanEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:bluetooth.metrics.BluetoothMetricsProto.ScanEvent)
}
ScanEvent::ScanEvent(const ScanEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ScanEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.initiator_){}
    , decltype(_impl_.scan_event_type_){}
    , decltype(_impl_.scan_technology_type_){}
    , decltype(_impl_.event_time_millis_){}
    , decltype(_impl_.number_results_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.initiator_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.initiator_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_initiator()) {
    _this->_impl_.initiator_.Set(from._internal_initiator(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.scan_event_type_, &from._impl_.scan_event_type_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.number_results_) -
    reinterpret_cast<char*>(&_impl_.scan_event_type_)) + sizeof(_impl_.number_results_));
  // @@protoc_insertion_point(copy_constructor:bluetooth.metrics.BluetoothMetricsProto.ScanEvent)
}

inline void ScanEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.initiator_){}
    , decltype(_impl_.scan_event_type_){0}
    , decltype(_impl_.scan_technology_type_){0}
    , decltype(_impl_.event_time_millis_){::int64_t{0}}
    , decltype(_impl_.number_results_){0}
  };
  _impl_.initiator_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.initiator_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ScanEvent::~ScanEvent() {
  // @@protoc_insertion_point(destructor:bluetooth.metrics.BluetoothMetricsProto.ScanEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ScanEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.initiator_.Destroy();
}

void ScanEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ScanEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:bluetooth.metrics.BluetoothMetricsProto.ScanEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.initiator_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000001eu) {
    ::memset(&_impl_.scan_event_type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.number_results_) -
        reinterpret_cast<char*>(&_impl_.scan_event_type_)) + sizeof(_impl_.number_results_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ScanEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .bluetooth.metrics.BluetoothMetricsProto.ScanEvent.ScanEventType scan_event_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          ::uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::bluetooth::metrics::BluetoothMetricsProto::ScanEvent_ScanEventType_IsValid(val))) {
            _internal_set_scan_event_type(static_cast<::bluetooth::metrics::BluetoothMetricsProto::ScanEvent_ScanEventType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string initiator = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_initiator();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .bluetooth.metrics.BluetoothMetricsProto.ScanEvent.ScanTechnologyType scan_technology_type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          ::uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::bluetooth::metrics::BluetoothMetricsProto::ScanEvent_ScanTechnologyType_IsValid(val))) {
            _internal_set_scan_technology_type(static_cast<::bluetooth::metrics::BluetoothMetricsProto::ScanEvent_ScanTechnologyType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 number_results = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_number_results(&has_bits);
          _impl_.number_results_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int64 event_time_millis = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _Internal::set_has_event_time_millis(&has_bits);
          _impl_.event_time_millis_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* ScanEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:bluetooth.metrics.BluetoothMetricsProto.ScanEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .bluetooth.metrics.BluetoothMetricsProto.ScanEvent.ScanEventType scan_event_type = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_scan_event_type(), target);
  }

  // optional string initiator = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_initiator(), target);
  }

  // optional .bluetooth.metrics.BluetoothMetricsProto.ScanEvent.ScanTechnologyType scan_technology_type = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_scan_technology_type(), target);
  }

  // optional int32 number_results = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_number_results(), target);
  }

  // optional int64 event_time_millis = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(5, this->_internal_event_time_millis(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:bluetooth.metrics.BluetoothMetricsProto.ScanEvent)
  return target;
}

size_t ScanEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:bluetooth.metrics.BluetoothMetricsProto.ScanEvent)
  size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string initiator = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_initiator());
    }

    // optional .bluetooth.metrics.BluetoothMetricsProto.ScanEvent.ScanEventType scan_event_type = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_scan_event_type());
    }

    // optional .bluetooth.metrics.BluetoothMetricsProto.ScanEvent.ScanTechnologyType scan_technology_type = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_scan_technology_type());
    }

    // optional int64 event_time_millis = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_event_time_millis());
    }

    // optional int32 number_results = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_number_results());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ScanEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ScanEvent*>(
      &from));
}

void ScanEvent::MergeFrom(const ScanEvent& from) {
  ScanEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:bluetooth.metrics.BluetoothMetricsProto.ScanEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_initiator(from._internal_initiator());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.scan_event_type_ = from._impl_.scan_event_type_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.scan_technology_type_ = from._impl_.scan_technology_type_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.event_time_millis_ = from._impl_.event_time_millis_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.number_results_ = from._impl_.number_results_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ScanEvent::CopyFrom(const ScanEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:bluetooth.metrics.BluetoothMetricsProto.ScanEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ScanEvent::IsInitialized() const {
  return true;
}

void ScanEvent::InternalSwap(ScanEvent* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.initiator_, lhs_arena,
      &other->_impl_.initiator_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ScanEvent, _impl_.number_results_)
      + sizeof(ScanEvent::_impl_.number_results_)  // NOLINT
      - PROTOBUF_FIELD_OFFSET(ScanEvent, _impl_.scan_event_type_)>(
          reinterpret_cast<char*>(&_impl_.scan_event_type_),
          reinterpret_cast<char*>(&other->_impl_.scan_event_type_));
}

std::string ScanEvent::GetTypeName() const {
  return "bluetooth.metrics.BluetoothMetricsProto.ScanEvent";
}


// ===================================================================

class ProfileConnectionStats::_Internal {
 public:
  using HasBits = decltype(std::declval<ProfileConnectionStats>()._impl_._has_bits_);
  static void set_has_profile_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_num_times_connected(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

ProfileConnectionStats::ProfileConnectionStats(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:bluetooth.metrics.BluetoothMetricsProto.ProfileConnectionStats)
}
ProfileConnectionStats::ProfileConnectionStats(const ProfileConnectionStats& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ProfileConnectionStats* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.profile_id_){}
    , decltype(_impl_.num_times_connected_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.profile_id_, &from._impl_.profile_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.num_times_connected_) -
    reinterpret_cast<char*>(&_impl_.profile_id_)) + sizeof(_impl_.num_times_connected_));
  // @@protoc_insertion_point(copy_constructor:bluetooth.metrics.BluetoothMetricsProto.ProfileConnectionStats)
}

inline void ProfileConnectionStats::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.profile_id_){0}
    , decltype(_impl_.num_times_connected_){0}
  };
}

ProfileConnectionStats::~ProfileConnectionStats() {
  // @@protoc_insertion_point(destructor:bluetooth.metrics.BluetoothMetricsProto.ProfileConnectionStats)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ProfileConnectionStats::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ProfileConnectionStats::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ProfileConnectionStats::Clear() {
// @@protoc_insertion_point(message_clear_start:bluetooth.metrics.BluetoothMetricsProto.ProfileConnectionStats)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.profile_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.num_times_connected_) -
        reinterpret_cast<char*>(&_impl_.profile_id_)) + sizeof(_impl_.num_times_connected_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ProfileConnectionStats::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .bluetooth.metrics.BluetoothMetricsProto.ProfileId profile_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          ::uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::bluetooth::metrics::BluetoothMetricsProto::ProfileId_IsValid(val))) {
            _internal_set_profile_id(static_cast<::bluetooth::metrics::BluetoothMetricsProto::ProfileId>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 num_times_connected = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_num_times_connected(&has_bits);
          _impl_.num_times_connected_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* ProfileConnectionStats::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:bluetooth.metrics.BluetoothMetricsProto.ProfileConnectionStats)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .bluetooth.metrics.BluetoothMetricsProto.ProfileId profile_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_profile_id(), target);
  }

  // optional int32 num_times_connected = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_num_times_connected(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:bluetooth.metrics.BluetoothMetricsProto.ProfileConnectionStats)
  return target;
}

size_t ProfileConnectionStats::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:bluetooth.metrics.BluetoothMetricsProto.ProfileConnectionStats)
  size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .bluetooth.metrics.BluetoothMetricsProto.ProfileId profile_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_profile_id());
    }

    // optional int32 num_times_connected = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_num_times_connected());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ProfileConnectionStats::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ProfileConnectionStats*>(
      &from));
}

void ProfileConnectionStats::MergeFrom(const ProfileConnectionStats& from) {
  ProfileConnectionStats* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:bluetooth.metrics.BluetoothMetricsProto.ProfileConnectionStats)
  GOOGLE_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.profile_id_ = from._impl_.profile_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.num_times_connected_ = from._impl_.num_times_connected_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ProfileConnectionStats::CopyFrom(const ProfileConnectionStats& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:bluetooth.metrics.BluetoothMetricsProto.ProfileConnectionStats)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ProfileConnectionStats::IsInitialized() const {
  return true;
}

void ProfileConnectionStats::InternalSwap(ProfileConnectionStats* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ProfileConnectionStats, _impl_.num_times_connected_)
      + sizeof(ProfileConnectionStats::_impl_.num_times_connected_)  // NOLINT
      - PROTOBUF_FIELD_OFFSET(ProfileConnectionStats, _impl_.profile_id_)>(
          reinterpret_cast<char*>(&_impl_.profile_id_),
          reinterpret_cast<char*>(&other->_impl_.profile_id_));
}

std::string ProfileConnectionStats::GetTypeName() const {
  return "bluetooth.metrics.BluetoothMetricsProto.ProfileConnectionStats";
}


// ===================================================================

class HeadsetProfileConnectionStats::_Internal {
 public:
  using HasBits = decltype(std::declval<HeadsetProfileConnectionStats>()._impl_._has_bits_);
  static void set_has_headset_profile_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_num_times_connected(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

HeadsetProfileConnectionStats::HeadsetProfileConnectionStats(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:bluetooth.metrics.BluetoothMetricsProto.HeadsetProfileConnectionStats)
}
HeadsetProfileConnectionStats::HeadsetProfileConnectionStats(const HeadsetProfileConnectionStats& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  HeadsetProfileConnectionStats* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.headset_profile_type_){}
    , decltype(_impl_.num_times_connected_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.headset_profile_type_, &from._impl_.headset_profile_type_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.num_times_connected_) -
    reinterpret_cast<char*>(&_impl_.headset_profile_type_)) + sizeof(_impl_.num_times_connected_));
  // @@protoc_insertion_point(copy_constructor:bluetooth.metrics.BluetoothMetricsProto.HeadsetProfileConnectionStats)
}

inline void HeadsetProfileConnectionStats::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.headset_profile_type_){0}
    , decltype(_impl_.num_times_connected_){0}
  };
}

HeadsetProfileConnectionStats::~HeadsetProfileConnectionStats() {
  // @@protoc_insertion_point(destructor:bluetooth.metrics.BluetoothMetricsProto.HeadsetProfileConnectionStats)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void HeadsetProfileConnectionStats::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void HeadsetProfileConnectionStats::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void HeadsetProfileConnectionStats::Clear() {
// @@protoc_insertion_point(message_clear_start:bluetooth.metrics.BluetoothMetricsProto.HeadsetProfileConnectionStats)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.headset_profile_type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.num_times_connected_) -
        reinterpret_cast<char*>(&_impl_.headset_profile_type_)) + sizeof(_impl_.num_times_connected_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* HeadsetProfileConnectionStats::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .bluetooth.metrics.BluetoothMetricsProto.HeadsetProfileType headset_profile_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          ::uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::bluetooth::metrics::BluetoothMetricsProto::HeadsetProfileType_IsValid(val))) {
            _internal_set_headset_profile_type(static_cast<::bluetooth::metrics::BluetoothMetricsProto::HeadsetProfileType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 num_times_connected = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_num_times_connected(&has_bits);
          _impl_.num_times_connected_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* HeadsetProfileConnectionStats::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:bluetooth.metrics.BluetoothMetricsProto.HeadsetProfileConnectionStats)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .bluetooth.metrics.BluetoothMetricsProto.HeadsetProfileType headset_profile_type = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_headset_profile_type(), target);
  }

  // optional int32 num_times_connected = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_num_times_connected(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:bluetooth.metrics.BluetoothMetricsProto.HeadsetProfileConnectionStats)
  return target;
}

size_t HeadsetProfileConnectionStats::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:bluetooth.metrics.BluetoothMetricsProto.HeadsetProfileConnectionStats)
  size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .bluetooth.metrics.BluetoothMetricsProto.HeadsetProfileType headset_profile_type = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_headset_profile_type());
    }

    // optional int32 num_times_connected = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_num_times_connected());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void HeadsetProfileConnectionStats::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const HeadsetProfileConnectionStats*>(
      &from));
}

void HeadsetProfileConnectionStats::MergeFrom(const HeadsetProfileConnectionStats& from) {
  HeadsetProfileConnectionStats* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:bluetooth.metrics.BluetoothMetricsProto.HeadsetProfileConnectionStats)
  GOOGLE_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.headset_profile_type_ = from._impl_.headset_profile_type_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.num_times_connected_ = from._impl_.num_times_connected_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void HeadsetProfileConnectionStats::CopyFrom(const HeadsetProfileConnectionStats& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:bluetooth.metrics.BluetoothMetricsProto.HeadsetProfileConnectionStats)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HeadsetProfileConnectionStats::IsInitialized() const {
  return true;
}

void HeadsetProfileConnectionStats::InternalSwap(HeadsetProfileConnectionStats* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(HeadsetProfileConnectionStats, _impl_.num_times_connected_)
      + sizeof(HeadsetProfileConnectionStats::_impl_.num_times_connected_)  // NOLINT
      - PROTOBUF_FIELD_OFFSET(HeadsetProfileConnectionStats, _impl_.headset_profile_type_)>(
          reinterpret_cast<char*>(&_impl_.headset_profile_type_),
          reinterpret_cast<char*>(&other->_impl_.headset_profile_type_));
}

std::string HeadsetProfileConnectionStats::GetTypeName() const {
  return "bluetooth.metrics.BluetoothMetricsProto.HeadsetProfileConnectionStats";
}


// ===================================================================

class BluetoothRemoteDeviceInformation::_Internal {
 public:
  using HasBits = decltype(std::declval<BluetoothRemoteDeviceInformation>()._impl_._has_bits_);
  static void set_has_allowlisted_device_name_hash(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_class_of_device(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_oui(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

BluetoothRemoteDeviceInformation::BluetoothRemoteDeviceInformation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:bluetooth.metrics.BluetoothMetricsProto.BluetoothRemoteDeviceInformation)
}
BluetoothRemoteDeviceInformation::BluetoothRemoteDeviceInformation(const BluetoothRemoteDeviceInformation& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  BluetoothRemoteDeviceInformation* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.allowlisted_device_name_hash_){}
    , decltype(_impl_.class_of_device_){}
    , decltype(_impl_.oui_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.allowlisted_device_name_hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.allowlisted_device_name_hash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_allowlisted_device_name_hash()) {
    _this->_impl_.allowlisted_device_name_hash_.Set(from._internal_allowlisted_device_name_hash(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.class_of_device_, &from._impl_.class_of_device_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.oui_) -
    reinterpret_cast<char*>(&_impl_.class_of_device_)) + sizeof(_impl_.oui_));
  // @@protoc_insertion_point(copy_constructor:bluetooth.metrics.BluetoothMetricsProto.BluetoothRemoteDeviceInformation)
}

inline void BluetoothRemoteDeviceInformation::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.allowlisted_device_name_hash_){}
    , decltype(_impl_.class_of_device_){0}
    , decltype(_impl_.oui_){0}
  };
  _impl_.allowlisted_device_name_hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.allowlisted_device_name_hash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

BluetoothRemoteDeviceInformation::~BluetoothRemoteDeviceInformation() {
  // @@protoc_insertion_point(destructor:bluetooth.metrics.BluetoothMetricsProto.BluetoothRemoteDeviceInformation)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BluetoothRemoteDeviceInformation::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.allowlisted_device_name_hash_.Destroy();
}

void BluetoothRemoteDeviceInformation::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BluetoothRemoteDeviceInformation::Clear() {
// @@protoc_insertion_point(message_clear_start:bluetooth.metrics.BluetoothMetricsProto.BluetoothRemoteDeviceInformation)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.allowlisted_device_name_hash_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.class_of_device_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.oui_) -
        reinterpret_cast<char*>(&_impl_.class_of_device_)) + sizeof(_impl_.oui_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* BluetoothRemoteDeviceInformation::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string allowlisted_device_name_hash = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_allowlisted_device_name_hash();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 class_of_device = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_class_of_device(&has_bits);
          _impl_.class_of_device_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 oui = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_oui(&has_bits);
          _impl_.oui_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* BluetoothRemoteDeviceInformation::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:bluetooth.metrics.BluetoothMetricsProto.BluetoothRemoteDeviceInformation)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string allowlisted_device_name_hash = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_allowlisted_device_name_hash(), target);
  }

  // optional int32 class_of_device = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_class_of_device(), target);
  }

  // optional int32 oui = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_oui(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:bluetooth.metrics.BluetoothMetricsProto.BluetoothRemoteDeviceInformation)
  return target;
}

size_t BluetoothRemoteDeviceInformation::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:bluetooth.metrics.BluetoothMetricsProto.BluetoothRemoteDeviceInformation)
  size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string allowlisted_device_name_hash = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_allowlisted_device_name_hash());
    }

    // optional int32 class_of_device = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_class_of_device());
    }

    // optional int32 oui = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_oui());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void BluetoothRemoteDeviceInformation::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const BluetoothRemoteDeviceInformation*>(
      &from));
}

void BluetoothRemoteDeviceInformation::MergeFrom(const BluetoothRemoteDeviceInformation& from) {
  BluetoothRemoteDeviceInformation* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:bluetooth.metrics.BluetoothMetricsProto.BluetoothRemoteDeviceInformation)
  GOOGLE_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_allowlisted_device_name_hash(from._internal_allowlisted_device_name_hash());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.class_of_device_ = from._impl_.class_of_device_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.oui_ = from._impl_.oui_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void BluetoothRemoteDeviceInformation::CopyFrom(const BluetoothRemoteDeviceInformation& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:bluetooth.metrics.BluetoothMetricsProto.BluetoothRemoteDeviceInformation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BluetoothRemoteDeviceInformation::IsInitialized() const {
  return true;
}

void BluetoothRemoteDeviceInformation::InternalSwap(BluetoothRemoteDeviceInformation* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.allowlisted_device_name_hash_, lhs_arena,
      &other->_impl_.allowlisted_device_name_hash_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BluetoothRemoteDeviceInformation, _impl_.oui_)
      + sizeof(BluetoothRemoteDeviceInformation::_impl_.oui_)  // NOLINT
      - PROTOBUF_FIELD_OFFSET(BluetoothRemoteDeviceInformation, _impl_.class_of_device_)>(
          reinterpret_cast<char*>(&_impl_.class_of_device_),
          reinterpret_cast<char*>(&other->_impl_.class_of_device_));
}

std::string BluetoothRemoteDeviceInformation::GetTypeName() const {
  return "bluetooth.metrics.BluetoothMetricsProto.BluetoothRemoteDeviceInformation";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace BluetoothMetricsProto
}  // namespace metrics
}  // namespace bluetooth
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::bluetooth::metrics::BluetoothMetricsProto::BluetoothLog*
Arena::CreateMaybeMessage< ::bluetooth::metrics::BluetoothMetricsProto::BluetoothLog >(Arena* arena) {
  return Arena::CreateMessageInternal< ::bluetooth::metrics::BluetoothMetricsProto::BluetoothLog >(arena);
}
template<> PROTOBUF_NOINLINE ::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo*
Arena::CreateMaybeMessage< ::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::bluetooth::metrics::BluetoothMetricsProto::BluetoothSession*
Arena::CreateMaybeMessage< ::bluetooth::metrics::BluetoothMetricsProto::BluetoothSession >(Arena* arena) {
  return Arena::CreateMessageInternal< ::bluetooth::metrics::BluetoothMetricsProto::BluetoothSession >(arena);
}
template<> PROTOBUF_NOINLINE ::bluetooth::metrics::BluetoothMetricsProto::RFCommSession*
Arena::CreateMaybeMessage< ::bluetooth::metrics::BluetoothMetricsProto::RFCommSession >(Arena* arena) {
  return Arena::CreateMessageInternal< ::bluetooth::metrics::BluetoothMetricsProto::RFCommSession >(arena);
}
template<> PROTOBUF_NOINLINE ::bluetooth::metrics::BluetoothMetricsProto::A2DPSession*
Arena::CreateMaybeMessage< ::bluetooth::metrics::BluetoothMetricsProto::A2DPSession >(Arena* arena) {
  return Arena::CreateMessageInternal< ::bluetooth::metrics::BluetoothMetricsProto::A2DPSession >(arena);
}
template<> PROTOBUF_NOINLINE ::bluetooth::metrics::BluetoothMetricsProto::PairEvent*
Arena::CreateMaybeMessage< ::bluetooth::metrics::BluetoothMetricsProto::PairEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::bluetooth::metrics::BluetoothMetricsProto::PairEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::bluetooth::metrics::BluetoothMetricsProto::WakeEvent*
Arena::CreateMaybeMessage< ::bluetooth::metrics::BluetoothMetricsProto::WakeEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::bluetooth::metrics::BluetoothMetricsProto::WakeEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::bluetooth::metrics::BluetoothMetricsProto::ScanEvent*
Arena::CreateMaybeMessage< ::bluetooth::metrics::BluetoothMetricsProto::ScanEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::bluetooth::metrics::BluetoothMetricsProto::ScanEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::bluetooth::metrics::BluetoothMetricsProto::ProfileConnectionStats*
Arena::CreateMaybeMessage< ::bluetooth::metrics::BluetoothMetricsProto::ProfileConnectionStats >(Arena* arena) {
  return Arena::CreateMessageInternal< ::bluetooth::metrics::BluetoothMetricsProto::ProfileConnectionStats >(arena);
}
template<> PROTOBUF_NOINLINE ::bluetooth::metrics::BluetoothMetricsProto::HeadsetProfileConnectionStats*
Arena::CreateMaybeMessage< ::bluetooth::metrics::BluetoothMetricsProto::HeadsetProfileConnectionStats >(Arena* arena) {
  return Arena::CreateMessageInternal< ::bluetooth::metrics::BluetoothMetricsProto::HeadsetProfileConnectionStats >(arena);
}
template<> PROTOBUF_NOINLINE ::bluetooth::metrics::BluetoothMetricsProto::BluetoothRemoteDeviceInformation*
Arena::CreateMaybeMessage< ::bluetooth::metrics::BluetoothMetricsProto::BluetoothRemoteDeviceInformation >(Arena* arena) {
  return Arena::CreateMessageInternal< ::bluetooth::metrics::BluetoothMetricsProto::BluetoothRemoteDeviceInformation >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
