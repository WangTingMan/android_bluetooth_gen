// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: packages/modules/Bluetooth/system/gd/proto/bluetooth/metrics/bluetooth.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_packages_2fmodules_2fBluetooth_2fsystem_2fgd_2fproto_2fbluetooth_2fmetrics_2fbluetooth_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_packages_2fmodules_2fBluetooth_2fsystem_2fgd_2fproto_2fbluetooth_2fmetrics_2fbluetooth_2eproto

#include <cstdint>
#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_packages_2fmodules_2fBluetooth_2fsystem_2fgd_2fproto_2fbluetooth_2fmetrics_2fbluetooth_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_packages_2fmodules_2fBluetooth_2fsystem_2fgd_2fproto_2fbluetooth_2fmetrics_2fbluetooth_2eproto {
  static const ::uint32_t offsets[];
};
namespace bluetooth {
namespace metrics {
namespace BluetoothMetricsProto {
class A2DPSession;
struct A2DPSessionDefaultTypeInternal;
extern A2DPSessionDefaultTypeInternal _A2DPSession_default_instance_;
class BluetoothLog;
struct BluetoothLogDefaultTypeInternal;
extern BluetoothLogDefaultTypeInternal _BluetoothLog_default_instance_;
class BluetoothRemoteDeviceInformation;
struct BluetoothRemoteDeviceInformationDefaultTypeInternal;
extern BluetoothRemoteDeviceInformationDefaultTypeInternal _BluetoothRemoteDeviceInformation_default_instance_;
class BluetoothSession;
struct BluetoothSessionDefaultTypeInternal;
extern BluetoothSessionDefaultTypeInternal _BluetoothSession_default_instance_;
class DeviceInfo;
struct DeviceInfoDefaultTypeInternal;
extern DeviceInfoDefaultTypeInternal _DeviceInfo_default_instance_;
class HeadsetProfileConnectionStats;
struct HeadsetProfileConnectionStatsDefaultTypeInternal;
extern HeadsetProfileConnectionStatsDefaultTypeInternal _HeadsetProfileConnectionStats_default_instance_;
class PairEvent;
struct PairEventDefaultTypeInternal;
extern PairEventDefaultTypeInternal _PairEvent_default_instance_;
class ProfileConnectionStats;
struct ProfileConnectionStatsDefaultTypeInternal;
extern ProfileConnectionStatsDefaultTypeInternal _ProfileConnectionStats_default_instance_;
class RFCommSession;
struct RFCommSessionDefaultTypeInternal;
extern RFCommSessionDefaultTypeInternal _RFCommSession_default_instance_;
class ScanEvent;
struct ScanEventDefaultTypeInternal;
extern ScanEventDefaultTypeInternal _ScanEvent_default_instance_;
class WakeEvent;
struct WakeEventDefaultTypeInternal;
extern WakeEventDefaultTypeInternal _WakeEvent_default_instance_;
}  // namespace BluetoothMetricsProto
}  // namespace metrics
}  // namespace bluetooth
PROTOBUF_NAMESPACE_OPEN
template<> ::bluetooth::metrics::BluetoothMetricsProto::A2DPSession* Arena::CreateMaybeMessage<::bluetooth::metrics::BluetoothMetricsProto::A2DPSession>(Arena*);
template<> ::bluetooth::metrics::BluetoothMetricsProto::BluetoothLog* Arena::CreateMaybeMessage<::bluetooth::metrics::BluetoothMetricsProto::BluetoothLog>(Arena*);
template<> ::bluetooth::metrics::BluetoothMetricsProto::BluetoothRemoteDeviceInformation* Arena::CreateMaybeMessage<::bluetooth::metrics::BluetoothMetricsProto::BluetoothRemoteDeviceInformation>(Arena*);
template<> ::bluetooth::metrics::BluetoothMetricsProto::BluetoothSession* Arena::CreateMaybeMessage<::bluetooth::metrics::BluetoothMetricsProto::BluetoothSession>(Arena*);
template<> ::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo* Arena::CreateMaybeMessage<::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo>(Arena*);
template<> ::bluetooth::metrics::BluetoothMetricsProto::HeadsetProfileConnectionStats* Arena::CreateMaybeMessage<::bluetooth::metrics::BluetoothMetricsProto::HeadsetProfileConnectionStats>(Arena*);
template<> ::bluetooth::metrics::BluetoothMetricsProto::PairEvent* Arena::CreateMaybeMessage<::bluetooth::metrics::BluetoothMetricsProto::PairEvent>(Arena*);
template<> ::bluetooth::metrics::BluetoothMetricsProto::ProfileConnectionStats* Arena::CreateMaybeMessage<::bluetooth::metrics::BluetoothMetricsProto::ProfileConnectionStats>(Arena*);
template<> ::bluetooth::metrics::BluetoothMetricsProto::RFCommSession* Arena::CreateMaybeMessage<::bluetooth::metrics::BluetoothMetricsProto::RFCommSession>(Arena*);
template<> ::bluetooth::metrics::BluetoothMetricsProto::ScanEvent* Arena::CreateMaybeMessage<::bluetooth::metrics::BluetoothMetricsProto::ScanEvent>(Arena*);
template<> ::bluetooth::metrics::BluetoothMetricsProto::WakeEvent* Arena::CreateMaybeMessage<::bluetooth::metrics::BluetoothMetricsProto::WakeEvent>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace bluetooth {
namespace metrics {
namespace BluetoothMetricsProto {

enum DeviceInfo_DeviceType : int {
  DeviceInfo_DeviceType_DEVICE_TYPE_UNKNOWN = 0,
  DeviceInfo_DeviceType_DEVICE_TYPE_BREDR = 1,
  DeviceInfo_DeviceType_DEVICE_TYPE_LE = 2,
  DeviceInfo_DeviceType_DEVICE_TYPE_DUMO = 3
};
bool DeviceInfo_DeviceType_IsValid(int value);
constexpr DeviceInfo_DeviceType DeviceInfo_DeviceType_DeviceType_MIN = DeviceInfo_DeviceType_DEVICE_TYPE_UNKNOWN;
constexpr DeviceInfo_DeviceType DeviceInfo_DeviceType_DeviceType_MAX = DeviceInfo_DeviceType_DEVICE_TYPE_DUMO;
constexpr int DeviceInfo_DeviceType_DeviceType_ARRAYSIZE = DeviceInfo_DeviceType_DeviceType_MAX + 1;

const std::string& DeviceInfo_DeviceType_Name(DeviceInfo_DeviceType value);
template<typename T>
inline const std::string& DeviceInfo_DeviceType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DeviceInfo_DeviceType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DeviceInfo_DeviceType_Name.");
  return DeviceInfo_DeviceType_Name(static_cast<DeviceInfo_DeviceType>(enum_t_value));
}
bool DeviceInfo_DeviceType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DeviceInfo_DeviceType* value);
enum BluetoothSession_ConnectionTechnologyType : int {
  BluetoothSession_ConnectionTechnologyType_CONNECTION_TECHNOLOGY_TYPE_UNKNOWN = 0,
  BluetoothSession_ConnectionTechnologyType_CONNECTION_TECHNOLOGY_TYPE_LE = 1,
  BluetoothSession_ConnectionTechnologyType_CONNECTION_TECHNOLOGY_TYPE_BREDR = 2
};
bool BluetoothSession_ConnectionTechnologyType_IsValid(int value);
constexpr BluetoothSession_ConnectionTechnologyType BluetoothSession_ConnectionTechnologyType_ConnectionTechnologyType_MIN = BluetoothSession_ConnectionTechnologyType_CONNECTION_TECHNOLOGY_TYPE_UNKNOWN;
constexpr BluetoothSession_ConnectionTechnologyType BluetoothSession_ConnectionTechnologyType_ConnectionTechnologyType_MAX = BluetoothSession_ConnectionTechnologyType_CONNECTION_TECHNOLOGY_TYPE_BREDR;
constexpr int BluetoothSession_ConnectionTechnologyType_ConnectionTechnologyType_ARRAYSIZE = BluetoothSession_ConnectionTechnologyType_ConnectionTechnologyType_MAX + 1;

const std::string& BluetoothSession_ConnectionTechnologyType_Name(BluetoothSession_ConnectionTechnologyType value);
template<typename T>
inline const std::string& BluetoothSession_ConnectionTechnologyType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BluetoothSession_ConnectionTechnologyType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BluetoothSession_ConnectionTechnologyType_Name.");
  return BluetoothSession_ConnectionTechnologyType_Name(static_cast<BluetoothSession_ConnectionTechnologyType>(enum_t_value));
}
bool BluetoothSession_ConnectionTechnologyType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BluetoothSession_ConnectionTechnologyType* value);
enum BluetoothSession_DisconnectReasonType : int {
  BluetoothSession_DisconnectReasonType_UNKNOWN = 0,
  BluetoothSession_DisconnectReasonType_METRICS_DUMP = 1,
  BluetoothSession_DisconnectReasonType_NEXT_START_WITHOUT_END_PREVIOUS = 2
};
bool BluetoothSession_DisconnectReasonType_IsValid(int value);
constexpr BluetoothSession_DisconnectReasonType BluetoothSession_DisconnectReasonType_DisconnectReasonType_MIN = BluetoothSession_DisconnectReasonType_UNKNOWN;
constexpr BluetoothSession_DisconnectReasonType BluetoothSession_DisconnectReasonType_DisconnectReasonType_MAX = BluetoothSession_DisconnectReasonType_NEXT_START_WITHOUT_END_PREVIOUS;
constexpr int BluetoothSession_DisconnectReasonType_DisconnectReasonType_ARRAYSIZE = BluetoothSession_DisconnectReasonType_DisconnectReasonType_MAX + 1;

const std::string& BluetoothSession_DisconnectReasonType_Name(BluetoothSession_DisconnectReasonType value);
template<typename T>
inline const std::string& BluetoothSession_DisconnectReasonType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BluetoothSession_DisconnectReasonType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BluetoothSession_DisconnectReasonType_Name.");
  return BluetoothSession_DisconnectReasonType_Name(static_cast<BluetoothSession_DisconnectReasonType>(enum_t_value));
}
bool BluetoothSession_DisconnectReasonType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BluetoothSession_DisconnectReasonType* value);
enum WakeEvent_WakeEventType : int {
  WakeEvent_WakeEventType_UNKNOWN = 0,
  WakeEvent_WakeEventType_ACQUIRED = 1,
  WakeEvent_WakeEventType_RELEASED = 2
};
bool WakeEvent_WakeEventType_IsValid(int value);
constexpr WakeEvent_WakeEventType WakeEvent_WakeEventType_WakeEventType_MIN = WakeEvent_WakeEventType_UNKNOWN;
constexpr WakeEvent_WakeEventType WakeEvent_WakeEventType_WakeEventType_MAX = WakeEvent_WakeEventType_RELEASED;
constexpr int WakeEvent_WakeEventType_WakeEventType_ARRAYSIZE = WakeEvent_WakeEventType_WakeEventType_MAX + 1;

const std::string& WakeEvent_WakeEventType_Name(WakeEvent_WakeEventType value);
template<typename T>
inline const std::string& WakeEvent_WakeEventType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, WakeEvent_WakeEventType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function WakeEvent_WakeEventType_Name.");
  return WakeEvent_WakeEventType_Name(static_cast<WakeEvent_WakeEventType>(enum_t_value));
}
bool WakeEvent_WakeEventType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, WakeEvent_WakeEventType* value);
enum ScanEvent_ScanTechnologyType : int {
  ScanEvent_ScanTechnologyType_SCAN_TYPE_UNKNOWN = 0,
  ScanEvent_ScanTechnologyType_SCAN_TECH_TYPE_LE = 1,
  ScanEvent_ScanTechnologyType_SCAN_TECH_TYPE_BREDR = 2,
  ScanEvent_ScanTechnologyType_SCAN_TECH_TYPE_BOTH = 3
};
bool ScanEvent_ScanTechnologyType_IsValid(int value);
constexpr ScanEvent_ScanTechnologyType ScanEvent_ScanTechnologyType_ScanTechnologyType_MIN = ScanEvent_ScanTechnologyType_SCAN_TYPE_UNKNOWN;
constexpr ScanEvent_ScanTechnologyType ScanEvent_ScanTechnologyType_ScanTechnologyType_MAX = ScanEvent_ScanTechnologyType_SCAN_TECH_TYPE_BOTH;
constexpr int ScanEvent_ScanTechnologyType_ScanTechnologyType_ARRAYSIZE = ScanEvent_ScanTechnologyType_ScanTechnologyType_MAX + 1;

const std::string& ScanEvent_ScanTechnologyType_Name(ScanEvent_ScanTechnologyType value);
template<typename T>
inline const std::string& ScanEvent_ScanTechnologyType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ScanEvent_ScanTechnologyType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ScanEvent_ScanTechnologyType_Name.");
  return ScanEvent_ScanTechnologyType_Name(static_cast<ScanEvent_ScanTechnologyType>(enum_t_value));
}
bool ScanEvent_ScanTechnologyType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ScanEvent_ScanTechnologyType* value);
enum ScanEvent_ScanEventType : int {
  ScanEvent_ScanEventType_SCAN_EVENT_START = 0,
  ScanEvent_ScanEventType_SCAN_EVENT_STOP = 1
};
bool ScanEvent_ScanEventType_IsValid(int value);
constexpr ScanEvent_ScanEventType ScanEvent_ScanEventType_ScanEventType_MIN = ScanEvent_ScanEventType_SCAN_EVENT_START;
constexpr ScanEvent_ScanEventType ScanEvent_ScanEventType_ScanEventType_MAX = ScanEvent_ScanEventType_SCAN_EVENT_STOP;
constexpr int ScanEvent_ScanEventType_ScanEventType_ARRAYSIZE = ScanEvent_ScanEventType_ScanEventType_MAX + 1;

const std::string& ScanEvent_ScanEventType_Name(ScanEvent_ScanEventType value);
template<typename T>
inline const std::string& ScanEvent_ScanEventType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ScanEvent_ScanEventType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ScanEvent_ScanEventType_Name.");
  return ScanEvent_ScanEventType_Name(static_cast<ScanEvent_ScanEventType>(enum_t_value));
}
bool ScanEvent_ScanEventType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ScanEvent_ScanEventType* value);
enum A2dpSourceCodec : int {
  A2DP_SOURCE_CODEC_UNKNOWN = 0,
  A2DP_SOURCE_CODEC_SBC = 1,
  A2DP_SOURCE_CODEC_AAC = 2,
  A2DP_SOURCE_CODEC_APTX = 3,
  A2DP_SOURCE_CODEC_APTX_HD = 4,
  A2DP_SOURCE_CODEC_LDAC = 5
};
bool A2dpSourceCodec_IsValid(int value);
constexpr A2dpSourceCodec A2dpSourceCodec_MIN = A2DP_SOURCE_CODEC_UNKNOWN;
constexpr A2dpSourceCodec A2dpSourceCodec_MAX = A2DP_SOURCE_CODEC_LDAC;
constexpr int A2dpSourceCodec_ARRAYSIZE = A2dpSourceCodec_MAX + 1;

const std::string& A2dpSourceCodec_Name(A2dpSourceCodec value);
template<typename T>
inline const std::string& A2dpSourceCodec_Name(T enum_t_value) {
  static_assert(::std::is_same<T, A2dpSourceCodec>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function A2dpSourceCodec_Name.");
  return A2dpSourceCodec_Name(static_cast<A2dpSourceCodec>(enum_t_value));
}
bool A2dpSourceCodec_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, A2dpSourceCodec* value);
enum ProfileId : int {
  PROFILE_UNKNOWN = 0,
  HEADSET = 1,
  A2DP = 2,
  HEALTH = 3,
  HID_HOST = 4,
  PAN = 5,
  PBAP = 6,
  GATT = 7,
  GATT_SERVER = 8,
  MAP = 9,
  SAP = 10,
  A2DP_SINK = 11,
  AVRCP_CONTROLLER = 12,
  AVRCP = 13,
  HEADSET_CLIENT = 16,
  PBAP_CLIENT = 17,
  MAP_CLIENT = 18,
  HID_DEVICE = 19,
  OPP = 20,
  HEARING_AID = 21
};
bool ProfileId_IsValid(int value);
constexpr ProfileId ProfileId_MIN = PROFILE_UNKNOWN;
constexpr ProfileId ProfileId_MAX = HEARING_AID;
constexpr int ProfileId_ARRAYSIZE = ProfileId_MAX + 1;

const std::string& ProfileId_Name(ProfileId value);
template<typename T>
inline const std::string& ProfileId_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ProfileId>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ProfileId_Name.");
  return ProfileId_Name(static_cast<ProfileId>(enum_t_value));
}
bool ProfileId_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ProfileId* value);
enum HeadsetProfileType : int {
  HEADSET_PROFILE_UNKNOWN = 0,
  HSP = 1,
  HFP = 2
};
bool HeadsetProfileType_IsValid(int value);
constexpr HeadsetProfileType HeadsetProfileType_MIN = HEADSET_PROFILE_UNKNOWN;
constexpr HeadsetProfileType HeadsetProfileType_MAX = HFP;
constexpr int HeadsetProfileType_ARRAYSIZE = HeadsetProfileType_MAX + 1;

const std::string& HeadsetProfileType_Name(HeadsetProfileType value);
template<typename T>
inline const std::string& HeadsetProfileType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, HeadsetProfileType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function HeadsetProfileType_Name.");
  return HeadsetProfileType_Name(static_cast<HeadsetProfileType>(enum_t_value));
}
bool HeadsetProfileType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, HeadsetProfileType* value);
// ===================================================================

class BluetoothLog final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:bluetooth.metrics.BluetoothMetricsProto.BluetoothLog) */ {
 public:
  inline BluetoothLog() : BluetoothLog(nullptr) {}
  ~BluetoothLog() override;
  explicit PROTOBUF_CONSTEXPR BluetoothLog(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BluetoothLog(const BluetoothLog& from);
  BluetoothLog(BluetoothLog&& from) noexcept
    : BluetoothLog() {
    *this = ::std::move(from);
  }

  inline BluetoothLog& operator=(const BluetoothLog& from) {
    if (this == &from) return *this;
    CopyFrom(from);
    return *this;
  }
  inline BluetoothLog& operator=(BluetoothLog&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const BluetoothLog& default_instance() {
    return *internal_default_instance();
  }
  static inline const BluetoothLog* internal_default_instance() {
    return reinterpret_cast<const BluetoothLog*>(
               &_BluetoothLog_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(BluetoothLog& a, BluetoothLog& b) {
    a.Swap(&b);
  }
  inline void Swap(BluetoothLog* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BluetoothLog* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BluetoothLog* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BluetoothLog>(arena);
  }
  BluetoothLog* New() const {
    return New(nullptr);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const BluetoothLog& from);
  void MergeFrom(const BluetoothLog& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BluetoothLog* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bluetooth.metrics.BluetoothMetricsProto.BluetoothLog";
  }
  protected:
  explicit BluetoothLog(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionFieldNumber = 1,
    kPairEventFieldNumber = 2,
    kWakeEventFieldNumber = 3,
    kScanEventFieldNumber = 4,
    kProfileConnectionStatsFieldNumber = 10,
    kHeadsetProfileConnectionStatsFieldNumber = 11,
    kNumBluetoothSessionFieldNumber = 6,
    kNumPairEventFieldNumber = 7,
    kNumWakeEventFieldNumber = 8,
    kNumScanEventFieldNumber = 9,
    kNumBondedDevicesFieldNumber = 5,
  };
  // repeated .bluetooth.metrics.BluetoothMetricsProto.BluetoothSession session = 1;
  int session_size() const;
  private:
  int _internal_session_size() const;
  public:
  void clear_session();
  ::bluetooth::metrics::BluetoothMetricsProto::BluetoothSession* mutable_session(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bluetooth::metrics::BluetoothMetricsProto::BluetoothSession >*
      mutable_session();
  private:
  const ::bluetooth::metrics::BluetoothMetricsProto::BluetoothSession& _internal_session(int index) const;
  ::bluetooth::metrics::BluetoothMetricsProto::BluetoothSession* _internal_add_session();
  public:
  const ::bluetooth::metrics::BluetoothMetricsProto::BluetoothSession& session(int index) const;
  ::bluetooth::metrics::BluetoothMetricsProto::BluetoothSession* add_session();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bluetooth::metrics::BluetoothMetricsProto::BluetoothSession >&
      session() const;

  // repeated .bluetooth.metrics.BluetoothMetricsProto.PairEvent pair_event = 2;
  int pair_event_size() const;
  private:
  int _internal_pair_event_size() const;
  public:
  void clear_pair_event();
  ::bluetooth::metrics::BluetoothMetricsProto::PairEvent* mutable_pair_event(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bluetooth::metrics::BluetoothMetricsProto::PairEvent >*
      mutable_pair_event();
  private:
  const ::bluetooth::metrics::BluetoothMetricsProto::PairEvent& _internal_pair_event(int index) const;
  ::bluetooth::metrics::BluetoothMetricsProto::PairEvent* _internal_add_pair_event();
  public:
  const ::bluetooth::metrics::BluetoothMetricsProto::PairEvent& pair_event(int index) const;
  ::bluetooth::metrics::BluetoothMetricsProto::PairEvent* add_pair_event();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bluetooth::metrics::BluetoothMetricsProto::PairEvent >&
      pair_event() const;

  // repeated .bluetooth.metrics.BluetoothMetricsProto.WakeEvent wake_event = 3;
  int wake_event_size() const;
  private:
  int _internal_wake_event_size() const;
  public:
  void clear_wake_event();
  ::bluetooth::metrics::BluetoothMetricsProto::WakeEvent* mutable_wake_event(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bluetooth::metrics::BluetoothMetricsProto::WakeEvent >*
      mutable_wake_event();
  private:
  const ::bluetooth::metrics::BluetoothMetricsProto::WakeEvent& _internal_wake_event(int index) const;
  ::bluetooth::metrics::BluetoothMetricsProto::WakeEvent* _internal_add_wake_event();
  public:
  const ::bluetooth::metrics::BluetoothMetricsProto::WakeEvent& wake_event(int index) const;
  ::bluetooth::metrics::BluetoothMetricsProto::WakeEvent* add_wake_event();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bluetooth::metrics::BluetoothMetricsProto::WakeEvent >&
      wake_event() const;

  // repeated .bluetooth.metrics.BluetoothMetricsProto.ScanEvent scan_event = 4;
  int scan_event_size() const;
  private:
  int _internal_scan_event_size() const;
  public:
  void clear_scan_event();
  ::bluetooth::metrics::BluetoothMetricsProto::ScanEvent* mutable_scan_event(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bluetooth::metrics::BluetoothMetricsProto::ScanEvent >*
      mutable_scan_event();
  private:
  const ::bluetooth::metrics::BluetoothMetricsProto::ScanEvent& _internal_scan_event(int index) const;
  ::bluetooth::metrics::BluetoothMetricsProto::ScanEvent* _internal_add_scan_event();
  public:
  const ::bluetooth::metrics::BluetoothMetricsProto::ScanEvent& scan_event(int index) const;
  ::bluetooth::metrics::BluetoothMetricsProto::ScanEvent* add_scan_event();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bluetooth::metrics::BluetoothMetricsProto::ScanEvent >&
      scan_event() const;

  // repeated .bluetooth.metrics.BluetoothMetricsProto.ProfileConnectionStats profile_connection_stats = 10;
  int profile_connection_stats_size() const;
  private:
  int _internal_profile_connection_stats_size() const;
  public:
  void clear_profile_connection_stats();
  ::bluetooth::metrics::BluetoothMetricsProto::ProfileConnectionStats* mutable_profile_connection_stats(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bluetooth::metrics::BluetoothMetricsProto::ProfileConnectionStats >*
      mutable_profile_connection_stats();
  private:
  const ::bluetooth::metrics::BluetoothMetricsProto::ProfileConnectionStats& _internal_profile_connection_stats(int index) const;
  ::bluetooth::metrics::BluetoothMetricsProto::ProfileConnectionStats* _internal_add_profile_connection_stats();
  public:
  const ::bluetooth::metrics::BluetoothMetricsProto::ProfileConnectionStats& profile_connection_stats(int index) const;
  ::bluetooth::metrics::BluetoothMetricsProto::ProfileConnectionStats* add_profile_connection_stats();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bluetooth::metrics::BluetoothMetricsProto::ProfileConnectionStats >&
      profile_connection_stats() const;

  // repeated .bluetooth.metrics.BluetoothMetricsProto.HeadsetProfileConnectionStats headset_profile_connection_stats = 11;
  int headset_profile_connection_stats_size() const;
  private:
  int _internal_headset_profile_connection_stats_size() const;
  public:
  void clear_headset_profile_connection_stats();
  ::bluetooth::metrics::BluetoothMetricsProto::HeadsetProfileConnectionStats* mutable_headset_profile_connection_stats(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bluetooth::metrics::BluetoothMetricsProto::HeadsetProfileConnectionStats >*
      mutable_headset_profile_connection_stats();
  private:
  const ::bluetooth::metrics::BluetoothMetricsProto::HeadsetProfileConnectionStats& _internal_headset_profile_connection_stats(int index) const;
  ::bluetooth::metrics::BluetoothMetricsProto::HeadsetProfileConnectionStats* _internal_add_headset_profile_connection_stats();
  public:
  const ::bluetooth::metrics::BluetoothMetricsProto::HeadsetProfileConnectionStats& headset_profile_connection_stats(int index) const;
  ::bluetooth::metrics::BluetoothMetricsProto::HeadsetProfileConnectionStats* add_headset_profile_connection_stats();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bluetooth::metrics::BluetoothMetricsProto::HeadsetProfileConnectionStats >&
      headset_profile_connection_stats() const;

  // optional int64 num_bluetooth_session = 6;
  bool has_num_bluetooth_session() const;
  private:
  bool _internal_has_num_bluetooth_session() const;
  public:
  void clear_num_bluetooth_session();
  ::int64_t num_bluetooth_session() const;
  void set_num_bluetooth_session(::int64_t value);
  private:
  ::int64_t _internal_num_bluetooth_session() const;
  void _internal_set_num_bluetooth_session(::int64_t value);
  public:

  // optional int64 num_pair_event = 7;
  bool has_num_pair_event() const;
  private:
  bool _internal_has_num_pair_event() const;
  public:
  void clear_num_pair_event();
  ::int64_t num_pair_event() const;
  void set_num_pair_event(::int64_t value);
  private:
  ::int64_t _internal_num_pair_event() const;
  void _internal_set_num_pair_event(::int64_t value);
  public:

  // optional int64 num_wake_event = 8;
  bool has_num_wake_event() const;
  private:
  bool _internal_has_num_wake_event() const;
  public:
  void clear_num_wake_event();
  ::int64_t num_wake_event() const;
  void set_num_wake_event(::int64_t value);
  private:
  ::int64_t _internal_num_wake_event() const;
  void _internal_set_num_wake_event(::int64_t value);
  public:

  // optional int64 num_scan_event = 9;
  bool has_num_scan_event() const;
  private:
  bool _internal_has_num_scan_event() const;
  public:
  void clear_num_scan_event();
  ::int64_t num_scan_event() const;
  void set_num_scan_event(::int64_t value);
  private:
  ::int64_t _internal_num_scan_event() const;
  void _internal_set_num_scan_event(::int64_t value);
  public:

  // optional int32 num_bonded_devices = 5;
  bool has_num_bonded_devices() const;
  private:
  bool _internal_has_num_bonded_devices() const;
  public:
  void clear_num_bonded_devices();
  ::int32_t num_bonded_devices() const;
  void set_num_bonded_devices(::int32_t value);
  private:
  ::int32_t _internal_num_bonded_devices() const;
  void _internal_set_num_bonded_devices(::int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:bluetooth.metrics.BluetoothMetricsProto.BluetoothLog)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bluetooth::metrics::BluetoothMetricsProto::BluetoothSession > session_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bluetooth::metrics::BluetoothMetricsProto::PairEvent > pair_event_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bluetooth::metrics::BluetoothMetricsProto::WakeEvent > wake_event_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bluetooth::metrics::BluetoothMetricsProto::ScanEvent > scan_event_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bluetooth::metrics::BluetoothMetricsProto::ProfileConnectionStats > profile_connection_stats_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bluetooth::metrics::BluetoothMetricsProto::HeadsetProfileConnectionStats > headset_profile_connection_stats_;
    ::int64_t num_bluetooth_session_;
    ::int64_t num_pair_event_;
    ::int64_t num_wake_event_;
    ::int64_t num_scan_event_;
    ::int32_t num_bonded_devices_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_packages_2fmodules_2fBluetooth_2fsystem_2fgd_2fproto_2fbluetooth_2fmetrics_2fbluetooth_2eproto;
};
// -------------------------------------------------------------------

class DeviceInfo final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:bluetooth.metrics.BluetoothMetricsProto.DeviceInfo) */ {
 public:
  inline DeviceInfo() : DeviceInfo(nullptr) {}
  ~DeviceInfo() override;
  explicit PROTOBUF_CONSTEXPR DeviceInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceInfo(const DeviceInfo& from);
  DeviceInfo(DeviceInfo&& from) noexcept
    : DeviceInfo() {
    *this = ::std::move(from);
  }

  inline DeviceInfo& operator=(const DeviceInfo& from) {
    if (this == &from) return *this;
    CopyFrom(from);
    return *this;
  }
  inline DeviceInfo& operator=(DeviceInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DeviceInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceInfo* internal_default_instance() {
    return reinterpret_cast<const DeviceInfo*>(
               &_DeviceInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(DeviceInfo& a, DeviceInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeviceInfo>(arena);
  }
  DeviceInfo* New() const {
    return New(nullptr);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DeviceInfo& from);
  void MergeFrom(const DeviceInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeviceInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bluetooth.metrics.BluetoothMetricsProto.DeviceInfo";
  }
  protected:
  explicit DeviceInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef DeviceInfo_DeviceType DeviceType;
  static constexpr DeviceType DEVICE_TYPE_UNKNOWN =
    DeviceInfo_DeviceType_DEVICE_TYPE_UNKNOWN;
  static constexpr DeviceType DEVICE_TYPE_BREDR =
    DeviceInfo_DeviceType_DEVICE_TYPE_BREDR;
  static constexpr DeviceType DEVICE_TYPE_LE =
    DeviceInfo_DeviceType_DEVICE_TYPE_LE;
  static constexpr DeviceType DEVICE_TYPE_DUMO =
    DeviceInfo_DeviceType_DEVICE_TYPE_DUMO;
  static inline bool DeviceType_IsValid(int value) {
    return DeviceInfo_DeviceType_IsValid(value);
  }
  static constexpr DeviceType DeviceType_MIN =
    DeviceInfo_DeviceType_DeviceType_MIN;
  static constexpr DeviceType DeviceType_MAX =
    DeviceInfo_DeviceType_DeviceType_MAX;
  static constexpr int DeviceType_ARRAYSIZE =
    DeviceInfo_DeviceType_DeviceType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& DeviceType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, DeviceType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function DeviceType_Name.");
    return DeviceInfo_DeviceType_Name(enum_t_value);
  }
  static inline bool DeviceType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      DeviceType* value) {
    return DeviceInfo_DeviceType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceClassFieldNumber = 1,
    kDeviceTypeFieldNumber = 2,
  };
  // optional int32 device_class = 1;
  bool has_device_class() const;
  private:
  bool _internal_has_device_class() const;
  public:
  void clear_device_class();
  ::int32_t device_class() const;
  void set_device_class(::int32_t value);
  private:
  ::int32_t _internal_device_class() const;
  void _internal_set_device_class(::int32_t value);
  public:

  // optional .bluetooth.metrics.BluetoothMetricsProto.DeviceInfo.DeviceType device_type = 2;
  bool has_device_type() const;
  private:
  bool _internal_has_device_type() const;
  public:
  void clear_device_type();
  ::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo_DeviceType device_type() const;
  void set_device_type(::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo_DeviceType value);
  private:
  ::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo_DeviceType _internal_device_type() const;
  void _internal_set_device_type(::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo_DeviceType value);
  public:

  // @@protoc_insertion_point(class_scope:bluetooth.metrics.BluetoothMetricsProto.DeviceInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::int32_t device_class_;
    int device_type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_packages_2fmodules_2fBluetooth_2fsystem_2fgd_2fproto_2fbluetooth_2fmetrics_2fbluetooth_2eproto;
};
// -------------------------------------------------------------------

class BluetoothSession final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:bluetooth.metrics.BluetoothMetricsProto.BluetoothSession) */ {
 public:
  inline BluetoothSession() : BluetoothSession(nullptr) {}
  ~BluetoothSession() override;
  explicit PROTOBUF_CONSTEXPR BluetoothSession(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BluetoothSession(const BluetoothSession& from);
  BluetoothSession(BluetoothSession&& from) noexcept
    : BluetoothSession() {
    *this = ::std::move(from);
  }

  inline BluetoothSession& operator=(const BluetoothSession& from) {
    if (this == &from) return *this;
    CopyFrom(from);
    return *this;
  }
  inline BluetoothSession& operator=(BluetoothSession&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const BluetoothSession& default_instance() {
    return *internal_default_instance();
  }
  static inline const BluetoothSession* internal_default_instance() {
    return reinterpret_cast<const BluetoothSession*>(
               &_BluetoothSession_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(BluetoothSession& a, BluetoothSession& b) {
    a.Swap(&b);
  }
  inline void Swap(BluetoothSession* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BluetoothSession* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BluetoothSession* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BluetoothSession>(arena);
  }
  BluetoothSession* New() const {
    return New(nullptr);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const BluetoothSession& from);
  void MergeFrom(const BluetoothSession& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BluetoothSession* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bluetooth.metrics.BluetoothMetricsProto.BluetoothSession";
  }
  protected:
  explicit BluetoothSession(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef BluetoothSession_ConnectionTechnologyType ConnectionTechnologyType;
  static constexpr ConnectionTechnologyType CONNECTION_TECHNOLOGY_TYPE_UNKNOWN =
    BluetoothSession_ConnectionTechnologyType_CONNECTION_TECHNOLOGY_TYPE_UNKNOWN;
  static constexpr ConnectionTechnologyType CONNECTION_TECHNOLOGY_TYPE_LE =
    BluetoothSession_ConnectionTechnologyType_CONNECTION_TECHNOLOGY_TYPE_LE;
  static constexpr ConnectionTechnologyType CONNECTION_TECHNOLOGY_TYPE_BREDR =
    BluetoothSession_ConnectionTechnologyType_CONNECTION_TECHNOLOGY_TYPE_BREDR;
  static inline bool ConnectionTechnologyType_IsValid(int value) {
    return BluetoothSession_ConnectionTechnologyType_IsValid(value);
  }
  static constexpr ConnectionTechnologyType ConnectionTechnologyType_MIN =
    BluetoothSession_ConnectionTechnologyType_ConnectionTechnologyType_MIN;
  static constexpr ConnectionTechnologyType ConnectionTechnologyType_MAX =
    BluetoothSession_ConnectionTechnologyType_ConnectionTechnologyType_MAX;
  static constexpr int ConnectionTechnologyType_ARRAYSIZE =
    BluetoothSession_ConnectionTechnologyType_ConnectionTechnologyType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& ConnectionTechnologyType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ConnectionTechnologyType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ConnectionTechnologyType_Name.");
    return BluetoothSession_ConnectionTechnologyType_Name(enum_t_value);
  }
  static inline bool ConnectionTechnologyType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ConnectionTechnologyType* value) {
    return BluetoothSession_ConnectionTechnologyType_Parse(name, value);
  }

  typedef BluetoothSession_DisconnectReasonType DisconnectReasonType;
  static constexpr DisconnectReasonType UNKNOWN =
    BluetoothSession_DisconnectReasonType_UNKNOWN;
  static constexpr DisconnectReasonType METRICS_DUMP =
    BluetoothSession_DisconnectReasonType_METRICS_DUMP;
  static constexpr DisconnectReasonType NEXT_START_WITHOUT_END_PREVIOUS =
    BluetoothSession_DisconnectReasonType_NEXT_START_WITHOUT_END_PREVIOUS;
  static inline bool DisconnectReasonType_IsValid(int value) {
    return BluetoothSession_DisconnectReasonType_IsValid(value);
  }
  static constexpr DisconnectReasonType DisconnectReasonType_MIN =
    BluetoothSession_DisconnectReasonType_DisconnectReasonType_MIN;
  static constexpr DisconnectReasonType DisconnectReasonType_MAX =
    BluetoothSession_DisconnectReasonType_DisconnectReasonType_MAX;
  static constexpr int DisconnectReasonType_ARRAYSIZE =
    BluetoothSession_DisconnectReasonType_DisconnectReasonType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& DisconnectReasonType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, DisconnectReasonType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function DisconnectReasonType_Name.");
    return BluetoothSession_DisconnectReasonType_Name(enum_t_value);
  }
  static inline bool DisconnectReasonType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      DisconnectReasonType* value) {
    return BluetoothSession_DisconnectReasonType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDisconnectReasonFieldNumber = 4,
    kDeviceConnectedToFieldNumber = 5,
    kRfcommSessionFieldNumber = 6,
    kA2DpSessionFieldNumber = 7,
    kSessionDurationSecFieldNumber = 2,
    kConnectionTechnologyTypeFieldNumber = 3,
    kDisconnectReasonTypeFieldNumber = 8,
  };
  // optional string disconnect_reason = 4 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_disconnect_reason() const;
  private:
  bool _internal_has_disconnect_reason() const;
  public:
  PROTOBUF_DEPRECATED void clear_disconnect_reason();
  PROTOBUF_DEPRECATED const std::string& disconnect_reason() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  PROTOBUF_DEPRECATED void set_disconnect_reason(ArgT0&& arg0, ArgT... args);
  PROTOBUF_DEPRECATED std::string* mutable_disconnect_reason();
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED std::string* release_disconnect_reason();
  PROTOBUF_DEPRECATED void set_allocated_disconnect_reason(std::string* disconnect_reason);
  private:
  const std::string& _internal_disconnect_reason() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_disconnect_reason(const std::string& value);
  std::string* _internal_mutable_disconnect_reason();
  public:

  // optional .bluetooth.metrics.BluetoothMetricsProto.DeviceInfo device_connected_to = 5;
  bool has_device_connected_to() const;
  private:
  bool _internal_has_device_connected_to() const;
  public:
  void clear_device_connected_to();
  const ::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo& device_connected_to() const;
  PROTOBUF_NODISCARD ::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo* release_device_connected_to();
  ::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo* mutable_device_connected_to();
  void set_allocated_device_connected_to(::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo* device_connected_to);
  private:
  const ::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo& _internal_device_connected_to() const;
  ::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo* _internal_mutable_device_connected_to();
  public:
  void unsafe_arena_set_allocated_device_connected_to(
      ::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo* device_connected_to);
  ::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo* unsafe_arena_release_device_connected_to();

  // optional .bluetooth.metrics.BluetoothMetricsProto.RFCommSession rfcomm_session = 6;
  bool has_rfcomm_session() const;
  private:
  bool _internal_has_rfcomm_session() const;
  public:
  void clear_rfcomm_session();
  const ::bluetooth::metrics::BluetoothMetricsProto::RFCommSession& rfcomm_session() const;
  PROTOBUF_NODISCARD ::bluetooth::metrics::BluetoothMetricsProto::RFCommSession* release_rfcomm_session();
  ::bluetooth::metrics::BluetoothMetricsProto::RFCommSession* mutable_rfcomm_session();
  void set_allocated_rfcomm_session(::bluetooth::metrics::BluetoothMetricsProto::RFCommSession* rfcomm_session);
  private:
  const ::bluetooth::metrics::BluetoothMetricsProto::RFCommSession& _internal_rfcomm_session() const;
  ::bluetooth::metrics::BluetoothMetricsProto::RFCommSession* _internal_mutable_rfcomm_session();
  public:
  void unsafe_arena_set_allocated_rfcomm_session(
      ::bluetooth::metrics::BluetoothMetricsProto::RFCommSession* rfcomm_session);
  ::bluetooth::metrics::BluetoothMetricsProto::RFCommSession* unsafe_arena_release_rfcomm_session();

  // optional .bluetooth.metrics.BluetoothMetricsProto.A2DPSession a2dp_session = 7;
  bool has_a2dp_session() const;
  private:
  bool _internal_has_a2dp_session() const;
  public:
  void clear_a2dp_session();
  const ::bluetooth::metrics::BluetoothMetricsProto::A2DPSession& a2dp_session() const;
  PROTOBUF_NODISCARD ::bluetooth::metrics::BluetoothMetricsProto::A2DPSession* release_a2dp_session();
  ::bluetooth::metrics::BluetoothMetricsProto::A2DPSession* mutable_a2dp_session();
  void set_allocated_a2dp_session(::bluetooth::metrics::BluetoothMetricsProto::A2DPSession* a2dp_session);
  private:
  const ::bluetooth::metrics::BluetoothMetricsProto::A2DPSession& _internal_a2dp_session() const;
  ::bluetooth::metrics::BluetoothMetricsProto::A2DPSession* _internal_mutable_a2dp_session();
  public:
  void unsafe_arena_set_allocated_a2dp_session(
      ::bluetooth::metrics::BluetoothMetricsProto::A2DPSession* a2dp_session);
  ::bluetooth::metrics::BluetoothMetricsProto::A2DPSession* unsafe_arena_release_a2dp_session();

  // optional int64 session_duration_sec = 2;
  bool has_session_duration_sec() const;
  private:
  bool _internal_has_session_duration_sec() const;
  public:
  void clear_session_duration_sec();
  ::int64_t session_duration_sec() const;
  void set_session_duration_sec(::int64_t value);
  private:
  ::int64_t _internal_session_duration_sec() const;
  void _internal_set_session_duration_sec(::int64_t value);
  public:

  // optional .bluetooth.metrics.BluetoothMetricsProto.BluetoothSession.ConnectionTechnologyType connection_technology_type = 3;
  bool has_connection_technology_type() const;
  private:
  bool _internal_has_connection_technology_type() const;
  public:
  void clear_connection_technology_type();
  ::bluetooth::metrics::BluetoothMetricsProto::BluetoothSession_ConnectionTechnologyType connection_technology_type() const;
  void set_connection_technology_type(::bluetooth::metrics::BluetoothMetricsProto::BluetoothSession_ConnectionTechnologyType value);
  private:
  ::bluetooth::metrics::BluetoothMetricsProto::BluetoothSession_ConnectionTechnologyType _internal_connection_technology_type() const;
  void _internal_set_connection_technology_type(::bluetooth::metrics::BluetoothMetricsProto::BluetoothSession_ConnectionTechnologyType value);
  public:

  // optional .bluetooth.metrics.BluetoothMetricsProto.BluetoothSession.DisconnectReasonType disconnect_reason_type = 8;
  bool has_disconnect_reason_type() const;
  private:
  bool _internal_has_disconnect_reason_type() const;
  public:
  void clear_disconnect_reason_type();
  ::bluetooth::metrics::BluetoothMetricsProto::BluetoothSession_DisconnectReasonType disconnect_reason_type() const;
  void set_disconnect_reason_type(::bluetooth::metrics::BluetoothMetricsProto::BluetoothSession_DisconnectReasonType value);
  private:
  ::bluetooth::metrics::BluetoothMetricsProto::BluetoothSession_DisconnectReasonType _internal_disconnect_reason_type() const;
  void _internal_set_disconnect_reason_type(::bluetooth::metrics::BluetoothMetricsProto::BluetoothSession_DisconnectReasonType value);
  public:

  // @@protoc_insertion_point(class_scope:bluetooth.metrics.BluetoothMetricsProto.BluetoothSession)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr disconnect_reason_;
    ::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo* device_connected_to_;
    ::bluetooth::metrics::BluetoothMetricsProto::RFCommSession* rfcomm_session_;
    ::bluetooth::metrics::BluetoothMetricsProto::A2DPSession* a2dp_session_;
    ::int64_t session_duration_sec_;
    int connection_technology_type_;
    int disconnect_reason_type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_packages_2fmodules_2fBluetooth_2fsystem_2fgd_2fproto_2fbluetooth_2fmetrics_2fbluetooth_2eproto;
};
// -------------------------------------------------------------------

class RFCommSession final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:bluetooth.metrics.BluetoothMetricsProto.RFCommSession) */ {
 public:
  inline RFCommSession() : RFCommSession(nullptr) {}
  ~RFCommSession() override;
  explicit PROTOBUF_CONSTEXPR RFCommSession(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RFCommSession(const RFCommSession& from);
  RFCommSession(RFCommSession&& from) noexcept
    : RFCommSession() {
    *this = ::std::move(from);
  }

  inline RFCommSession& operator=(const RFCommSession& from) {
    if (this == &from) return *this;
    CopyFrom(from);
    return *this;
  }
  inline RFCommSession& operator=(RFCommSession&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const RFCommSession& default_instance() {
    return *internal_default_instance();
  }
  static inline const RFCommSession* internal_default_instance() {
    return reinterpret_cast<const RFCommSession*>(
               &_RFCommSession_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(RFCommSession& a, RFCommSession& b) {
    a.Swap(&b);
  }
  inline void Swap(RFCommSession* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RFCommSession* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RFCommSession* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RFCommSession>(arena);
  }
  RFCommSession* New() const {
    return New(nullptr);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const RFCommSession& from);
  void MergeFrom(const RFCommSession& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RFCommSession* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bluetooth.metrics.BluetoothMetricsProto.RFCommSession";
  }
  protected:
  explicit RFCommSession(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRxBytesFieldNumber = 1,
    kTxBytesFieldNumber = 2,
  };
  // optional int32 rx_bytes = 1;
  bool has_rx_bytes() const;
  private:
  bool _internal_has_rx_bytes() const;
  public:
  void clear_rx_bytes();
  ::int32_t rx_bytes() const;
  void set_rx_bytes(::int32_t value);
  private:
  ::int32_t _internal_rx_bytes() const;
  void _internal_set_rx_bytes(::int32_t value);
  public:

  // optional int32 tx_bytes = 2;
  bool has_tx_bytes() const;
  private:
  bool _internal_has_tx_bytes() const;
  public:
  void clear_tx_bytes();
  ::int32_t tx_bytes() const;
  void set_tx_bytes(::int32_t value);
  private:
  ::int32_t _internal_tx_bytes() const;
  void _internal_set_tx_bytes(::int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:bluetooth.metrics.BluetoothMetricsProto.RFCommSession)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::int32_t rx_bytes_;
    ::int32_t tx_bytes_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_packages_2fmodules_2fBluetooth_2fsystem_2fgd_2fproto_2fbluetooth_2fmetrics_2fbluetooth_2eproto;
};
// -------------------------------------------------------------------

class A2DPSession final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:bluetooth.metrics.BluetoothMetricsProto.A2DPSession) */ {
 public:
  inline A2DPSession() : A2DPSession(nullptr) {}
  ~A2DPSession() override;
  explicit PROTOBUF_CONSTEXPR A2DPSession(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  A2DPSession(const A2DPSession& from);
  A2DPSession(A2DPSession&& from) noexcept
    : A2DPSession() {
    *this = ::std::move(from);
  }

  inline A2DPSession& operator=(const A2DPSession& from) {
    if (this == &from) return *this;
    CopyFrom(from);
    return *this;
  }
  inline A2DPSession& operator=(A2DPSession&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const A2DPSession& default_instance() {
    return *internal_default_instance();
  }
  static inline const A2DPSession* internal_default_instance() {
    return reinterpret_cast<const A2DPSession*>(
               &_A2DPSession_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(A2DPSession& a, A2DPSession& b) {
    a.Swap(&b);
  }
  inline void Swap(A2DPSession* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(A2DPSession* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  A2DPSession* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<A2DPSession>(arena);
  }
  A2DPSession* New() const {
    return New(nullptr);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const A2DPSession& from);
  void MergeFrom(const A2DPSession& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(A2DPSession* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bluetooth.metrics.BluetoothMetricsProto.A2DPSession";
  }
  protected:
  explicit A2DPSession(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMediaTimerMinMillisFieldNumber = 1,
    kMediaTimerMaxMillisFieldNumber = 2,
    kMediaTimerAvgMillisFieldNumber = 3,
    kBufferOverrunsMaxCountFieldNumber = 4,
    kBufferOverrunsTotalFieldNumber = 5,
    kBufferUnderrunsAverageFieldNumber = 6,
    kAudioDurationMillisFieldNumber = 8,
    kBufferUnderrunsCountFieldNumber = 7,
    kSourceCodecFieldNumber = 9,
    kIsA2DpOffloadFieldNumber = 10,
  };
  // optional int32 media_timer_min_millis = 1;
  bool has_media_timer_min_millis() const;
  private:
  bool _internal_has_media_timer_min_millis() const;
  public:
  void clear_media_timer_min_millis();
  ::int32_t media_timer_min_millis() const;
  void set_media_timer_min_millis(::int32_t value);
  private:
  ::int32_t _internal_media_timer_min_millis() const;
  void _internal_set_media_timer_min_millis(::int32_t value);
  public:

  // optional int32 media_timer_max_millis = 2;
  bool has_media_timer_max_millis() const;
  private:
  bool _internal_has_media_timer_max_millis() const;
  public:
  void clear_media_timer_max_millis();
  ::int32_t media_timer_max_millis() const;
  void set_media_timer_max_millis(::int32_t value);
  private:
  ::int32_t _internal_media_timer_max_millis() const;
  void _internal_set_media_timer_max_millis(::int32_t value);
  public:

  // optional int32 media_timer_avg_millis = 3;
  bool has_media_timer_avg_millis() const;
  private:
  bool _internal_has_media_timer_avg_millis() const;
  public:
  void clear_media_timer_avg_millis();
  ::int32_t media_timer_avg_millis() const;
  void set_media_timer_avg_millis(::int32_t value);
  private:
  ::int32_t _internal_media_timer_avg_millis() const;
  void _internal_set_media_timer_avg_millis(::int32_t value);
  public:

  // optional int32 buffer_overruns_max_count = 4;
  bool has_buffer_overruns_max_count() const;
  private:
  bool _internal_has_buffer_overruns_max_count() const;
  public:
  void clear_buffer_overruns_max_count();
  ::int32_t buffer_overruns_max_count() const;
  void set_buffer_overruns_max_count(::int32_t value);
  private:
  ::int32_t _internal_buffer_overruns_max_count() const;
  void _internal_set_buffer_overruns_max_count(::int32_t value);
  public:

  // optional int32 buffer_overruns_total = 5;
  bool has_buffer_overruns_total() const;
  private:
  bool _internal_has_buffer_overruns_total() const;
  public:
  void clear_buffer_overruns_total();
  ::int32_t buffer_overruns_total() const;
  void set_buffer_overruns_total(::int32_t value);
  private:
  ::int32_t _internal_buffer_overruns_total() const;
  void _internal_set_buffer_overruns_total(::int32_t value);
  public:

  // optional float buffer_underruns_average = 6;
  bool has_buffer_underruns_average() const;
  private:
  bool _internal_has_buffer_underruns_average() const;
  public:
  void clear_buffer_underruns_average();
  float buffer_underruns_average() const;
  void set_buffer_underruns_average(float value);
  private:
  float _internal_buffer_underruns_average() const;
  void _internal_set_buffer_underruns_average(float value);
  public:

  // optional int64 audio_duration_millis = 8;
  bool has_audio_duration_millis() const;
  private:
  bool _internal_has_audio_duration_millis() const;
  public:
  void clear_audio_duration_millis();
  ::int64_t audio_duration_millis() const;
  void set_audio_duration_millis(::int64_t value);
  private:
  ::int64_t _internal_audio_duration_millis() const;
  void _internal_set_audio_duration_millis(::int64_t value);
  public:

  // optional int32 buffer_underruns_count = 7;
  bool has_buffer_underruns_count() const;
  private:
  bool _internal_has_buffer_underruns_count() const;
  public:
  void clear_buffer_underruns_count();
  ::int32_t buffer_underruns_count() const;
  void set_buffer_underruns_count(::int32_t value);
  private:
  ::int32_t _internal_buffer_underruns_count() const;
  void _internal_set_buffer_underruns_count(::int32_t value);
  public:

  // optional .bluetooth.metrics.BluetoothMetricsProto.A2dpSourceCodec source_codec = 9;
  bool has_source_codec() const;
  private:
  bool _internal_has_source_codec() const;
  public:
  void clear_source_codec();
  ::bluetooth::metrics::BluetoothMetricsProto::A2dpSourceCodec source_codec() const;
  void set_source_codec(::bluetooth::metrics::BluetoothMetricsProto::A2dpSourceCodec value);
  private:
  ::bluetooth::metrics::BluetoothMetricsProto::A2dpSourceCodec _internal_source_codec() const;
  void _internal_set_source_codec(::bluetooth::metrics::BluetoothMetricsProto::A2dpSourceCodec value);
  public:

  // optional bool is_a2dp_offload = 10;
  bool has_is_a2dp_offload() const;
  private:
  bool _internal_has_is_a2dp_offload() const;
  public:
  void clear_is_a2dp_offload();
  bool is_a2dp_offload() const;
  void set_is_a2dp_offload(bool value);
  private:
  bool _internal_is_a2dp_offload() const;
  void _internal_set_is_a2dp_offload(bool value);
  public:

  // @@protoc_insertion_point(class_scope:bluetooth.metrics.BluetoothMetricsProto.A2DPSession)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::int32_t media_timer_min_millis_;
    ::int32_t media_timer_max_millis_;
    ::int32_t media_timer_avg_millis_;
    ::int32_t buffer_overruns_max_count_;
    ::int32_t buffer_overruns_total_;
    float buffer_underruns_average_;
    ::int64_t audio_duration_millis_;
    ::int32_t buffer_underruns_count_;
    int source_codec_;
    bool is_a2dp_offload_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_packages_2fmodules_2fBluetooth_2fsystem_2fgd_2fproto_2fbluetooth_2fmetrics_2fbluetooth_2eproto;
};
// -------------------------------------------------------------------

class PairEvent final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:bluetooth.metrics.BluetoothMetricsProto.PairEvent) */ {
 public:
  inline PairEvent() : PairEvent(nullptr) {}
  ~PairEvent() override;
  explicit PROTOBUF_CONSTEXPR PairEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PairEvent(const PairEvent& from);
  PairEvent(PairEvent&& from) noexcept
    : PairEvent() {
    *this = ::std::move(from);
  }

  inline PairEvent& operator=(const PairEvent& from) {
    if (this == &from) return *this;
    CopyFrom(from);
    return *this;
  }
  inline PairEvent& operator=(PairEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const PairEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const PairEvent* internal_default_instance() {
    return reinterpret_cast<const PairEvent*>(
               &_PairEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(PairEvent& a, PairEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(PairEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PairEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PairEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PairEvent>(arena);
  }
  PairEvent* New() const {
    return New(nullptr);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const PairEvent& from);
  void MergeFrom(const PairEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PairEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bluetooth.metrics.BluetoothMetricsProto.PairEvent";
  }
  protected:
  explicit PairEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDevicePairedWithFieldNumber = 3,
    kEventTimeMillisFieldNumber = 2,
    kDisconnectReasonFieldNumber = 1,
  };
  // optional .bluetooth.metrics.BluetoothMetricsProto.DeviceInfo device_paired_with = 3;
  bool has_device_paired_with() const;
  private:
  bool _internal_has_device_paired_with() const;
  public:
  void clear_device_paired_with();
  const ::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo& device_paired_with() const;
  PROTOBUF_NODISCARD ::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo* release_device_paired_with();
  ::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo* mutable_device_paired_with();
  void set_allocated_device_paired_with(::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo* device_paired_with);
  private:
  const ::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo& _internal_device_paired_with() const;
  ::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo* _internal_mutable_device_paired_with();
  public:
  void unsafe_arena_set_allocated_device_paired_with(
      ::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo* device_paired_with);
  ::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo* unsafe_arena_release_device_paired_with();

  // optional int64 event_time_millis = 2;
  bool has_event_time_millis() const;
  private:
  bool _internal_has_event_time_millis() const;
  public:
  void clear_event_time_millis();
  ::int64_t event_time_millis() const;
  void set_event_time_millis(::int64_t value);
  private:
  ::int64_t _internal_event_time_millis() const;
  void _internal_set_event_time_millis(::int64_t value);
  public:

  // optional int32 disconnect_reason = 1;
  bool has_disconnect_reason() const;
  private:
  bool _internal_has_disconnect_reason() const;
  public:
  void clear_disconnect_reason();
  ::int32_t disconnect_reason() const;
  void set_disconnect_reason(::int32_t value);
  private:
  ::int32_t _internal_disconnect_reason() const;
  void _internal_set_disconnect_reason(::int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:bluetooth.metrics.BluetoothMetricsProto.PairEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo* device_paired_with_;
    ::int64_t event_time_millis_;
    ::int32_t disconnect_reason_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_packages_2fmodules_2fBluetooth_2fsystem_2fgd_2fproto_2fbluetooth_2fmetrics_2fbluetooth_2eproto;
};
// -------------------------------------------------------------------

class WakeEvent final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:bluetooth.metrics.BluetoothMetricsProto.WakeEvent) */ {
 public:
  inline WakeEvent() : WakeEvent(nullptr) {}
  ~WakeEvent() override;
  explicit PROTOBUF_CONSTEXPR WakeEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WakeEvent(const WakeEvent& from);
  WakeEvent(WakeEvent&& from) noexcept
    : WakeEvent() {
    *this = ::std::move(from);
  }

  inline WakeEvent& operator=(const WakeEvent& from) {
    if (this == &from) return *this;
    CopyFrom(from);
    return *this;
  }
  inline WakeEvent& operator=(WakeEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const WakeEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const WakeEvent* internal_default_instance() {
    return reinterpret_cast<const WakeEvent*>(
               &_WakeEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(WakeEvent& a, WakeEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(WakeEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WakeEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WakeEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<WakeEvent>(arena);
  }
  WakeEvent* New() const {
    return New(nullptr);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const WakeEvent& from);
  void MergeFrom(const WakeEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(WakeEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bluetooth.metrics.BluetoothMetricsProto.WakeEvent";
  }
  protected:
  explicit WakeEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef WakeEvent_WakeEventType WakeEventType;
  static constexpr WakeEventType UNKNOWN =
    WakeEvent_WakeEventType_UNKNOWN;
  static constexpr WakeEventType ACQUIRED =
    WakeEvent_WakeEventType_ACQUIRED;
  static constexpr WakeEventType RELEASED =
    WakeEvent_WakeEventType_RELEASED;
  static inline bool WakeEventType_IsValid(int value) {
    return WakeEvent_WakeEventType_IsValid(value);
  }
  static constexpr WakeEventType WakeEventType_MIN =
    WakeEvent_WakeEventType_WakeEventType_MIN;
  static constexpr WakeEventType WakeEventType_MAX =
    WakeEvent_WakeEventType_WakeEventType_MAX;
  static constexpr int WakeEventType_ARRAYSIZE =
    WakeEvent_WakeEventType_WakeEventType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& WakeEventType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, WakeEventType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function WakeEventType_Name.");
    return WakeEvent_WakeEventType_Name(enum_t_value);
  }
  static inline bool WakeEventType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      WakeEventType* value) {
    return WakeEvent_WakeEventType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kRequestorFieldNumber = 2,
    kNameFieldNumber = 3,
    kEventTimeMillisFieldNumber = 4,
    kWakeEventTypeFieldNumber = 1,
  };
  // optional string requestor = 2;
  bool has_requestor() const;
  private:
  bool _internal_has_requestor() const;
  public:
  void clear_requestor();
  const std::string& requestor() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_requestor(ArgT0&& arg0, ArgT... args);
  std::string* mutable_requestor();
  PROTOBUF_NODISCARD std::string* release_requestor();
  void set_allocated_requestor(std::string* requestor);
  private:
  const std::string& _internal_requestor() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_requestor(const std::string& value);
  std::string* _internal_mutable_requestor();
  public:

  // optional string name = 3;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional int64 event_time_millis = 4;
  bool has_event_time_millis() const;
  private:
  bool _internal_has_event_time_millis() const;
  public:
  void clear_event_time_millis();
  ::int64_t event_time_millis() const;
  void set_event_time_millis(::int64_t value);
  private:
  ::int64_t _internal_event_time_millis() const;
  void _internal_set_event_time_millis(::int64_t value);
  public:

  // optional .bluetooth.metrics.BluetoothMetricsProto.WakeEvent.WakeEventType wake_event_type = 1;
  bool has_wake_event_type() const;
  private:
  bool _internal_has_wake_event_type() const;
  public:
  void clear_wake_event_type();
  ::bluetooth::metrics::BluetoothMetricsProto::WakeEvent_WakeEventType wake_event_type() const;
  void set_wake_event_type(::bluetooth::metrics::BluetoothMetricsProto::WakeEvent_WakeEventType value);
  private:
  ::bluetooth::metrics::BluetoothMetricsProto::WakeEvent_WakeEventType _internal_wake_event_type() const;
  void _internal_set_wake_event_type(::bluetooth::metrics::BluetoothMetricsProto::WakeEvent_WakeEventType value);
  public:

  // @@protoc_insertion_point(class_scope:bluetooth.metrics.BluetoothMetricsProto.WakeEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr requestor_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::int64_t event_time_millis_;
    int wake_event_type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_packages_2fmodules_2fBluetooth_2fsystem_2fgd_2fproto_2fbluetooth_2fmetrics_2fbluetooth_2eproto;
};
// -------------------------------------------------------------------

class ScanEvent final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:bluetooth.metrics.BluetoothMetricsProto.ScanEvent) */ {
 public:
  inline ScanEvent() : ScanEvent(nullptr) {}
  ~ScanEvent() override;
  explicit PROTOBUF_CONSTEXPR ScanEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ScanEvent(const ScanEvent& from);
  ScanEvent(ScanEvent&& from) noexcept
    : ScanEvent() {
    *this = ::std::move(from);
  }

  inline ScanEvent& operator=(const ScanEvent& from) {
    if (this == &from) return *this;
    CopyFrom(from);
    return *this;
  }
  inline ScanEvent& operator=(ScanEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ScanEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const ScanEvent* internal_default_instance() {
    return reinterpret_cast<const ScanEvent*>(
               &_ScanEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ScanEvent& a, ScanEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(ScanEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ScanEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ScanEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ScanEvent>(arena);
  }
  ScanEvent* New() const {
    return New(nullptr);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ScanEvent& from);
  void MergeFrom(const ScanEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ScanEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bluetooth.metrics.BluetoothMetricsProto.ScanEvent";
  }
  protected:
  explicit ScanEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef ScanEvent_ScanTechnologyType ScanTechnologyType;
  static constexpr ScanTechnologyType SCAN_TYPE_UNKNOWN =
    ScanEvent_ScanTechnologyType_SCAN_TYPE_UNKNOWN;
  static constexpr ScanTechnologyType SCAN_TECH_TYPE_LE =
    ScanEvent_ScanTechnologyType_SCAN_TECH_TYPE_LE;
  static constexpr ScanTechnologyType SCAN_TECH_TYPE_BREDR =
    ScanEvent_ScanTechnologyType_SCAN_TECH_TYPE_BREDR;
  static constexpr ScanTechnologyType SCAN_TECH_TYPE_BOTH =
    ScanEvent_ScanTechnologyType_SCAN_TECH_TYPE_BOTH;
  static inline bool ScanTechnologyType_IsValid(int value) {
    return ScanEvent_ScanTechnologyType_IsValid(value);
  }
  static constexpr ScanTechnologyType ScanTechnologyType_MIN =
    ScanEvent_ScanTechnologyType_ScanTechnologyType_MIN;
  static constexpr ScanTechnologyType ScanTechnologyType_MAX =
    ScanEvent_ScanTechnologyType_ScanTechnologyType_MAX;
  static constexpr int ScanTechnologyType_ARRAYSIZE =
    ScanEvent_ScanTechnologyType_ScanTechnologyType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& ScanTechnologyType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ScanTechnologyType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ScanTechnologyType_Name.");
    return ScanEvent_ScanTechnologyType_Name(enum_t_value);
  }
  static inline bool ScanTechnologyType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ScanTechnologyType* value) {
    return ScanEvent_ScanTechnologyType_Parse(name, value);
  }

  typedef ScanEvent_ScanEventType ScanEventType;
  static constexpr ScanEventType SCAN_EVENT_START =
    ScanEvent_ScanEventType_SCAN_EVENT_START;
  static constexpr ScanEventType SCAN_EVENT_STOP =
    ScanEvent_ScanEventType_SCAN_EVENT_STOP;
  static inline bool ScanEventType_IsValid(int value) {
    return ScanEvent_ScanEventType_IsValid(value);
  }
  static constexpr ScanEventType ScanEventType_MIN =
    ScanEvent_ScanEventType_ScanEventType_MIN;
  static constexpr ScanEventType ScanEventType_MAX =
    ScanEvent_ScanEventType_ScanEventType_MAX;
  static constexpr int ScanEventType_ARRAYSIZE =
    ScanEvent_ScanEventType_ScanEventType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& ScanEventType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ScanEventType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ScanEventType_Name.");
    return ScanEvent_ScanEventType_Name(enum_t_value);
  }
  static inline bool ScanEventType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ScanEventType* value) {
    return ScanEvent_ScanEventType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kInitiatorFieldNumber = 2,
    kScanEventTypeFieldNumber = 1,
    kScanTechnologyTypeFieldNumber = 3,
    kEventTimeMillisFieldNumber = 5,
    kNumberResultsFieldNumber = 4,
  };
  // optional string initiator = 2;
  bool has_initiator() const;
  private:
  bool _internal_has_initiator() const;
  public:
  void clear_initiator();
  const std::string& initiator() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_initiator(ArgT0&& arg0, ArgT... args);
  std::string* mutable_initiator();
  PROTOBUF_NODISCARD std::string* release_initiator();
  void set_allocated_initiator(std::string* initiator);
  private:
  const std::string& _internal_initiator() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_initiator(const std::string& value);
  std::string* _internal_mutable_initiator();
  public:

  // optional .bluetooth.metrics.BluetoothMetricsProto.ScanEvent.ScanEventType scan_event_type = 1;
  bool has_scan_event_type() const;
  private:
  bool _internal_has_scan_event_type() const;
  public:
  void clear_scan_event_type();
  ::bluetooth::metrics::BluetoothMetricsProto::ScanEvent_ScanEventType scan_event_type() const;
  void set_scan_event_type(::bluetooth::metrics::BluetoothMetricsProto::ScanEvent_ScanEventType value);
  private:
  ::bluetooth::metrics::BluetoothMetricsProto::ScanEvent_ScanEventType _internal_scan_event_type() const;
  void _internal_set_scan_event_type(::bluetooth::metrics::BluetoothMetricsProto::ScanEvent_ScanEventType value);
  public:

  // optional .bluetooth.metrics.BluetoothMetricsProto.ScanEvent.ScanTechnologyType scan_technology_type = 3;
  bool has_scan_technology_type() const;
  private:
  bool _internal_has_scan_technology_type() const;
  public:
  void clear_scan_technology_type();
  ::bluetooth::metrics::BluetoothMetricsProto::ScanEvent_ScanTechnologyType scan_technology_type() const;
  void set_scan_technology_type(::bluetooth::metrics::BluetoothMetricsProto::ScanEvent_ScanTechnologyType value);
  private:
  ::bluetooth::metrics::BluetoothMetricsProto::ScanEvent_ScanTechnologyType _internal_scan_technology_type() const;
  void _internal_set_scan_technology_type(::bluetooth::metrics::BluetoothMetricsProto::ScanEvent_ScanTechnologyType value);
  public:

  // optional int64 event_time_millis = 5;
  bool has_event_time_millis() const;
  private:
  bool _internal_has_event_time_millis() const;
  public:
  void clear_event_time_millis();
  ::int64_t event_time_millis() const;
  void set_event_time_millis(::int64_t value);
  private:
  ::int64_t _internal_event_time_millis() const;
  void _internal_set_event_time_millis(::int64_t value);
  public:

  // optional int32 number_results = 4;
  bool has_number_results() const;
  private:
  bool _internal_has_number_results() const;
  public:
  void clear_number_results();
  ::int32_t number_results() const;
  void set_number_results(::int32_t value);
  private:
  ::int32_t _internal_number_results() const;
  void _internal_set_number_results(::int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:bluetooth.metrics.BluetoothMetricsProto.ScanEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr initiator_;
    int scan_event_type_;
    int scan_technology_type_;
    ::int64_t event_time_millis_;
    ::int32_t number_results_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_packages_2fmodules_2fBluetooth_2fsystem_2fgd_2fproto_2fbluetooth_2fmetrics_2fbluetooth_2eproto;
};
// -------------------------------------------------------------------

class ProfileConnectionStats final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:bluetooth.metrics.BluetoothMetricsProto.ProfileConnectionStats) */ {
 public:
  inline ProfileConnectionStats() : ProfileConnectionStats(nullptr) {}
  ~ProfileConnectionStats() override;
  explicit PROTOBUF_CONSTEXPR ProfileConnectionStats(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProfileConnectionStats(const ProfileConnectionStats& from);
  ProfileConnectionStats(ProfileConnectionStats&& from) noexcept
    : ProfileConnectionStats() {
    *this = ::std::move(from);
  }

  inline ProfileConnectionStats& operator=(const ProfileConnectionStats& from) {
    if (this == &from) return *this;
    CopyFrom(from);
    return *this;
  }
  inline ProfileConnectionStats& operator=(ProfileConnectionStats&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ProfileConnectionStats& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProfileConnectionStats* internal_default_instance() {
    return reinterpret_cast<const ProfileConnectionStats*>(
               &_ProfileConnectionStats_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ProfileConnectionStats& a, ProfileConnectionStats& b) {
    a.Swap(&b);
  }
  inline void Swap(ProfileConnectionStats* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProfileConnectionStats* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProfileConnectionStats* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ProfileConnectionStats>(arena);
  }
  ProfileConnectionStats* New() const {
    return New(nullptr);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ProfileConnectionStats& from);
  void MergeFrom(const ProfileConnectionStats& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ProfileConnectionStats* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bluetooth.metrics.BluetoothMetricsProto.ProfileConnectionStats";
  }
  protected:
  explicit ProfileConnectionStats(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProfileIdFieldNumber = 1,
    kNumTimesConnectedFieldNumber = 2,
  };
  // optional .bluetooth.metrics.BluetoothMetricsProto.ProfileId profile_id = 1;
  bool has_profile_id() const;
  private:
  bool _internal_has_profile_id() const;
  public:
  void clear_profile_id();
  ::bluetooth::metrics::BluetoothMetricsProto::ProfileId profile_id() const;
  void set_profile_id(::bluetooth::metrics::BluetoothMetricsProto::ProfileId value);
  private:
  ::bluetooth::metrics::BluetoothMetricsProto::ProfileId _internal_profile_id() const;
  void _internal_set_profile_id(::bluetooth::metrics::BluetoothMetricsProto::ProfileId value);
  public:

  // optional int32 num_times_connected = 2;
  bool has_num_times_connected() const;
  private:
  bool _internal_has_num_times_connected() const;
  public:
  void clear_num_times_connected();
  ::int32_t num_times_connected() const;
  void set_num_times_connected(::int32_t value);
  private:
  ::int32_t _internal_num_times_connected() const;
  void _internal_set_num_times_connected(::int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:bluetooth.metrics.BluetoothMetricsProto.ProfileConnectionStats)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int profile_id_;
    ::int32_t num_times_connected_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_packages_2fmodules_2fBluetooth_2fsystem_2fgd_2fproto_2fbluetooth_2fmetrics_2fbluetooth_2eproto;
};
// -------------------------------------------------------------------

class HeadsetProfileConnectionStats final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:bluetooth.metrics.BluetoothMetricsProto.HeadsetProfileConnectionStats) */ {
 public:
  inline HeadsetProfileConnectionStats() : HeadsetProfileConnectionStats(nullptr) {}
  ~HeadsetProfileConnectionStats() override;
  explicit PROTOBUF_CONSTEXPR HeadsetProfileConnectionStats(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HeadsetProfileConnectionStats(const HeadsetProfileConnectionStats& from);
  HeadsetProfileConnectionStats(HeadsetProfileConnectionStats&& from) noexcept
    : HeadsetProfileConnectionStats() {
    *this = ::std::move(from);
  }

  inline HeadsetProfileConnectionStats& operator=(const HeadsetProfileConnectionStats& from) {
    if (this == &from) return *this;
    CopyFrom(from);
    return *this;
  }
  inline HeadsetProfileConnectionStats& operator=(HeadsetProfileConnectionStats&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const HeadsetProfileConnectionStats& default_instance() {
    return *internal_default_instance();
  }
  static inline const HeadsetProfileConnectionStats* internal_default_instance() {
    return reinterpret_cast<const HeadsetProfileConnectionStats*>(
               &_HeadsetProfileConnectionStats_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(HeadsetProfileConnectionStats& a, HeadsetProfileConnectionStats& b) {
    a.Swap(&b);
  }
  inline void Swap(HeadsetProfileConnectionStats* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HeadsetProfileConnectionStats* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HeadsetProfileConnectionStats* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HeadsetProfileConnectionStats>(arena);
  }
  HeadsetProfileConnectionStats* New() const {
    return New(nullptr);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const HeadsetProfileConnectionStats& from);
  void MergeFrom(const HeadsetProfileConnectionStats& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(HeadsetProfileConnectionStats* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bluetooth.metrics.BluetoothMetricsProto.HeadsetProfileConnectionStats";
  }
  protected:
  explicit HeadsetProfileConnectionStats(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeadsetProfileTypeFieldNumber = 1,
    kNumTimesConnectedFieldNumber = 2,
  };
  // optional .bluetooth.metrics.BluetoothMetricsProto.HeadsetProfileType headset_profile_type = 1;
  bool has_headset_profile_type() const;
  private:
  bool _internal_has_headset_profile_type() const;
  public:
  void clear_headset_profile_type();
  ::bluetooth::metrics::BluetoothMetricsProto::HeadsetProfileType headset_profile_type() const;
  void set_headset_profile_type(::bluetooth::metrics::BluetoothMetricsProto::HeadsetProfileType value);
  private:
  ::bluetooth::metrics::BluetoothMetricsProto::HeadsetProfileType _internal_headset_profile_type() const;
  void _internal_set_headset_profile_type(::bluetooth::metrics::BluetoothMetricsProto::HeadsetProfileType value);
  public:

  // optional int32 num_times_connected = 2;
  bool has_num_times_connected() const;
  private:
  bool _internal_has_num_times_connected() const;
  public:
  void clear_num_times_connected();
  ::int32_t num_times_connected() const;
  void set_num_times_connected(::int32_t value);
  private:
  ::int32_t _internal_num_times_connected() const;
  void _internal_set_num_times_connected(::int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:bluetooth.metrics.BluetoothMetricsProto.HeadsetProfileConnectionStats)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int headset_profile_type_;
    ::int32_t num_times_connected_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_packages_2fmodules_2fBluetooth_2fsystem_2fgd_2fproto_2fbluetooth_2fmetrics_2fbluetooth_2eproto;
};
// -------------------------------------------------------------------

class BluetoothRemoteDeviceInformation final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:bluetooth.metrics.BluetoothMetricsProto.BluetoothRemoteDeviceInformation) */ {
 public:
  inline BluetoothRemoteDeviceInformation() : BluetoothRemoteDeviceInformation(nullptr) {}
  ~BluetoothRemoteDeviceInformation() override;
  explicit PROTOBUF_CONSTEXPR BluetoothRemoteDeviceInformation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BluetoothRemoteDeviceInformation(const BluetoothRemoteDeviceInformation& from);
  BluetoothRemoteDeviceInformation(BluetoothRemoteDeviceInformation&& from) noexcept
    : BluetoothRemoteDeviceInformation() {
    *this = ::std::move(from);
  }

  inline BluetoothRemoteDeviceInformation& operator=(const BluetoothRemoteDeviceInformation& from) {
    if (this == &from) return *this;
    CopyFrom(from);
    return *this;
  }
  inline BluetoothRemoteDeviceInformation& operator=(BluetoothRemoteDeviceInformation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const BluetoothRemoteDeviceInformation& default_instance() {
    return *internal_default_instance();
  }
  static inline const BluetoothRemoteDeviceInformation* internal_default_instance() {
    return reinterpret_cast<const BluetoothRemoteDeviceInformation*>(
               &_BluetoothRemoteDeviceInformation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(BluetoothRemoteDeviceInformation& a, BluetoothRemoteDeviceInformation& b) {
    a.Swap(&b);
  }
  inline void Swap(BluetoothRemoteDeviceInformation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BluetoothRemoteDeviceInformation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BluetoothRemoteDeviceInformation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BluetoothRemoteDeviceInformation>(arena);
  }
  BluetoothRemoteDeviceInformation* New() const {
    return New(nullptr);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const BluetoothRemoteDeviceInformation& from);
  void MergeFrom(const BluetoothRemoteDeviceInformation& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BluetoothRemoteDeviceInformation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bluetooth.metrics.BluetoothMetricsProto.BluetoothRemoteDeviceInformation";
  }
  protected:
  explicit BluetoothRemoteDeviceInformation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAllowlistedDeviceNameHashFieldNumber = 1,
    kClassOfDeviceFieldNumber = 2,
    kOuiFieldNumber = 3,
  };
  // optional string allowlisted_device_name_hash = 1;
  bool has_allowlisted_device_name_hash() const;
  private:
  bool _internal_has_allowlisted_device_name_hash() const;
  public:
  void clear_allowlisted_device_name_hash();
  const std::string& allowlisted_device_name_hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_allowlisted_device_name_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_allowlisted_device_name_hash();
  PROTOBUF_NODISCARD std::string* release_allowlisted_device_name_hash();
  void set_allocated_allowlisted_device_name_hash(std::string* allowlisted_device_name_hash);
  private:
  const std::string& _internal_allowlisted_device_name_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_allowlisted_device_name_hash(const std::string& value);
  std::string* _internal_mutable_allowlisted_device_name_hash();
  public:

  // optional int32 class_of_device = 2;
  bool has_class_of_device() const;
  private:
  bool _internal_has_class_of_device() const;
  public:
  void clear_class_of_device();
  ::int32_t class_of_device() const;
  void set_class_of_device(::int32_t value);
  private:
  ::int32_t _internal_class_of_device() const;
  void _internal_set_class_of_device(::int32_t value);
  public:

  // optional int32 oui = 3;
  bool has_oui() const;
  private:
  bool _internal_has_oui() const;
  public:
  void clear_oui();
  ::int32_t oui() const;
  void set_oui(::int32_t value);
  private:
  ::int32_t _internal_oui() const;
  void _internal_set_oui(::int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:bluetooth.metrics.BluetoothMetricsProto.BluetoothRemoteDeviceInformation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr allowlisted_device_name_hash_;
    ::int32_t class_of_device_;
    ::int32_t oui_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_packages_2fmodules_2fBluetooth_2fsystem_2fgd_2fproto_2fbluetooth_2fmetrics_2fbluetooth_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// BluetoothLog

// repeated .bluetooth.metrics.BluetoothMetricsProto.BluetoothSession session = 1;
inline int BluetoothLog::_internal_session_size() const {
  return _impl_.session_.size();
}
inline int BluetoothLog::session_size() const {
  return _internal_session_size();
}
inline void BluetoothLog::clear_session() {
  _impl_.session_.Clear();
}
inline ::bluetooth::metrics::BluetoothMetricsProto::BluetoothSession* BluetoothLog::mutable_session(int index) {
  // @@protoc_insertion_point(field_mutable:bluetooth.metrics.BluetoothMetricsProto.BluetoothLog.session)
  return _impl_.session_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bluetooth::metrics::BluetoothMetricsProto::BluetoothSession >*
BluetoothLog::mutable_session() {
  // @@protoc_insertion_point(field_mutable_list:bluetooth.metrics.BluetoothMetricsProto.BluetoothLog.session)
  return &_impl_.session_;
}
inline const ::bluetooth::metrics::BluetoothMetricsProto::BluetoothSession& BluetoothLog::_internal_session(int index) const {
  return _impl_.session_.Get(index);
}
inline const ::bluetooth::metrics::BluetoothMetricsProto::BluetoothSession& BluetoothLog::session(int index) const {
  // @@protoc_insertion_point(field_get:bluetooth.metrics.BluetoothMetricsProto.BluetoothLog.session)
  return _internal_session(index);
}
inline ::bluetooth::metrics::BluetoothMetricsProto::BluetoothSession* BluetoothLog::_internal_add_session() {
  return _impl_.session_.Add();
}
inline ::bluetooth::metrics::BluetoothMetricsProto::BluetoothSession* BluetoothLog::add_session() {
  ::bluetooth::metrics::BluetoothMetricsProto::BluetoothSession* _add = _internal_add_session();
  // @@protoc_insertion_point(field_add:bluetooth.metrics.BluetoothMetricsProto.BluetoothLog.session)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bluetooth::metrics::BluetoothMetricsProto::BluetoothSession >&
BluetoothLog::session() const {
  // @@protoc_insertion_point(field_list:bluetooth.metrics.BluetoothMetricsProto.BluetoothLog.session)
  return _impl_.session_;
}

// repeated .bluetooth.metrics.BluetoothMetricsProto.PairEvent pair_event = 2;
inline int BluetoothLog::_internal_pair_event_size() const {
  return _impl_.pair_event_.size();
}
inline int BluetoothLog::pair_event_size() const {
  return _internal_pair_event_size();
}
inline void BluetoothLog::clear_pair_event() {
  _impl_.pair_event_.Clear();
}
inline ::bluetooth::metrics::BluetoothMetricsProto::PairEvent* BluetoothLog::mutable_pair_event(int index) {
  // @@protoc_insertion_point(field_mutable:bluetooth.metrics.BluetoothMetricsProto.BluetoothLog.pair_event)
  return _impl_.pair_event_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bluetooth::metrics::BluetoothMetricsProto::PairEvent >*
BluetoothLog::mutable_pair_event() {
  // @@protoc_insertion_point(field_mutable_list:bluetooth.metrics.BluetoothMetricsProto.BluetoothLog.pair_event)
  return &_impl_.pair_event_;
}
inline const ::bluetooth::metrics::BluetoothMetricsProto::PairEvent& BluetoothLog::_internal_pair_event(int index) const {
  return _impl_.pair_event_.Get(index);
}
inline const ::bluetooth::metrics::BluetoothMetricsProto::PairEvent& BluetoothLog::pair_event(int index) const {
  // @@protoc_insertion_point(field_get:bluetooth.metrics.BluetoothMetricsProto.BluetoothLog.pair_event)
  return _internal_pair_event(index);
}
inline ::bluetooth::metrics::BluetoothMetricsProto::PairEvent* BluetoothLog::_internal_add_pair_event() {
  return _impl_.pair_event_.Add();
}
inline ::bluetooth::metrics::BluetoothMetricsProto::PairEvent* BluetoothLog::add_pair_event() {
  ::bluetooth::metrics::BluetoothMetricsProto::PairEvent* _add = _internal_add_pair_event();
  // @@protoc_insertion_point(field_add:bluetooth.metrics.BluetoothMetricsProto.BluetoothLog.pair_event)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bluetooth::metrics::BluetoothMetricsProto::PairEvent >&
BluetoothLog::pair_event() const {
  // @@protoc_insertion_point(field_list:bluetooth.metrics.BluetoothMetricsProto.BluetoothLog.pair_event)
  return _impl_.pair_event_;
}

// repeated .bluetooth.metrics.BluetoothMetricsProto.WakeEvent wake_event = 3;
inline int BluetoothLog::_internal_wake_event_size() const {
  return _impl_.wake_event_.size();
}
inline int BluetoothLog::wake_event_size() const {
  return _internal_wake_event_size();
}
inline void BluetoothLog::clear_wake_event() {
  _impl_.wake_event_.Clear();
}
inline ::bluetooth::metrics::BluetoothMetricsProto::WakeEvent* BluetoothLog::mutable_wake_event(int index) {
  // @@protoc_insertion_point(field_mutable:bluetooth.metrics.BluetoothMetricsProto.BluetoothLog.wake_event)
  return _impl_.wake_event_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bluetooth::metrics::BluetoothMetricsProto::WakeEvent >*
BluetoothLog::mutable_wake_event() {
  // @@protoc_insertion_point(field_mutable_list:bluetooth.metrics.BluetoothMetricsProto.BluetoothLog.wake_event)
  return &_impl_.wake_event_;
}
inline const ::bluetooth::metrics::BluetoothMetricsProto::WakeEvent& BluetoothLog::_internal_wake_event(int index) const {
  return _impl_.wake_event_.Get(index);
}
inline const ::bluetooth::metrics::BluetoothMetricsProto::WakeEvent& BluetoothLog::wake_event(int index) const {
  // @@protoc_insertion_point(field_get:bluetooth.metrics.BluetoothMetricsProto.BluetoothLog.wake_event)
  return _internal_wake_event(index);
}
inline ::bluetooth::metrics::BluetoothMetricsProto::WakeEvent* BluetoothLog::_internal_add_wake_event() {
  return _impl_.wake_event_.Add();
}
inline ::bluetooth::metrics::BluetoothMetricsProto::WakeEvent* BluetoothLog::add_wake_event() {
  ::bluetooth::metrics::BluetoothMetricsProto::WakeEvent* _add = _internal_add_wake_event();
  // @@protoc_insertion_point(field_add:bluetooth.metrics.BluetoothMetricsProto.BluetoothLog.wake_event)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bluetooth::metrics::BluetoothMetricsProto::WakeEvent >&
BluetoothLog::wake_event() const {
  // @@protoc_insertion_point(field_list:bluetooth.metrics.BluetoothMetricsProto.BluetoothLog.wake_event)
  return _impl_.wake_event_;
}

// repeated .bluetooth.metrics.BluetoothMetricsProto.ScanEvent scan_event = 4;
inline int BluetoothLog::_internal_scan_event_size() const {
  return _impl_.scan_event_.size();
}
inline int BluetoothLog::scan_event_size() const {
  return _internal_scan_event_size();
}
inline void BluetoothLog::clear_scan_event() {
  _impl_.scan_event_.Clear();
}
inline ::bluetooth::metrics::BluetoothMetricsProto::ScanEvent* BluetoothLog::mutable_scan_event(int index) {
  // @@protoc_insertion_point(field_mutable:bluetooth.metrics.BluetoothMetricsProto.BluetoothLog.scan_event)
  return _impl_.scan_event_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bluetooth::metrics::BluetoothMetricsProto::ScanEvent >*
BluetoothLog::mutable_scan_event() {
  // @@protoc_insertion_point(field_mutable_list:bluetooth.metrics.BluetoothMetricsProto.BluetoothLog.scan_event)
  return &_impl_.scan_event_;
}
inline const ::bluetooth::metrics::BluetoothMetricsProto::ScanEvent& BluetoothLog::_internal_scan_event(int index) const {
  return _impl_.scan_event_.Get(index);
}
inline const ::bluetooth::metrics::BluetoothMetricsProto::ScanEvent& BluetoothLog::scan_event(int index) const {
  // @@protoc_insertion_point(field_get:bluetooth.metrics.BluetoothMetricsProto.BluetoothLog.scan_event)
  return _internal_scan_event(index);
}
inline ::bluetooth::metrics::BluetoothMetricsProto::ScanEvent* BluetoothLog::_internal_add_scan_event() {
  return _impl_.scan_event_.Add();
}
inline ::bluetooth::metrics::BluetoothMetricsProto::ScanEvent* BluetoothLog::add_scan_event() {
  ::bluetooth::metrics::BluetoothMetricsProto::ScanEvent* _add = _internal_add_scan_event();
  // @@protoc_insertion_point(field_add:bluetooth.metrics.BluetoothMetricsProto.BluetoothLog.scan_event)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bluetooth::metrics::BluetoothMetricsProto::ScanEvent >&
BluetoothLog::scan_event() const {
  // @@protoc_insertion_point(field_list:bluetooth.metrics.BluetoothMetricsProto.BluetoothLog.scan_event)
  return _impl_.scan_event_;
}

// optional int32 num_bonded_devices = 5;
inline bool BluetoothLog::_internal_has_num_bonded_devices() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool BluetoothLog::has_num_bonded_devices() const {
  return _internal_has_num_bonded_devices();
}
inline void BluetoothLog::clear_num_bonded_devices() {
  _impl_.num_bonded_devices_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int32_t BluetoothLog::_internal_num_bonded_devices() const {
  return _impl_.num_bonded_devices_;
}
inline ::int32_t BluetoothLog::num_bonded_devices() const {
  // @@protoc_insertion_point(field_get:bluetooth.metrics.BluetoothMetricsProto.BluetoothLog.num_bonded_devices)
  return _internal_num_bonded_devices();
}
inline void BluetoothLog::_internal_set_num_bonded_devices(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.num_bonded_devices_ = value;
}
inline void BluetoothLog::set_num_bonded_devices(::int32_t value) {
  _internal_set_num_bonded_devices(value);
  // @@protoc_insertion_point(field_set:bluetooth.metrics.BluetoothMetricsProto.BluetoothLog.num_bonded_devices)
}

// optional int64 num_bluetooth_session = 6;
inline bool BluetoothLog::_internal_has_num_bluetooth_session() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BluetoothLog::has_num_bluetooth_session() const {
  return _internal_has_num_bluetooth_session();
}
inline void BluetoothLog::clear_num_bluetooth_session() {
  _impl_.num_bluetooth_session_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int64_t BluetoothLog::_internal_num_bluetooth_session() const {
  return _impl_.num_bluetooth_session_;
}
inline ::int64_t BluetoothLog::num_bluetooth_session() const {
  // @@protoc_insertion_point(field_get:bluetooth.metrics.BluetoothMetricsProto.BluetoothLog.num_bluetooth_session)
  return _internal_num_bluetooth_session();
}
inline void BluetoothLog::_internal_set_num_bluetooth_session(::int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.num_bluetooth_session_ = value;
}
inline void BluetoothLog::set_num_bluetooth_session(::int64_t value) {
  _internal_set_num_bluetooth_session(value);
  // @@protoc_insertion_point(field_set:bluetooth.metrics.BluetoothMetricsProto.BluetoothLog.num_bluetooth_session)
}

// optional int64 num_pair_event = 7;
inline bool BluetoothLog::_internal_has_num_pair_event() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool BluetoothLog::has_num_pair_event() const {
  return _internal_has_num_pair_event();
}
inline void BluetoothLog::clear_num_pair_event() {
  _impl_.num_pair_event_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int64_t BluetoothLog::_internal_num_pair_event() const {
  return _impl_.num_pair_event_;
}
inline ::int64_t BluetoothLog::num_pair_event() const {
  // @@protoc_insertion_point(field_get:bluetooth.metrics.BluetoothMetricsProto.BluetoothLog.num_pair_event)
  return _internal_num_pair_event();
}
inline void BluetoothLog::_internal_set_num_pair_event(::int64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.num_pair_event_ = value;
}
inline void BluetoothLog::set_num_pair_event(::int64_t value) {
  _internal_set_num_pair_event(value);
  // @@protoc_insertion_point(field_set:bluetooth.metrics.BluetoothMetricsProto.BluetoothLog.num_pair_event)
}

// optional int64 num_wake_event = 8;
inline bool BluetoothLog::_internal_has_num_wake_event() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool BluetoothLog::has_num_wake_event() const {
  return _internal_has_num_wake_event();
}
inline void BluetoothLog::clear_num_wake_event() {
  _impl_.num_wake_event_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int64_t BluetoothLog::_internal_num_wake_event() const {
  return _impl_.num_wake_event_;
}
inline ::int64_t BluetoothLog::num_wake_event() const {
  // @@protoc_insertion_point(field_get:bluetooth.metrics.BluetoothMetricsProto.BluetoothLog.num_wake_event)
  return _internal_num_wake_event();
}
inline void BluetoothLog::_internal_set_num_wake_event(::int64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.num_wake_event_ = value;
}
inline void BluetoothLog::set_num_wake_event(::int64_t value) {
  _internal_set_num_wake_event(value);
  // @@protoc_insertion_point(field_set:bluetooth.metrics.BluetoothMetricsProto.BluetoothLog.num_wake_event)
}

// optional int64 num_scan_event = 9;
inline bool BluetoothLog::_internal_has_num_scan_event() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool BluetoothLog::has_num_scan_event() const {
  return _internal_has_num_scan_event();
}
inline void BluetoothLog::clear_num_scan_event() {
  _impl_.num_scan_event_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int64_t BluetoothLog::_internal_num_scan_event() const {
  return _impl_.num_scan_event_;
}
inline ::int64_t BluetoothLog::num_scan_event() const {
  // @@protoc_insertion_point(field_get:bluetooth.metrics.BluetoothMetricsProto.BluetoothLog.num_scan_event)
  return _internal_num_scan_event();
}
inline void BluetoothLog::_internal_set_num_scan_event(::int64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.num_scan_event_ = value;
}
inline void BluetoothLog::set_num_scan_event(::int64_t value) {
  _internal_set_num_scan_event(value);
  // @@protoc_insertion_point(field_set:bluetooth.metrics.BluetoothMetricsProto.BluetoothLog.num_scan_event)
}

// repeated .bluetooth.metrics.BluetoothMetricsProto.ProfileConnectionStats profile_connection_stats = 10;
inline int BluetoothLog::_internal_profile_connection_stats_size() const {
  return _impl_.profile_connection_stats_.size();
}
inline int BluetoothLog::profile_connection_stats_size() const {
  return _internal_profile_connection_stats_size();
}
inline void BluetoothLog::clear_profile_connection_stats() {
  _impl_.profile_connection_stats_.Clear();
}
inline ::bluetooth::metrics::BluetoothMetricsProto::ProfileConnectionStats* BluetoothLog::mutable_profile_connection_stats(int index) {
  // @@protoc_insertion_point(field_mutable:bluetooth.metrics.BluetoothMetricsProto.BluetoothLog.profile_connection_stats)
  return _impl_.profile_connection_stats_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bluetooth::metrics::BluetoothMetricsProto::ProfileConnectionStats >*
BluetoothLog::mutable_profile_connection_stats() {
  // @@protoc_insertion_point(field_mutable_list:bluetooth.metrics.BluetoothMetricsProto.BluetoothLog.profile_connection_stats)
  return &_impl_.profile_connection_stats_;
}
inline const ::bluetooth::metrics::BluetoothMetricsProto::ProfileConnectionStats& BluetoothLog::_internal_profile_connection_stats(int index) const {
  return _impl_.profile_connection_stats_.Get(index);
}
inline const ::bluetooth::metrics::BluetoothMetricsProto::ProfileConnectionStats& BluetoothLog::profile_connection_stats(int index) const {
  // @@protoc_insertion_point(field_get:bluetooth.metrics.BluetoothMetricsProto.BluetoothLog.profile_connection_stats)
  return _internal_profile_connection_stats(index);
}
inline ::bluetooth::metrics::BluetoothMetricsProto::ProfileConnectionStats* BluetoothLog::_internal_add_profile_connection_stats() {
  return _impl_.profile_connection_stats_.Add();
}
inline ::bluetooth::metrics::BluetoothMetricsProto::ProfileConnectionStats* BluetoothLog::add_profile_connection_stats() {
  ::bluetooth::metrics::BluetoothMetricsProto::ProfileConnectionStats* _add = _internal_add_profile_connection_stats();
  // @@protoc_insertion_point(field_add:bluetooth.metrics.BluetoothMetricsProto.BluetoothLog.profile_connection_stats)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bluetooth::metrics::BluetoothMetricsProto::ProfileConnectionStats >&
BluetoothLog::profile_connection_stats() const {
  // @@protoc_insertion_point(field_list:bluetooth.metrics.BluetoothMetricsProto.BluetoothLog.profile_connection_stats)
  return _impl_.profile_connection_stats_;
}

// repeated .bluetooth.metrics.BluetoothMetricsProto.HeadsetProfileConnectionStats headset_profile_connection_stats = 11;
inline int BluetoothLog::_internal_headset_profile_connection_stats_size() const {
  return _impl_.headset_profile_connection_stats_.size();
}
inline int BluetoothLog::headset_profile_connection_stats_size() const {
  return _internal_headset_profile_connection_stats_size();
}
inline void BluetoothLog::clear_headset_profile_connection_stats() {
  _impl_.headset_profile_connection_stats_.Clear();
}
inline ::bluetooth::metrics::BluetoothMetricsProto::HeadsetProfileConnectionStats* BluetoothLog::mutable_headset_profile_connection_stats(int index) {
  // @@protoc_insertion_point(field_mutable:bluetooth.metrics.BluetoothMetricsProto.BluetoothLog.headset_profile_connection_stats)
  return _impl_.headset_profile_connection_stats_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bluetooth::metrics::BluetoothMetricsProto::HeadsetProfileConnectionStats >*
BluetoothLog::mutable_headset_profile_connection_stats() {
  // @@protoc_insertion_point(field_mutable_list:bluetooth.metrics.BluetoothMetricsProto.BluetoothLog.headset_profile_connection_stats)
  return &_impl_.headset_profile_connection_stats_;
}
inline const ::bluetooth::metrics::BluetoothMetricsProto::HeadsetProfileConnectionStats& BluetoothLog::_internal_headset_profile_connection_stats(int index) const {
  return _impl_.headset_profile_connection_stats_.Get(index);
}
inline const ::bluetooth::metrics::BluetoothMetricsProto::HeadsetProfileConnectionStats& BluetoothLog::headset_profile_connection_stats(int index) const {
  // @@protoc_insertion_point(field_get:bluetooth.metrics.BluetoothMetricsProto.BluetoothLog.headset_profile_connection_stats)
  return _internal_headset_profile_connection_stats(index);
}
inline ::bluetooth::metrics::BluetoothMetricsProto::HeadsetProfileConnectionStats* BluetoothLog::_internal_add_headset_profile_connection_stats() {
  return _impl_.headset_profile_connection_stats_.Add();
}
inline ::bluetooth::metrics::BluetoothMetricsProto::HeadsetProfileConnectionStats* BluetoothLog::add_headset_profile_connection_stats() {
  ::bluetooth::metrics::BluetoothMetricsProto::HeadsetProfileConnectionStats* _add = _internal_add_headset_profile_connection_stats();
  // @@protoc_insertion_point(field_add:bluetooth.metrics.BluetoothMetricsProto.BluetoothLog.headset_profile_connection_stats)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bluetooth::metrics::BluetoothMetricsProto::HeadsetProfileConnectionStats >&
BluetoothLog::headset_profile_connection_stats() const {
  // @@protoc_insertion_point(field_list:bluetooth.metrics.BluetoothMetricsProto.BluetoothLog.headset_profile_connection_stats)
  return _impl_.headset_profile_connection_stats_;
}

// -------------------------------------------------------------------

// DeviceInfo

// optional int32 device_class = 1;
inline bool DeviceInfo::_internal_has_device_class() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DeviceInfo::has_device_class() const {
  return _internal_has_device_class();
}
inline void DeviceInfo::clear_device_class() {
  _impl_.device_class_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t DeviceInfo::_internal_device_class() const {
  return _impl_.device_class_;
}
inline ::int32_t DeviceInfo::device_class() const {
  // @@protoc_insertion_point(field_get:bluetooth.metrics.BluetoothMetricsProto.DeviceInfo.device_class)
  return _internal_device_class();
}
inline void DeviceInfo::_internal_set_device_class(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.device_class_ = value;
}
inline void DeviceInfo::set_device_class(::int32_t value) {
  _internal_set_device_class(value);
  // @@protoc_insertion_point(field_set:bluetooth.metrics.BluetoothMetricsProto.DeviceInfo.device_class)
}

// optional .bluetooth.metrics.BluetoothMetricsProto.DeviceInfo.DeviceType device_type = 2;
inline bool DeviceInfo::_internal_has_device_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DeviceInfo::has_device_type() const {
  return _internal_has_device_type();
}
inline void DeviceInfo::clear_device_type() {
  _impl_.device_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo_DeviceType DeviceInfo::_internal_device_type() const {
  return static_cast< ::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo_DeviceType >(_impl_.device_type_);
}
inline ::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo_DeviceType DeviceInfo::device_type() const {
  // @@protoc_insertion_point(field_get:bluetooth.metrics.BluetoothMetricsProto.DeviceInfo.device_type)
  return _internal_device_type();
}
inline void DeviceInfo::_internal_set_device_type(::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo_DeviceType value) {
  assert(::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo_DeviceType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.device_type_ = value;
}
inline void DeviceInfo::set_device_type(::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo_DeviceType value) {
  _internal_set_device_type(value);
  // @@protoc_insertion_point(field_set:bluetooth.metrics.BluetoothMetricsProto.DeviceInfo.device_type)
}

// -------------------------------------------------------------------

// BluetoothSession

// optional int64 session_duration_sec = 2;
inline bool BluetoothSession::_internal_has_session_duration_sec() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool BluetoothSession::has_session_duration_sec() const {
  return _internal_has_session_duration_sec();
}
inline void BluetoothSession::clear_session_duration_sec() {
  _impl_.session_duration_sec_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int64_t BluetoothSession::_internal_session_duration_sec() const {
  return _impl_.session_duration_sec_;
}
inline ::int64_t BluetoothSession::session_duration_sec() const {
  // @@protoc_insertion_point(field_get:bluetooth.metrics.BluetoothMetricsProto.BluetoothSession.session_duration_sec)
  return _internal_session_duration_sec();
}
inline void BluetoothSession::_internal_set_session_duration_sec(::int64_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.session_duration_sec_ = value;
}
inline void BluetoothSession::set_session_duration_sec(::int64_t value) {
  _internal_set_session_duration_sec(value);
  // @@protoc_insertion_point(field_set:bluetooth.metrics.BluetoothMetricsProto.BluetoothSession.session_duration_sec)
}

// optional .bluetooth.metrics.BluetoothMetricsProto.BluetoothSession.ConnectionTechnologyType connection_technology_type = 3;
inline bool BluetoothSession::_internal_has_connection_technology_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool BluetoothSession::has_connection_technology_type() const {
  return _internal_has_connection_technology_type();
}
inline void BluetoothSession::clear_connection_technology_type() {
  _impl_.connection_technology_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::bluetooth::metrics::BluetoothMetricsProto::BluetoothSession_ConnectionTechnologyType BluetoothSession::_internal_connection_technology_type() const {
  return static_cast< ::bluetooth::metrics::BluetoothMetricsProto::BluetoothSession_ConnectionTechnologyType >(_impl_.connection_technology_type_);
}
inline ::bluetooth::metrics::BluetoothMetricsProto::BluetoothSession_ConnectionTechnologyType BluetoothSession::connection_technology_type() const {
  // @@protoc_insertion_point(field_get:bluetooth.metrics.BluetoothMetricsProto.BluetoothSession.connection_technology_type)
  return _internal_connection_technology_type();
}
inline void BluetoothSession::_internal_set_connection_technology_type(::bluetooth::metrics::BluetoothMetricsProto::BluetoothSession_ConnectionTechnologyType value) {
  assert(::bluetooth::metrics::BluetoothMetricsProto::BluetoothSession_ConnectionTechnologyType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.connection_technology_type_ = value;
}
inline void BluetoothSession::set_connection_technology_type(::bluetooth::metrics::BluetoothMetricsProto::BluetoothSession_ConnectionTechnologyType value) {
  _internal_set_connection_technology_type(value);
  // @@protoc_insertion_point(field_set:bluetooth.metrics.BluetoothMetricsProto.BluetoothSession.connection_technology_type)
}

// optional string disconnect_reason = 4 [deprecated = true];
inline bool BluetoothSession::_internal_has_disconnect_reason() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BluetoothSession::has_disconnect_reason() const {
  return _internal_has_disconnect_reason();
}
inline void BluetoothSession::clear_disconnect_reason() {
  _impl_.disconnect_reason_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BluetoothSession::disconnect_reason() const {
  // @@protoc_insertion_point(field_get:bluetooth.metrics.BluetoothMetricsProto.BluetoothSession.disconnect_reason)
  return _internal_disconnect_reason();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BluetoothSession::set_disconnect_reason(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.disconnect_reason_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bluetooth.metrics.BluetoothMetricsProto.BluetoothSession.disconnect_reason)
}
inline std::string* BluetoothSession::mutable_disconnect_reason() {
  std::string* _s = _internal_mutable_disconnect_reason();
  // @@protoc_insertion_point(field_mutable:bluetooth.metrics.BluetoothMetricsProto.BluetoothSession.disconnect_reason)
  return _s;
}
inline const std::string& BluetoothSession::_internal_disconnect_reason() const {
  return _impl_.disconnect_reason_.Get();
}
inline void BluetoothSession::_internal_set_disconnect_reason(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.disconnect_reason_.Set(value, GetArenaForAllocation());
}
inline std::string* BluetoothSession::_internal_mutable_disconnect_reason() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.disconnect_reason_.Mutable(GetArenaForAllocation());
}
inline std::string* BluetoothSession::release_disconnect_reason() {
  // @@protoc_insertion_point(field_release:bluetooth.metrics.BluetoothMetricsProto.BluetoothSession.disconnect_reason)
  if (!_internal_has_disconnect_reason()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.disconnect_reason_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.disconnect_reason_.IsDefault()) {
    _impl_.disconnect_reason_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void BluetoothSession::set_allocated_disconnect_reason(std::string* disconnect_reason) {
  if (disconnect_reason != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.disconnect_reason_.SetAllocated(disconnect_reason, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.disconnect_reason_.IsDefault()) {
    _impl_.disconnect_reason_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bluetooth.metrics.BluetoothMetricsProto.BluetoothSession.disconnect_reason)
}

// optional .bluetooth.metrics.BluetoothMetricsProto.DeviceInfo device_connected_to = 5;
inline bool BluetoothSession::_internal_has_device_connected_to() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.device_connected_to_ != nullptr);
  return value;
}
inline bool BluetoothSession::has_device_connected_to() const {
  return _internal_has_device_connected_to();
}
inline void BluetoothSession::clear_device_connected_to() {
  if (_impl_.device_connected_to_ != nullptr) _impl_.device_connected_to_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo& BluetoothSession::_internal_device_connected_to() const {
  const ::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo* p = _impl_.device_connected_to_;
  return p != nullptr ? *p : reinterpret_cast<const ::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo&>(
      ::bluetooth::metrics::BluetoothMetricsProto::_DeviceInfo_default_instance_);
}
inline const ::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo& BluetoothSession::device_connected_to() const {
  // @@protoc_insertion_point(field_get:bluetooth.metrics.BluetoothMetricsProto.BluetoothSession.device_connected_to)
  return _internal_device_connected_to();
}
inline void BluetoothSession::unsafe_arena_set_allocated_device_connected_to(
    ::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo* device_connected_to) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_connected_to_);
  }
  _impl_.device_connected_to_ = device_connected_to;
  if (device_connected_to) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bluetooth.metrics.BluetoothMetricsProto.BluetoothSession.device_connected_to)
}
inline ::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo* BluetoothSession::release_device_connected_to() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo* temp = _impl_.device_connected_to_;
  _impl_.device_connected_to_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo* BluetoothSession::unsafe_arena_release_device_connected_to() {
  // @@protoc_insertion_point(field_release:bluetooth.metrics.BluetoothMetricsProto.BluetoothSession.device_connected_to)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo* temp = _impl_.device_connected_to_;
  _impl_.device_connected_to_ = nullptr;
  return temp;
}
inline ::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo* BluetoothSession::_internal_mutable_device_connected_to() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.device_connected_to_ == nullptr) {
    auto* p = CreateMaybeMessage<::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo>(GetArenaForAllocation());
    _impl_.device_connected_to_ = p;
  }
  return _impl_.device_connected_to_;
}
inline ::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo* BluetoothSession::mutable_device_connected_to() {
  ::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo* _msg = _internal_mutable_device_connected_to();
  // @@protoc_insertion_point(field_mutable:bluetooth.metrics.BluetoothMetricsProto.BluetoothSession.device_connected_to)
  return _msg;
}
inline void BluetoothSession::set_allocated_device_connected_to(::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo* device_connected_to) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.device_connected_to_;
  }
  if (device_connected_to) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(device_connected_to);
    if (message_arena != submessage_arena) {
      device_connected_to = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_connected_to, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.device_connected_to_ = device_connected_to;
  // @@protoc_insertion_point(field_set_allocated:bluetooth.metrics.BluetoothMetricsProto.BluetoothSession.device_connected_to)
}

// optional .bluetooth.metrics.BluetoothMetricsProto.RFCommSession rfcomm_session = 6;
inline bool BluetoothSession::_internal_has_rfcomm_session() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.rfcomm_session_ != nullptr);
  return value;
}
inline bool BluetoothSession::has_rfcomm_session() const {
  return _internal_has_rfcomm_session();
}
inline void BluetoothSession::clear_rfcomm_session() {
  if (_impl_.rfcomm_session_ != nullptr) _impl_.rfcomm_session_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::bluetooth::metrics::BluetoothMetricsProto::RFCommSession& BluetoothSession::_internal_rfcomm_session() const {
  const ::bluetooth::metrics::BluetoothMetricsProto::RFCommSession* p = _impl_.rfcomm_session_;
  return p != nullptr ? *p : reinterpret_cast<const ::bluetooth::metrics::BluetoothMetricsProto::RFCommSession&>(
      ::bluetooth::metrics::BluetoothMetricsProto::_RFCommSession_default_instance_);
}
inline const ::bluetooth::metrics::BluetoothMetricsProto::RFCommSession& BluetoothSession::rfcomm_session() const {
  // @@protoc_insertion_point(field_get:bluetooth.metrics.BluetoothMetricsProto.BluetoothSession.rfcomm_session)
  return _internal_rfcomm_session();
}
inline void BluetoothSession::unsafe_arena_set_allocated_rfcomm_session(
    ::bluetooth::metrics::BluetoothMetricsProto::RFCommSession* rfcomm_session) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.rfcomm_session_);
  }
  _impl_.rfcomm_session_ = rfcomm_session;
  if (rfcomm_session) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bluetooth.metrics.BluetoothMetricsProto.BluetoothSession.rfcomm_session)
}
inline ::bluetooth::metrics::BluetoothMetricsProto::RFCommSession* BluetoothSession::release_rfcomm_session() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::bluetooth::metrics::BluetoothMetricsProto::RFCommSession* temp = _impl_.rfcomm_session_;
  _impl_.rfcomm_session_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bluetooth::metrics::BluetoothMetricsProto::RFCommSession* BluetoothSession::unsafe_arena_release_rfcomm_session() {
  // @@protoc_insertion_point(field_release:bluetooth.metrics.BluetoothMetricsProto.BluetoothSession.rfcomm_session)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::bluetooth::metrics::BluetoothMetricsProto::RFCommSession* temp = _impl_.rfcomm_session_;
  _impl_.rfcomm_session_ = nullptr;
  return temp;
}
inline ::bluetooth::metrics::BluetoothMetricsProto::RFCommSession* BluetoothSession::_internal_mutable_rfcomm_session() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.rfcomm_session_ == nullptr) {
    auto* p = CreateMaybeMessage<::bluetooth::metrics::BluetoothMetricsProto::RFCommSession>(GetArenaForAllocation());
    _impl_.rfcomm_session_ = p;
  }
  return _impl_.rfcomm_session_;
}
inline ::bluetooth::metrics::BluetoothMetricsProto::RFCommSession* BluetoothSession::mutable_rfcomm_session() {
  ::bluetooth::metrics::BluetoothMetricsProto::RFCommSession* _msg = _internal_mutable_rfcomm_session();
  // @@protoc_insertion_point(field_mutable:bluetooth.metrics.BluetoothMetricsProto.BluetoothSession.rfcomm_session)
  return _msg;
}
inline void BluetoothSession::set_allocated_rfcomm_session(::bluetooth::metrics::BluetoothMetricsProto::RFCommSession* rfcomm_session) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.rfcomm_session_;
  }
  if (rfcomm_session) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(rfcomm_session);
    if (message_arena != submessage_arena) {
      rfcomm_session = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rfcomm_session, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.rfcomm_session_ = rfcomm_session;
  // @@protoc_insertion_point(field_set_allocated:bluetooth.metrics.BluetoothMetricsProto.BluetoothSession.rfcomm_session)
}

// optional .bluetooth.metrics.BluetoothMetricsProto.A2DPSession a2dp_session = 7;
inline bool BluetoothSession::_internal_has_a2dp_session() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.a2dp_session_ != nullptr);
  return value;
}
inline bool BluetoothSession::has_a2dp_session() const {
  return _internal_has_a2dp_session();
}
inline void BluetoothSession::clear_a2dp_session() {
  if (_impl_.a2dp_session_ != nullptr) _impl_.a2dp_session_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::bluetooth::metrics::BluetoothMetricsProto::A2DPSession& BluetoothSession::_internal_a2dp_session() const {
  const ::bluetooth::metrics::BluetoothMetricsProto::A2DPSession* p = _impl_.a2dp_session_;
  return p != nullptr ? *p : reinterpret_cast<const ::bluetooth::metrics::BluetoothMetricsProto::A2DPSession&>(
      ::bluetooth::metrics::BluetoothMetricsProto::_A2DPSession_default_instance_);
}
inline const ::bluetooth::metrics::BluetoothMetricsProto::A2DPSession& BluetoothSession::a2dp_session() const {
  // @@protoc_insertion_point(field_get:bluetooth.metrics.BluetoothMetricsProto.BluetoothSession.a2dp_session)
  return _internal_a2dp_session();
}
inline void BluetoothSession::unsafe_arena_set_allocated_a2dp_session(
    ::bluetooth::metrics::BluetoothMetricsProto::A2DPSession* a2dp_session) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.a2dp_session_);
  }
  _impl_.a2dp_session_ = a2dp_session;
  if (a2dp_session) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bluetooth.metrics.BluetoothMetricsProto.BluetoothSession.a2dp_session)
}
inline ::bluetooth::metrics::BluetoothMetricsProto::A2DPSession* BluetoothSession::release_a2dp_session() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::bluetooth::metrics::BluetoothMetricsProto::A2DPSession* temp = _impl_.a2dp_session_;
  _impl_.a2dp_session_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bluetooth::metrics::BluetoothMetricsProto::A2DPSession* BluetoothSession::unsafe_arena_release_a2dp_session() {
  // @@protoc_insertion_point(field_release:bluetooth.metrics.BluetoothMetricsProto.BluetoothSession.a2dp_session)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::bluetooth::metrics::BluetoothMetricsProto::A2DPSession* temp = _impl_.a2dp_session_;
  _impl_.a2dp_session_ = nullptr;
  return temp;
}
inline ::bluetooth::metrics::BluetoothMetricsProto::A2DPSession* BluetoothSession::_internal_mutable_a2dp_session() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.a2dp_session_ == nullptr) {
    auto* p = CreateMaybeMessage<::bluetooth::metrics::BluetoothMetricsProto::A2DPSession>(GetArenaForAllocation());
    _impl_.a2dp_session_ = p;
  }
  return _impl_.a2dp_session_;
}
inline ::bluetooth::metrics::BluetoothMetricsProto::A2DPSession* BluetoothSession::mutable_a2dp_session() {
  ::bluetooth::metrics::BluetoothMetricsProto::A2DPSession* _msg = _internal_mutable_a2dp_session();
  // @@protoc_insertion_point(field_mutable:bluetooth.metrics.BluetoothMetricsProto.BluetoothSession.a2dp_session)
  return _msg;
}
inline void BluetoothSession::set_allocated_a2dp_session(::bluetooth::metrics::BluetoothMetricsProto::A2DPSession* a2dp_session) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.a2dp_session_;
  }
  if (a2dp_session) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(a2dp_session);
    if (message_arena != submessage_arena) {
      a2dp_session = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, a2dp_session, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.a2dp_session_ = a2dp_session;
  // @@protoc_insertion_point(field_set_allocated:bluetooth.metrics.BluetoothMetricsProto.BluetoothSession.a2dp_session)
}

// optional .bluetooth.metrics.BluetoothMetricsProto.BluetoothSession.DisconnectReasonType disconnect_reason_type = 8;
inline bool BluetoothSession::_internal_has_disconnect_reason_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool BluetoothSession::has_disconnect_reason_type() const {
  return _internal_has_disconnect_reason_type();
}
inline void BluetoothSession::clear_disconnect_reason_type() {
  _impl_.disconnect_reason_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::bluetooth::metrics::BluetoothMetricsProto::BluetoothSession_DisconnectReasonType BluetoothSession::_internal_disconnect_reason_type() const {
  return static_cast< ::bluetooth::metrics::BluetoothMetricsProto::BluetoothSession_DisconnectReasonType >(_impl_.disconnect_reason_type_);
}
inline ::bluetooth::metrics::BluetoothMetricsProto::BluetoothSession_DisconnectReasonType BluetoothSession::disconnect_reason_type() const {
  // @@protoc_insertion_point(field_get:bluetooth.metrics.BluetoothMetricsProto.BluetoothSession.disconnect_reason_type)
  return _internal_disconnect_reason_type();
}
inline void BluetoothSession::_internal_set_disconnect_reason_type(::bluetooth::metrics::BluetoothMetricsProto::BluetoothSession_DisconnectReasonType value) {
  assert(::bluetooth::metrics::BluetoothMetricsProto::BluetoothSession_DisconnectReasonType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.disconnect_reason_type_ = value;
}
inline void BluetoothSession::set_disconnect_reason_type(::bluetooth::metrics::BluetoothMetricsProto::BluetoothSession_DisconnectReasonType value) {
  _internal_set_disconnect_reason_type(value);
  // @@protoc_insertion_point(field_set:bluetooth.metrics.BluetoothMetricsProto.BluetoothSession.disconnect_reason_type)
}

// -------------------------------------------------------------------

// RFCommSession

// optional int32 rx_bytes = 1;
inline bool RFCommSession::_internal_has_rx_bytes() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RFCommSession::has_rx_bytes() const {
  return _internal_has_rx_bytes();
}
inline void RFCommSession::clear_rx_bytes() {
  _impl_.rx_bytes_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t RFCommSession::_internal_rx_bytes() const {
  return _impl_.rx_bytes_;
}
inline ::int32_t RFCommSession::rx_bytes() const {
  // @@protoc_insertion_point(field_get:bluetooth.metrics.BluetoothMetricsProto.RFCommSession.rx_bytes)
  return _internal_rx_bytes();
}
inline void RFCommSession::_internal_set_rx_bytes(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.rx_bytes_ = value;
}
inline void RFCommSession::set_rx_bytes(::int32_t value) {
  _internal_set_rx_bytes(value);
  // @@protoc_insertion_point(field_set:bluetooth.metrics.BluetoothMetricsProto.RFCommSession.rx_bytes)
}

// optional int32 tx_bytes = 2;
inline bool RFCommSession::_internal_has_tx_bytes() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RFCommSession::has_tx_bytes() const {
  return _internal_has_tx_bytes();
}
inline void RFCommSession::clear_tx_bytes() {
  _impl_.tx_bytes_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t RFCommSession::_internal_tx_bytes() const {
  return _impl_.tx_bytes_;
}
inline ::int32_t RFCommSession::tx_bytes() const {
  // @@protoc_insertion_point(field_get:bluetooth.metrics.BluetoothMetricsProto.RFCommSession.tx_bytes)
  return _internal_tx_bytes();
}
inline void RFCommSession::_internal_set_tx_bytes(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.tx_bytes_ = value;
}
inline void RFCommSession::set_tx_bytes(::int32_t value) {
  _internal_set_tx_bytes(value);
  // @@protoc_insertion_point(field_set:bluetooth.metrics.BluetoothMetricsProto.RFCommSession.tx_bytes)
}

// -------------------------------------------------------------------

// A2DPSession

// optional int32 media_timer_min_millis = 1;
inline bool A2DPSession::_internal_has_media_timer_min_millis() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool A2DPSession::has_media_timer_min_millis() const {
  return _internal_has_media_timer_min_millis();
}
inline void A2DPSession::clear_media_timer_min_millis() {
  _impl_.media_timer_min_millis_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t A2DPSession::_internal_media_timer_min_millis() const {
  return _impl_.media_timer_min_millis_;
}
inline ::int32_t A2DPSession::media_timer_min_millis() const {
  // @@protoc_insertion_point(field_get:bluetooth.metrics.BluetoothMetricsProto.A2DPSession.media_timer_min_millis)
  return _internal_media_timer_min_millis();
}
inline void A2DPSession::_internal_set_media_timer_min_millis(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.media_timer_min_millis_ = value;
}
inline void A2DPSession::set_media_timer_min_millis(::int32_t value) {
  _internal_set_media_timer_min_millis(value);
  // @@protoc_insertion_point(field_set:bluetooth.metrics.BluetoothMetricsProto.A2DPSession.media_timer_min_millis)
}

// optional int32 media_timer_max_millis = 2;
inline bool A2DPSession::_internal_has_media_timer_max_millis() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool A2DPSession::has_media_timer_max_millis() const {
  return _internal_has_media_timer_max_millis();
}
inline void A2DPSession::clear_media_timer_max_millis() {
  _impl_.media_timer_max_millis_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t A2DPSession::_internal_media_timer_max_millis() const {
  return _impl_.media_timer_max_millis_;
}
inline ::int32_t A2DPSession::media_timer_max_millis() const {
  // @@protoc_insertion_point(field_get:bluetooth.metrics.BluetoothMetricsProto.A2DPSession.media_timer_max_millis)
  return _internal_media_timer_max_millis();
}
inline void A2DPSession::_internal_set_media_timer_max_millis(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.media_timer_max_millis_ = value;
}
inline void A2DPSession::set_media_timer_max_millis(::int32_t value) {
  _internal_set_media_timer_max_millis(value);
  // @@protoc_insertion_point(field_set:bluetooth.metrics.BluetoothMetricsProto.A2DPSession.media_timer_max_millis)
}

// optional int32 media_timer_avg_millis = 3;
inline bool A2DPSession::_internal_has_media_timer_avg_millis() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool A2DPSession::has_media_timer_avg_millis() const {
  return _internal_has_media_timer_avg_millis();
}
inline void A2DPSession::clear_media_timer_avg_millis() {
  _impl_.media_timer_avg_millis_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t A2DPSession::_internal_media_timer_avg_millis() const {
  return _impl_.media_timer_avg_millis_;
}
inline ::int32_t A2DPSession::media_timer_avg_millis() const {
  // @@protoc_insertion_point(field_get:bluetooth.metrics.BluetoothMetricsProto.A2DPSession.media_timer_avg_millis)
  return _internal_media_timer_avg_millis();
}
inline void A2DPSession::_internal_set_media_timer_avg_millis(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.media_timer_avg_millis_ = value;
}
inline void A2DPSession::set_media_timer_avg_millis(::int32_t value) {
  _internal_set_media_timer_avg_millis(value);
  // @@protoc_insertion_point(field_set:bluetooth.metrics.BluetoothMetricsProto.A2DPSession.media_timer_avg_millis)
}

// optional int32 buffer_overruns_max_count = 4;
inline bool A2DPSession::_internal_has_buffer_overruns_max_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool A2DPSession::has_buffer_overruns_max_count() const {
  return _internal_has_buffer_overruns_max_count();
}
inline void A2DPSession::clear_buffer_overruns_max_count() {
  _impl_.buffer_overruns_max_count_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int32_t A2DPSession::_internal_buffer_overruns_max_count() const {
  return _impl_.buffer_overruns_max_count_;
}
inline ::int32_t A2DPSession::buffer_overruns_max_count() const {
  // @@protoc_insertion_point(field_get:bluetooth.metrics.BluetoothMetricsProto.A2DPSession.buffer_overruns_max_count)
  return _internal_buffer_overruns_max_count();
}
inline void A2DPSession::_internal_set_buffer_overruns_max_count(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.buffer_overruns_max_count_ = value;
}
inline void A2DPSession::set_buffer_overruns_max_count(::int32_t value) {
  _internal_set_buffer_overruns_max_count(value);
  // @@protoc_insertion_point(field_set:bluetooth.metrics.BluetoothMetricsProto.A2DPSession.buffer_overruns_max_count)
}

// optional int32 buffer_overruns_total = 5;
inline bool A2DPSession::_internal_has_buffer_overruns_total() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool A2DPSession::has_buffer_overruns_total() const {
  return _internal_has_buffer_overruns_total();
}
inline void A2DPSession::clear_buffer_overruns_total() {
  _impl_.buffer_overruns_total_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int32_t A2DPSession::_internal_buffer_overruns_total() const {
  return _impl_.buffer_overruns_total_;
}
inline ::int32_t A2DPSession::buffer_overruns_total() const {
  // @@protoc_insertion_point(field_get:bluetooth.metrics.BluetoothMetricsProto.A2DPSession.buffer_overruns_total)
  return _internal_buffer_overruns_total();
}
inline void A2DPSession::_internal_set_buffer_overruns_total(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.buffer_overruns_total_ = value;
}
inline void A2DPSession::set_buffer_overruns_total(::int32_t value) {
  _internal_set_buffer_overruns_total(value);
  // @@protoc_insertion_point(field_set:bluetooth.metrics.BluetoothMetricsProto.A2DPSession.buffer_overruns_total)
}

// optional float buffer_underruns_average = 6;
inline bool A2DPSession::_internal_has_buffer_underruns_average() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool A2DPSession::has_buffer_underruns_average() const {
  return _internal_has_buffer_underruns_average();
}
inline void A2DPSession::clear_buffer_underruns_average() {
  _impl_.buffer_underruns_average_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline float A2DPSession::_internal_buffer_underruns_average() const {
  return _impl_.buffer_underruns_average_;
}
inline float A2DPSession::buffer_underruns_average() const {
  // @@protoc_insertion_point(field_get:bluetooth.metrics.BluetoothMetricsProto.A2DPSession.buffer_underruns_average)
  return _internal_buffer_underruns_average();
}
inline void A2DPSession::_internal_set_buffer_underruns_average(float value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.buffer_underruns_average_ = value;
}
inline void A2DPSession::set_buffer_underruns_average(float value) {
  _internal_set_buffer_underruns_average(value);
  // @@protoc_insertion_point(field_set:bluetooth.metrics.BluetoothMetricsProto.A2DPSession.buffer_underruns_average)
}

// optional int32 buffer_underruns_count = 7;
inline bool A2DPSession::_internal_has_buffer_underruns_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool A2DPSession::has_buffer_underruns_count() const {
  return _internal_has_buffer_underruns_count();
}
inline void A2DPSession::clear_buffer_underruns_count() {
  _impl_.buffer_underruns_count_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::int32_t A2DPSession::_internal_buffer_underruns_count() const {
  return _impl_.buffer_underruns_count_;
}
inline ::int32_t A2DPSession::buffer_underruns_count() const {
  // @@protoc_insertion_point(field_get:bluetooth.metrics.BluetoothMetricsProto.A2DPSession.buffer_underruns_count)
  return _internal_buffer_underruns_count();
}
inline void A2DPSession::_internal_set_buffer_underruns_count(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.buffer_underruns_count_ = value;
}
inline void A2DPSession::set_buffer_underruns_count(::int32_t value) {
  _internal_set_buffer_underruns_count(value);
  // @@protoc_insertion_point(field_set:bluetooth.metrics.BluetoothMetricsProto.A2DPSession.buffer_underruns_count)
}

// optional int64 audio_duration_millis = 8;
inline bool A2DPSession::_internal_has_audio_duration_millis() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool A2DPSession::has_audio_duration_millis() const {
  return _internal_has_audio_duration_millis();
}
inline void A2DPSession::clear_audio_duration_millis() {
  _impl_.audio_duration_millis_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::int64_t A2DPSession::_internal_audio_duration_millis() const {
  return _impl_.audio_duration_millis_;
}
inline ::int64_t A2DPSession::audio_duration_millis() const {
  // @@protoc_insertion_point(field_get:bluetooth.metrics.BluetoothMetricsProto.A2DPSession.audio_duration_millis)
  return _internal_audio_duration_millis();
}
inline void A2DPSession::_internal_set_audio_duration_millis(::int64_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.audio_duration_millis_ = value;
}
inline void A2DPSession::set_audio_duration_millis(::int64_t value) {
  _internal_set_audio_duration_millis(value);
  // @@protoc_insertion_point(field_set:bluetooth.metrics.BluetoothMetricsProto.A2DPSession.audio_duration_millis)
}

// optional .bluetooth.metrics.BluetoothMetricsProto.A2dpSourceCodec source_codec = 9;
inline bool A2DPSession::_internal_has_source_codec() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool A2DPSession::has_source_codec() const {
  return _internal_has_source_codec();
}
inline void A2DPSession::clear_source_codec() {
  _impl_.source_codec_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline ::bluetooth::metrics::BluetoothMetricsProto::A2dpSourceCodec A2DPSession::_internal_source_codec() const {
  return static_cast< ::bluetooth::metrics::BluetoothMetricsProto::A2dpSourceCodec >(_impl_.source_codec_);
}
inline ::bluetooth::metrics::BluetoothMetricsProto::A2dpSourceCodec A2DPSession::source_codec() const {
  // @@protoc_insertion_point(field_get:bluetooth.metrics.BluetoothMetricsProto.A2DPSession.source_codec)
  return _internal_source_codec();
}
inline void A2DPSession::_internal_set_source_codec(::bluetooth::metrics::BluetoothMetricsProto::A2dpSourceCodec value) {
  assert(::bluetooth::metrics::BluetoothMetricsProto::A2dpSourceCodec_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.source_codec_ = value;
}
inline void A2DPSession::set_source_codec(::bluetooth::metrics::BluetoothMetricsProto::A2dpSourceCodec value) {
  _internal_set_source_codec(value);
  // @@protoc_insertion_point(field_set:bluetooth.metrics.BluetoothMetricsProto.A2DPSession.source_codec)
}

// optional bool is_a2dp_offload = 10;
inline bool A2DPSession::_internal_has_is_a2dp_offload() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool A2DPSession::has_is_a2dp_offload() const {
  return _internal_has_is_a2dp_offload();
}
inline void A2DPSession::clear_is_a2dp_offload() {
  _impl_.is_a2dp_offload_ = false;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline bool A2DPSession::_internal_is_a2dp_offload() const {
  return _impl_.is_a2dp_offload_;
}
inline bool A2DPSession::is_a2dp_offload() const {
  // @@protoc_insertion_point(field_get:bluetooth.metrics.BluetoothMetricsProto.A2DPSession.is_a2dp_offload)
  return _internal_is_a2dp_offload();
}
inline void A2DPSession::_internal_set_is_a2dp_offload(bool value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.is_a2dp_offload_ = value;
}
inline void A2DPSession::set_is_a2dp_offload(bool value) {
  _internal_set_is_a2dp_offload(value);
  // @@protoc_insertion_point(field_set:bluetooth.metrics.BluetoothMetricsProto.A2DPSession.is_a2dp_offload)
}

// -------------------------------------------------------------------

// PairEvent

// optional int32 disconnect_reason = 1;
inline bool PairEvent::_internal_has_disconnect_reason() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool PairEvent::has_disconnect_reason() const {
  return _internal_has_disconnect_reason();
}
inline void PairEvent::clear_disconnect_reason() {
  _impl_.disconnect_reason_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t PairEvent::_internal_disconnect_reason() const {
  return _impl_.disconnect_reason_;
}
inline ::int32_t PairEvent::disconnect_reason() const {
  // @@protoc_insertion_point(field_get:bluetooth.metrics.BluetoothMetricsProto.PairEvent.disconnect_reason)
  return _internal_disconnect_reason();
}
inline void PairEvent::_internal_set_disconnect_reason(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.disconnect_reason_ = value;
}
inline void PairEvent::set_disconnect_reason(::int32_t value) {
  _internal_set_disconnect_reason(value);
  // @@protoc_insertion_point(field_set:bluetooth.metrics.BluetoothMetricsProto.PairEvent.disconnect_reason)
}

// optional int64 event_time_millis = 2;
inline bool PairEvent::_internal_has_event_time_millis() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PairEvent::has_event_time_millis() const {
  return _internal_has_event_time_millis();
}
inline void PairEvent::clear_event_time_millis() {
  _impl_.event_time_millis_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int64_t PairEvent::_internal_event_time_millis() const {
  return _impl_.event_time_millis_;
}
inline ::int64_t PairEvent::event_time_millis() const {
  // @@protoc_insertion_point(field_get:bluetooth.metrics.BluetoothMetricsProto.PairEvent.event_time_millis)
  return _internal_event_time_millis();
}
inline void PairEvent::_internal_set_event_time_millis(::int64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.event_time_millis_ = value;
}
inline void PairEvent::set_event_time_millis(::int64_t value) {
  _internal_set_event_time_millis(value);
  // @@protoc_insertion_point(field_set:bluetooth.metrics.BluetoothMetricsProto.PairEvent.event_time_millis)
}

// optional .bluetooth.metrics.BluetoothMetricsProto.DeviceInfo device_paired_with = 3;
inline bool PairEvent::_internal_has_device_paired_with() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.device_paired_with_ != nullptr);
  return value;
}
inline bool PairEvent::has_device_paired_with() const {
  return _internal_has_device_paired_with();
}
inline void PairEvent::clear_device_paired_with() {
  if (_impl_.device_paired_with_ != nullptr) _impl_.device_paired_with_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo& PairEvent::_internal_device_paired_with() const {
  const ::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo* p = _impl_.device_paired_with_;
  return p != nullptr ? *p : reinterpret_cast<const ::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo&>(
      ::bluetooth::metrics::BluetoothMetricsProto::_DeviceInfo_default_instance_);
}
inline const ::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo& PairEvent::device_paired_with() const {
  // @@protoc_insertion_point(field_get:bluetooth.metrics.BluetoothMetricsProto.PairEvent.device_paired_with)
  return _internal_device_paired_with();
}
inline void PairEvent::unsafe_arena_set_allocated_device_paired_with(
    ::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo* device_paired_with) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_paired_with_);
  }
  _impl_.device_paired_with_ = device_paired_with;
  if (device_paired_with) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bluetooth.metrics.BluetoothMetricsProto.PairEvent.device_paired_with)
}
inline ::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo* PairEvent::release_device_paired_with() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo* temp = _impl_.device_paired_with_;
  _impl_.device_paired_with_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo* PairEvent::unsafe_arena_release_device_paired_with() {
  // @@protoc_insertion_point(field_release:bluetooth.metrics.BluetoothMetricsProto.PairEvent.device_paired_with)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo* temp = _impl_.device_paired_with_;
  _impl_.device_paired_with_ = nullptr;
  return temp;
}
inline ::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo* PairEvent::_internal_mutable_device_paired_with() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.device_paired_with_ == nullptr) {
    auto* p = CreateMaybeMessage<::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo>(GetArenaForAllocation());
    _impl_.device_paired_with_ = p;
  }
  return _impl_.device_paired_with_;
}
inline ::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo* PairEvent::mutable_device_paired_with() {
  ::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo* _msg = _internal_mutable_device_paired_with();
  // @@protoc_insertion_point(field_mutable:bluetooth.metrics.BluetoothMetricsProto.PairEvent.device_paired_with)
  return _msg;
}
inline void PairEvent::set_allocated_device_paired_with(::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo* device_paired_with) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.device_paired_with_;
  }
  if (device_paired_with) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(device_paired_with);
    if (message_arena != submessage_arena) {
      device_paired_with = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_paired_with, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.device_paired_with_ = device_paired_with;
  // @@protoc_insertion_point(field_set_allocated:bluetooth.metrics.BluetoothMetricsProto.PairEvent.device_paired_with)
}

// -------------------------------------------------------------------

// WakeEvent

// optional .bluetooth.metrics.BluetoothMetricsProto.WakeEvent.WakeEventType wake_event_type = 1;
inline bool WakeEvent::_internal_has_wake_event_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool WakeEvent::has_wake_event_type() const {
  return _internal_has_wake_event_type();
}
inline void WakeEvent::clear_wake_event_type() {
  _impl_.wake_event_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::bluetooth::metrics::BluetoothMetricsProto::WakeEvent_WakeEventType WakeEvent::_internal_wake_event_type() const {
  return static_cast< ::bluetooth::metrics::BluetoothMetricsProto::WakeEvent_WakeEventType >(_impl_.wake_event_type_);
}
inline ::bluetooth::metrics::BluetoothMetricsProto::WakeEvent_WakeEventType WakeEvent::wake_event_type() const {
  // @@protoc_insertion_point(field_get:bluetooth.metrics.BluetoothMetricsProto.WakeEvent.wake_event_type)
  return _internal_wake_event_type();
}
inline void WakeEvent::_internal_set_wake_event_type(::bluetooth::metrics::BluetoothMetricsProto::WakeEvent_WakeEventType value) {
  assert(::bluetooth::metrics::BluetoothMetricsProto::WakeEvent_WakeEventType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.wake_event_type_ = value;
}
inline void WakeEvent::set_wake_event_type(::bluetooth::metrics::BluetoothMetricsProto::WakeEvent_WakeEventType value) {
  _internal_set_wake_event_type(value);
  // @@protoc_insertion_point(field_set:bluetooth.metrics.BluetoothMetricsProto.WakeEvent.wake_event_type)
}

// optional string requestor = 2;
inline bool WakeEvent::_internal_has_requestor() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool WakeEvent::has_requestor() const {
  return _internal_has_requestor();
}
inline void WakeEvent::clear_requestor() {
  _impl_.requestor_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& WakeEvent::requestor() const {
  // @@protoc_insertion_point(field_get:bluetooth.metrics.BluetoothMetricsProto.WakeEvent.requestor)
  return _internal_requestor();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WakeEvent::set_requestor(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.requestor_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bluetooth.metrics.BluetoothMetricsProto.WakeEvent.requestor)
}
inline std::string* WakeEvent::mutable_requestor() {
  std::string* _s = _internal_mutable_requestor();
  // @@protoc_insertion_point(field_mutable:bluetooth.metrics.BluetoothMetricsProto.WakeEvent.requestor)
  return _s;
}
inline const std::string& WakeEvent::_internal_requestor() const {
  return _impl_.requestor_.Get();
}
inline void WakeEvent::_internal_set_requestor(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.requestor_.Set(value, GetArenaForAllocation());
}
inline std::string* WakeEvent::_internal_mutable_requestor() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.requestor_.Mutable(GetArenaForAllocation());
}
inline std::string* WakeEvent::release_requestor() {
  // @@protoc_insertion_point(field_release:bluetooth.metrics.BluetoothMetricsProto.WakeEvent.requestor)
  if (!_internal_has_requestor()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.requestor_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.requestor_.IsDefault()) {
    _impl_.requestor_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void WakeEvent::set_allocated_requestor(std::string* requestor) {
  if (requestor != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.requestor_.SetAllocated(requestor, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.requestor_.IsDefault()) {
    _impl_.requestor_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bluetooth.metrics.BluetoothMetricsProto.WakeEvent.requestor)
}

// optional string name = 3;
inline bool WakeEvent::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool WakeEvent::has_name() const {
  return _internal_has_name();
}
inline void WakeEvent::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& WakeEvent::name() const {
  // @@protoc_insertion_point(field_get:bluetooth.metrics.BluetoothMetricsProto.WakeEvent.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WakeEvent::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bluetooth.metrics.BluetoothMetricsProto.WakeEvent.name)
}
inline std::string* WakeEvent::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:bluetooth.metrics.BluetoothMetricsProto.WakeEvent.name)
  return _s;
}
inline const std::string& WakeEvent::_internal_name() const {
  return _impl_.name_.Get();
}
inline void WakeEvent::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* WakeEvent::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* WakeEvent::release_name() {
  // @@protoc_insertion_point(field_release:bluetooth.metrics.BluetoothMetricsProto.WakeEvent.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void WakeEvent::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bluetooth.metrics.BluetoothMetricsProto.WakeEvent.name)
}

// optional int64 event_time_millis = 4;
inline bool WakeEvent::_internal_has_event_time_millis() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool WakeEvent::has_event_time_millis() const {
  return _internal_has_event_time_millis();
}
inline void WakeEvent::clear_event_time_millis() {
  _impl_.event_time_millis_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int64_t WakeEvent::_internal_event_time_millis() const {
  return _impl_.event_time_millis_;
}
inline ::int64_t WakeEvent::event_time_millis() const {
  // @@protoc_insertion_point(field_get:bluetooth.metrics.BluetoothMetricsProto.WakeEvent.event_time_millis)
  return _internal_event_time_millis();
}
inline void WakeEvent::_internal_set_event_time_millis(::int64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.event_time_millis_ = value;
}
inline void WakeEvent::set_event_time_millis(::int64_t value) {
  _internal_set_event_time_millis(value);
  // @@protoc_insertion_point(field_set:bluetooth.metrics.BluetoothMetricsProto.WakeEvent.event_time_millis)
}

// -------------------------------------------------------------------

// ScanEvent

// optional .bluetooth.metrics.BluetoothMetricsProto.ScanEvent.ScanEventType scan_event_type = 1;
inline bool ScanEvent::_internal_has_scan_event_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ScanEvent::has_scan_event_type() const {
  return _internal_has_scan_event_type();
}
inline void ScanEvent::clear_scan_event_type() {
  _impl_.scan_event_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::bluetooth::metrics::BluetoothMetricsProto::ScanEvent_ScanEventType ScanEvent::_internal_scan_event_type() const {
  return static_cast< ::bluetooth::metrics::BluetoothMetricsProto::ScanEvent_ScanEventType >(_impl_.scan_event_type_);
}
inline ::bluetooth::metrics::BluetoothMetricsProto::ScanEvent_ScanEventType ScanEvent::scan_event_type() const {
  // @@protoc_insertion_point(field_get:bluetooth.metrics.BluetoothMetricsProto.ScanEvent.scan_event_type)
  return _internal_scan_event_type();
}
inline void ScanEvent::_internal_set_scan_event_type(::bluetooth::metrics::BluetoothMetricsProto::ScanEvent_ScanEventType value) {
  assert(::bluetooth::metrics::BluetoothMetricsProto::ScanEvent_ScanEventType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.scan_event_type_ = value;
}
inline void ScanEvent::set_scan_event_type(::bluetooth::metrics::BluetoothMetricsProto::ScanEvent_ScanEventType value) {
  _internal_set_scan_event_type(value);
  // @@protoc_insertion_point(field_set:bluetooth.metrics.BluetoothMetricsProto.ScanEvent.scan_event_type)
}

// optional string initiator = 2;
inline bool ScanEvent::_internal_has_initiator() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ScanEvent::has_initiator() const {
  return _internal_has_initiator();
}
inline void ScanEvent::clear_initiator() {
  _impl_.initiator_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ScanEvent::initiator() const {
  // @@protoc_insertion_point(field_get:bluetooth.metrics.BluetoothMetricsProto.ScanEvent.initiator)
  return _internal_initiator();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ScanEvent::set_initiator(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.initiator_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bluetooth.metrics.BluetoothMetricsProto.ScanEvent.initiator)
}
inline std::string* ScanEvent::mutable_initiator() {
  std::string* _s = _internal_mutable_initiator();
  // @@protoc_insertion_point(field_mutable:bluetooth.metrics.BluetoothMetricsProto.ScanEvent.initiator)
  return _s;
}
inline const std::string& ScanEvent::_internal_initiator() const {
  return _impl_.initiator_.Get();
}
inline void ScanEvent::_internal_set_initiator(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.initiator_.Set(value, GetArenaForAllocation());
}
inline std::string* ScanEvent::_internal_mutable_initiator() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.initiator_.Mutable(GetArenaForAllocation());
}
inline std::string* ScanEvent::release_initiator() {
  // @@protoc_insertion_point(field_release:bluetooth.metrics.BluetoothMetricsProto.ScanEvent.initiator)
  if (!_internal_has_initiator()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.initiator_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.initiator_.IsDefault()) {
    _impl_.initiator_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ScanEvent::set_allocated_initiator(std::string* initiator) {
  if (initiator != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.initiator_.SetAllocated(initiator, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.initiator_.IsDefault()) {
    _impl_.initiator_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bluetooth.metrics.BluetoothMetricsProto.ScanEvent.initiator)
}

// optional .bluetooth.metrics.BluetoothMetricsProto.ScanEvent.ScanTechnologyType scan_technology_type = 3;
inline bool ScanEvent::_internal_has_scan_technology_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ScanEvent::has_scan_technology_type() const {
  return _internal_has_scan_technology_type();
}
inline void ScanEvent::clear_scan_technology_type() {
  _impl_.scan_technology_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::bluetooth::metrics::BluetoothMetricsProto::ScanEvent_ScanTechnologyType ScanEvent::_internal_scan_technology_type() const {
  return static_cast< ::bluetooth::metrics::BluetoothMetricsProto::ScanEvent_ScanTechnologyType >(_impl_.scan_technology_type_);
}
inline ::bluetooth::metrics::BluetoothMetricsProto::ScanEvent_ScanTechnologyType ScanEvent::scan_technology_type() const {
  // @@protoc_insertion_point(field_get:bluetooth.metrics.BluetoothMetricsProto.ScanEvent.scan_technology_type)
  return _internal_scan_technology_type();
}
inline void ScanEvent::_internal_set_scan_technology_type(::bluetooth::metrics::BluetoothMetricsProto::ScanEvent_ScanTechnologyType value) {
  assert(::bluetooth::metrics::BluetoothMetricsProto::ScanEvent_ScanTechnologyType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.scan_technology_type_ = value;
}
inline void ScanEvent::set_scan_technology_type(::bluetooth::metrics::BluetoothMetricsProto::ScanEvent_ScanTechnologyType value) {
  _internal_set_scan_technology_type(value);
  // @@protoc_insertion_point(field_set:bluetooth.metrics.BluetoothMetricsProto.ScanEvent.scan_technology_type)
}

// optional int32 number_results = 4;
inline bool ScanEvent::_internal_has_number_results() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ScanEvent::has_number_results() const {
  return _internal_has_number_results();
}
inline void ScanEvent::clear_number_results() {
  _impl_.number_results_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int32_t ScanEvent::_internal_number_results() const {
  return _impl_.number_results_;
}
inline ::int32_t ScanEvent::number_results() const {
  // @@protoc_insertion_point(field_get:bluetooth.metrics.BluetoothMetricsProto.ScanEvent.number_results)
  return _internal_number_results();
}
inline void ScanEvent::_internal_set_number_results(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.number_results_ = value;
}
inline void ScanEvent::set_number_results(::int32_t value) {
  _internal_set_number_results(value);
  // @@protoc_insertion_point(field_set:bluetooth.metrics.BluetoothMetricsProto.ScanEvent.number_results)
}

// optional int64 event_time_millis = 5;
inline bool ScanEvent::_internal_has_event_time_millis() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ScanEvent::has_event_time_millis() const {
  return _internal_has_event_time_millis();
}
inline void ScanEvent::clear_event_time_millis() {
  _impl_.event_time_millis_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int64_t ScanEvent::_internal_event_time_millis() const {
  return _impl_.event_time_millis_;
}
inline ::int64_t ScanEvent::event_time_millis() const {
  // @@protoc_insertion_point(field_get:bluetooth.metrics.BluetoothMetricsProto.ScanEvent.event_time_millis)
  return _internal_event_time_millis();
}
inline void ScanEvent::_internal_set_event_time_millis(::int64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.event_time_millis_ = value;
}
inline void ScanEvent::set_event_time_millis(::int64_t value) {
  _internal_set_event_time_millis(value);
  // @@protoc_insertion_point(field_set:bluetooth.metrics.BluetoothMetricsProto.ScanEvent.event_time_millis)
}

// -------------------------------------------------------------------

// ProfileConnectionStats

// optional .bluetooth.metrics.BluetoothMetricsProto.ProfileId profile_id = 1;
inline bool ProfileConnectionStats::_internal_has_profile_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ProfileConnectionStats::has_profile_id() const {
  return _internal_has_profile_id();
}
inline void ProfileConnectionStats::clear_profile_id() {
  _impl_.profile_id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::bluetooth::metrics::BluetoothMetricsProto::ProfileId ProfileConnectionStats::_internal_profile_id() const {
  return static_cast< ::bluetooth::metrics::BluetoothMetricsProto::ProfileId >(_impl_.profile_id_);
}
inline ::bluetooth::metrics::BluetoothMetricsProto::ProfileId ProfileConnectionStats::profile_id() const {
  // @@protoc_insertion_point(field_get:bluetooth.metrics.BluetoothMetricsProto.ProfileConnectionStats.profile_id)
  return _internal_profile_id();
}
inline void ProfileConnectionStats::_internal_set_profile_id(::bluetooth::metrics::BluetoothMetricsProto::ProfileId value) {
  assert(::bluetooth::metrics::BluetoothMetricsProto::ProfileId_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.profile_id_ = value;
}
inline void ProfileConnectionStats::set_profile_id(::bluetooth::metrics::BluetoothMetricsProto::ProfileId value) {
  _internal_set_profile_id(value);
  // @@protoc_insertion_point(field_set:bluetooth.metrics.BluetoothMetricsProto.ProfileConnectionStats.profile_id)
}

// optional int32 num_times_connected = 2;
inline bool ProfileConnectionStats::_internal_has_num_times_connected() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ProfileConnectionStats::has_num_times_connected() const {
  return _internal_has_num_times_connected();
}
inline void ProfileConnectionStats::clear_num_times_connected() {
  _impl_.num_times_connected_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t ProfileConnectionStats::_internal_num_times_connected() const {
  return _impl_.num_times_connected_;
}
inline ::int32_t ProfileConnectionStats::num_times_connected() const {
  // @@protoc_insertion_point(field_get:bluetooth.metrics.BluetoothMetricsProto.ProfileConnectionStats.num_times_connected)
  return _internal_num_times_connected();
}
inline void ProfileConnectionStats::_internal_set_num_times_connected(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.num_times_connected_ = value;
}
inline void ProfileConnectionStats::set_num_times_connected(::int32_t value) {
  _internal_set_num_times_connected(value);
  // @@protoc_insertion_point(field_set:bluetooth.metrics.BluetoothMetricsProto.ProfileConnectionStats.num_times_connected)
}

// -------------------------------------------------------------------

// HeadsetProfileConnectionStats

// optional .bluetooth.metrics.BluetoothMetricsProto.HeadsetProfileType headset_profile_type = 1;
inline bool HeadsetProfileConnectionStats::_internal_has_headset_profile_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool HeadsetProfileConnectionStats::has_headset_profile_type() const {
  return _internal_has_headset_profile_type();
}
inline void HeadsetProfileConnectionStats::clear_headset_profile_type() {
  _impl_.headset_profile_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::bluetooth::metrics::BluetoothMetricsProto::HeadsetProfileType HeadsetProfileConnectionStats::_internal_headset_profile_type() const {
  return static_cast< ::bluetooth::metrics::BluetoothMetricsProto::HeadsetProfileType >(_impl_.headset_profile_type_);
}
inline ::bluetooth::metrics::BluetoothMetricsProto::HeadsetProfileType HeadsetProfileConnectionStats::headset_profile_type() const {
  // @@protoc_insertion_point(field_get:bluetooth.metrics.BluetoothMetricsProto.HeadsetProfileConnectionStats.headset_profile_type)
  return _internal_headset_profile_type();
}
inline void HeadsetProfileConnectionStats::_internal_set_headset_profile_type(::bluetooth::metrics::BluetoothMetricsProto::HeadsetProfileType value) {
  assert(::bluetooth::metrics::BluetoothMetricsProto::HeadsetProfileType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.headset_profile_type_ = value;
}
inline void HeadsetProfileConnectionStats::set_headset_profile_type(::bluetooth::metrics::BluetoothMetricsProto::HeadsetProfileType value) {
  _internal_set_headset_profile_type(value);
  // @@protoc_insertion_point(field_set:bluetooth.metrics.BluetoothMetricsProto.HeadsetProfileConnectionStats.headset_profile_type)
}

// optional int32 num_times_connected = 2;
inline bool HeadsetProfileConnectionStats::_internal_has_num_times_connected() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool HeadsetProfileConnectionStats::has_num_times_connected() const {
  return _internal_has_num_times_connected();
}
inline void HeadsetProfileConnectionStats::clear_num_times_connected() {
  _impl_.num_times_connected_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t HeadsetProfileConnectionStats::_internal_num_times_connected() const {
  return _impl_.num_times_connected_;
}
inline ::int32_t HeadsetProfileConnectionStats::num_times_connected() const {
  // @@protoc_insertion_point(field_get:bluetooth.metrics.BluetoothMetricsProto.HeadsetProfileConnectionStats.num_times_connected)
  return _internal_num_times_connected();
}
inline void HeadsetProfileConnectionStats::_internal_set_num_times_connected(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.num_times_connected_ = value;
}
inline void HeadsetProfileConnectionStats::set_num_times_connected(::int32_t value) {
  _internal_set_num_times_connected(value);
  // @@protoc_insertion_point(field_set:bluetooth.metrics.BluetoothMetricsProto.HeadsetProfileConnectionStats.num_times_connected)
}

// -------------------------------------------------------------------

// BluetoothRemoteDeviceInformation

// optional string allowlisted_device_name_hash = 1;
inline bool BluetoothRemoteDeviceInformation::_internal_has_allowlisted_device_name_hash() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BluetoothRemoteDeviceInformation::has_allowlisted_device_name_hash() const {
  return _internal_has_allowlisted_device_name_hash();
}
inline void BluetoothRemoteDeviceInformation::clear_allowlisted_device_name_hash() {
  _impl_.allowlisted_device_name_hash_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BluetoothRemoteDeviceInformation::allowlisted_device_name_hash() const {
  // @@protoc_insertion_point(field_get:bluetooth.metrics.BluetoothMetricsProto.BluetoothRemoteDeviceInformation.allowlisted_device_name_hash)
  return _internal_allowlisted_device_name_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BluetoothRemoteDeviceInformation::set_allowlisted_device_name_hash(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.allowlisted_device_name_hash_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bluetooth.metrics.BluetoothMetricsProto.BluetoothRemoteDeviceInformation.allowlisted_device_name_hash)
}
inline std::string* BluetoothRemoteDeviceInformation::mutable_allowlisted_device_name_hash() {
  std::string* _s = _internal_mutable_allowlisted_device_name_hash();
  // @@protoc_insertion_point(field_mutable:bluetooth.metrics.BluetoothMetricsProto.BluetoothRemoteDeviceInformation.allowlisted_device_name_hash)
  return _s;
}
inline const std::string& BluetoothRemoteDeviceInformation::_internal_allowlisted_device_name_hash() const {
  return _impl_.allowlisted_device_name_hash_.Get();
}
inline void BluetoothRemoteDeviceInformation::_internal_set_allowlisted_device_name_hash(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.allowlisted_device_name_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* BluetoothRemoteDeviceInformation::_internal_mutable_allowlisted_device_name_hash() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.allowlisted_device_name_hash_.Mutable(GetArenaForAllocation());
}
inline std::string* BluetoothRemoteDeviceInformation::release_allowlisted_device_name_hash() {
  // @@protoc_insertion_point(field_release:bluetooth.metrics.BluetoothMetricsProto.BluetoothRemoteDeviceInformation.allowlisted_device_name_hash)
  if (!_internal_has_allowlisted_device_name_hash()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.allowlisted_device_name_hash_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.allowlisted_device_name_hash_.IsDefault()) {
    _impl_.allowlisted_device_name_hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void BluetoothRemoteDeviceInformation::set_allocated_allowlisted_device_name_hash(std::string* allowlisted_device_name_hash) {
  if (allowlisted_device_name_hash != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.allowlisted_device_name_hash_.SetAllocated(allowlisted_device_name_hash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.allowlisted_device_name_hash_.IsDefault()) {
    _impl_.allowlisted_device_name_hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bluetooth.metrics.BluetoothMetricsProto.BluetoothRemoteDeviceInformation.allowlisted_device_name_hash)
}

// optional int32 class_of_device = 2;
inline bool BluetoothRemoteDeviceInformation::_internal_has_class_of_device() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool BluetoothRemoteDeviceInformation::has_class_of_device() const {
  return _internal_has_class_of_device();
}
inline void BluetoothRemoteDeviceInformation::clear_class_of_device() {
  _impl_.class_of_device_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t BluetoothRemoteDeviceInformation::_internal_class_of_device() const {
  return _impl_.class_of_device_;
}
inline ::int32_t BluetoothRemoteDeviceInformation::class_of_device() const {
  // @@protoc_insertion_point(field_get:bluetooth.metrics.BluetoothMetricsProto.BluetoothRemoteDeviceInformation.class_of_device)
  return _internal_class_of_device();
}
inline void BluetoothRemoteDeviceInformation::_internal_set_class_of_device(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.class_of_device_ = value;
}
inline void BluetoothRemoteDeviceInformation::set_class_of_device(::int32_t value) {
  _internal_set_class_of_device(value);
  // @@protoc_insertion_point(field_set:bluetooth.metrics.BluetoothMetricsProto.BluetoothRemoteDeviceInformation.class_of_device)
}

// optional int32 oui = 3;
inline bool BluetoothRemoteDeviceInformation::_internal_has_oui() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool BluetoothRemoteDeviceInformation::has_oui() const {
  return _internal_has_oui();
}
inline void BluetoothRemoteDeviceInformation::clear_oui() {
  _impl_.oui_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t BluetoothRemoteDeviceInformation::_internal_oui() const {
  return _impl_.oui_;
}
inline ::int32_t BluetoothRemoteDeviceInformation::oui() const {
  // @@protoc_insertion_point(field_get:bluetooth.metrics.BluetoothMetricsProto.BluetoothRemoteDeviceInformation.oui)
  return _internal_oui();
}
inline void BluetoothRemoteDeviceInformation::_internal_set_oui(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.oui_ = value;
}
inline void BluetoothRemoteDeviceInformation::set_oui(::int32_t value) {
  _internal_set_oui(value);
  // @@protoc_insertion_point(field_set:bluetooth.metrics.BluetoothMetricsProto.BluetoothRemoteDeviceInformation.oui)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace BluetoothMetricsProto
}  // namespace metrics
}  // namespace bluetooth

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::bluetooth::metrics::BluetoothMetricsProto::DeviceInfo_DeviceType> : ::std::true_type {};
template <> struct is_proto_enum< ::bluetooth::metrics::BluetoothMetricsProto::BluetoothSession_ConnectionTechnologyType> : ::std::true_type {};
template <> struct is_proto_enum< ::bluetooth::metrics::BluetoothMetricsProto::BluetoothSession_DisconnectReasonType> : ::std::true_type {};
template <> struct is_proto_enum< ::bluetooth::metrics::BluetoothMetricsProto::WakeEvent_WakeEventType> : ::std::true_type {};
template <> struct is_proto_enum< ::bluetooth::metrics::BluetoothMetricsProto::ScanEvent_ScanTechnologyType> : ::std::true_type {};
template <> struct is_proto_enum< ::bluetooth::metrics::BluetoothMetricsProto::ScanEvent_ScanEventType> : ::std::true_type {};
template <> struct is_proto_enum< ::bluetooth::metrics::BluetoothMetricsProto::A2dpSourceCodec> : ::std::true_type {};
template <> struct is_proto_enum< ::bluetooth::metrics::BluetoothMetricsProto::ProfileId> : ::std::true_type {};
template <> struct is_proto_enum< ::bluetooth::metrics::BluetoothMetricsProto::HeadsetProfileType> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_packages_2fmodules_2fBluetooth_2fsystem_2fgd_2fproto_2fbluetooth_2fmetrics_2fbluetooth_2eproto
